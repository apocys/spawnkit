<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SpawnKit Village â€” Kenney Mini Characters</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#1a1a2e; overflow:hidden; font-family:'Press Start 2P',monospace; }
  canvas { display:block; image-rendering:pixelated; image-rendering:crisp-edges; cursor:grab; }
  canvas.dragging { cursor:grabbing; }

  /* â”€â”€â”€ Top Bar â”€â”€â”€ */
  #topbar {
    position:fixed; top:0; left:0; right:0; height:36px; z-index:100;
    background:rgba(20,20,40,0.92); border-bottom:2px solid #3a5; display:flex;
    align-items:center; padding:0 12px; gap:12px;
  }
  #topbar .title { color:#5f8; font-size:10px; letter-spacing:2px; }
  #topbar .mode { color:#fa5; font-size:7px; padding:2px 6px; border:1px solid #fa5; border-radius:3px; }
  #topbar .sep { flex:1; }
  #topbar .zoom-info { color:#8ab; font-size:7px; }

  /* â”€â”€â”€ Bottom Bar â”€â”€â”€ */
  #bottombar {
    position:fixed; bottom:0; left:0; right:0; min-height:32px; z-index:100;
    background:rgba(20,20,40,0.92); border-top:2px solid #3a5; display:flex;
    align-items:center; padding:0 8px; gap:10px; font-size:6px; color:#8ab;
    flex-wrap:wrap;
  }
  .agent-stat { display:flex; align-items:center; gap:4px; cursor:pointer; padding:2px 4px; border-radius:3px; }
  .agent-stat:hover { background:rgba(60,170,90,0.15); }
  .agent-stat .dot { width:7px; height:7px; border-radius:50%; flex-shrink:0; }
  .agent-stat .aname { color:#cde; }
  .agent-stat .atask { color:#8ab; max-width:100px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

  /* â”€â”€â”€ Agent Detail Panel â”€â”€â”€ */
  #agent-panel {
    position:fixed; top:36px; right:0; width:260px; bottom:32px; z-index:99;
    background:rgba(20,20,40,0.97); border-left:2px solid #3a5;
    transform:translateX(100%); transition:transform .3s ease;
    padding:16px; overflow-y:auto; color:#cde;
  }
  #agent-panel.open { transform:translateX(0); }
  #agent-panel h2 { font-size:10px; color:#5f8; margin-bottom:6px; }
  #agent-panel .role { font-size:7px; color:#fa5; margin-bottom:10px; }
  #agent-panel .field { font-size:7px; margin-bottom:5px; line-height:1.6; }
  #agent-panel .field label { color:#8ab; }
  #agent-panel .close-btn {
    position:absolute; top:8px; right:8px; background:none; border:1px solid #f55;
    color:#f55; font-size:8px; cursor:pointer; padding:2px 6px; font-family:inherit;
  }
  #agent-panel .task-list { margin-top:8px; }
  #agent-panel .task { font-size:6px; color:#acd; padding:4px; background:rgba(50,70,50,0.3); margin-bottom:3px; border-left:2px solid #3a5; }
  #agent-panel .anim-info { font-size:6px; color:#7bc; margin-top:8px; padding:6px; background:rgba(30,50,80,0.4); border:1px solid #3a5; border-radius:3px; }
</style>
</head>
<body>

<div id="topbar">
  <span class="title">ğŸŒ¿ SPAWNKIT VILLAGE</span>
  <span class="mode" id="mode-badge">VILLAGE</span>
  <span class="sep"></span>
  <span id="zoom-info" class="zoom-info">100%</span>
</div>

<canvas id="game"></canvas>

<div id="bottombar" id="bottombar-inner">
  <!-- populated by JS -->
</div>

<div id="agent-panel">
  <button class="close-btn" onclick="closePanel()">âœ•</button>
  <h2 id="panel-name">â€”</h2>
  <div class="role" id="panel-role">â€”</div>
  <div class="field"><label>Status: </label><span id="panel-status">â€”</span></div>
  <div class="field"><label>Animation: </label><span id="panel-anim">â€”</span></div>
  <div class="field"><label>Location: </label><span id="panel-location">â€”</span></div>
  <div class="field"><label>Current Task: </label></div>
  <div class="task-list" id="panel-tasks"></div>
  <div class="anim-info" id="panel-anim-info">â€”</div>
</div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TILE = 16;
const SCALE = 2;
const T = TILE * SCALE;       // 32px rendered tile
const FPS_ANIM = 8;
const MOVE_SPEED = 1.0;       // tiles/second
const SPRITE_SRC_SIZE = 256;  // Kenney sprites are 256Ã—256
const SPRITE_DRAW_SIZE = 50;  // draw size in world pixels (better proportion to buildings)
const SPRITE_FRAMES = 8;     // 8 frames per animation
const SEPARATION_RADIUS = 1.5;
const SEPARATION_FORCE = 1.8;

// Isometric directions
const DIRECTIONS = ['SE', 'SW', 'NE', 'NW'];

// All environment assets relative to THIS file â†’ ../office-green-iso/assets/
const ASSETS = '../office-green-iso/assets/';

// Kenney sprites relative to THIS file
const SPRITE_BASE = 'assets/rendered-sprites/';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KENNEY SPRITE LOADER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Path: {SPRITE_BASE}{charModel}/{animType}_{charModel}/{direction}/frame_{NNN}.png
// e.g.: assets/rendered-sprites/character-male-a/idle_character-male-a/SE/frame_000.png

const spriteCache = {};    // key -> Image
let loadedCount = 0;
let totalImages = 0;

function loadImage(path) {
  if (spriteCache[path]) return spriteCache[path];
  totalImages++;
  const img = new Image();
  img.src = path;
  img.onload = () => { loadedCount++; };
  img.onerror = () => { console.warn('Failed to load:', path); loadedCount++; };
  spriteCache[path] = img;
  return img;
}

// Load environment image (uses ASSETS prefix)
function loadEnvImage(path) {
  return loadImage(ASSETS + path);
}

// Load a full sprite set for a character model: idle + walk, 4 dirs, 8 frames
// Returns { idle: { SE: [img0..7], SW: [...], ... }, walk: { SE: [...], ... } }
function loadCharacterSprites(charModel) {
  const set = { idle: {}, walk: {} };
  for (const animType of ['idle', 'walk']) {
    for (const dir of DIRECTIONS) {
      set[animType][dir] = [];
      for (let f = 0; f < SPRITE_FRAMES; f++) {
        const fStr = String(f).padStart(3, '0');
        const path = `${SPRITE_BASE}${charModel}/${animType}_${charModel}/${dir}/frame_${fStr}.png`;
        set[animType][dir].push(loadImage(path));
      }
    }
  }
  return set;
}

// Agent â†’ Character model mapping
const CHARACTER_MODELS = {
  apomac:   'character-male-a',
  forge:    'character-male-c',
  hunter:   'character-male-d',
  atlas:    'character-female-a',
  echo:     'character-female-c',
  sentinel: 'character-male-e',
};

// Preload all character sprites
const characterSprites = {};
for (const [agentId, charModel] of Object.entries(CHARACTER_MODELS)) {
  characterSprites[agentId] = loadCharacterSprites(charModel);
}

// Environment images
const IMG = {
  floorTiles:  loadEnvImage('Environment/Tilesets/Floors_Tiles.png'),
  waterTiles:  loadEnvImage('Environment/Tilesets/Water_tiles.png'),
  wallTiles:   loadEnvImage('Environment/Tilesets/Wall_Tiles.png'),
  buildWalls:  loadEnvImage('Environment/Structures/Buildings/Walls.png'),
  buildFloors: loadEnvImage('Environment/Structures/Buildings/Floors.png'),
  buildRoofs:  loadEnvImage('Environment/Structures/Buildings/Roofs.png'),
  buildProps:  loadEnvImage('Environment/Structures/Buildings/Props.png'),
  tree1:       loadEnvImage('Environment/Props/Static/Trees/Model_01/Size_03.png'),
  tree2:       loadEnvImage('Environment/Props/Static/Trees/Model_02/Size_03.png'),
  tree3:       loadEnvImage('Environment/Props/Static/Trees/Model_03/Size_02.png'),
  anvil:       loadEnvImage('Environment/Structures/Stations/Anvil/Anvil.png'),
  workbench:   loadEnvImage('Environment/Structures/Stations/Workbench/Workbench.png'),
  bonfire:     loadEnvImage('Environment/Structures/Stations/Bonfire/Bonfire.png'),
  sawmill:     loadEnvImage('Environment/Structures/Stations/Sawmill/Base.png'),
  shadows:     loadEnvImage('Environment/Props/Static/Shadows.png'),
};

// â”€â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAP_W = 42;
const MAP_H = 42;

const tileMap = [];
for (let y = 0; y < MAP_H; y++) {
  tileMap[y] = new Uint8Array(MAP_W);
}

const RIVER_ROW_START = 28;
const RIVER_ROW_END   = 30;

function buildTileMap() {
  for (let y = 2; y < MAP_H - 2; y++) {
    tileMap[y][20] = (y >= RIVER_ROW_START && y <= RIVER_ROW_END) ? 2 : 3;
    tileMap[y][21] = (y >= RIVER_ROW_START && y <= RIVER_ROW_END) ? 2 : 3;
  }
  for (let x = 2; x < MAP_W - 2; x++) {
    tileMap[16][x] = 3;
    tileMap[17][x] = 3;
  }
  for (let x = 2; x < MAP_W - 2; x++) {
    tileMap[33][x] = 3;
    tileMap[34][x] = 3;
  }
  for (let x = 0; x < MAP_W; x++) {
    for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
      tileMap[ry][x] = 2;
    }
  }
  for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
    tileMap[ry][20] = 3;
    tileMap[ry][21] = 3;
  }
}

buildTileMap();

function isWalkable(tx, ty) {
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return false;
  const t = tileMap[ty][tx];
  return t === 0 || t === 3;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// A* PATHFINDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findPath(sx, sy, ex, ey) {
  sx = Math.round(sx); sy = Math.round(sy);
  ex = Math.round(ex); ey = Math.round(ey);
  if (!isWalkable(ex, ey)) {
    for (const [dx,dy] of [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]) {
      if (isWalkable(ex+dx, ey+dy)) { ex += dx; ey += dy; break; }
    }
    if (!isWalkable(ex, ey)) return null;
  }
  if (sx === ex && sy === ey) return [];

  const open = [{ x:sx, y:sy, g:0, h:0, f:0, parent:null }];
  const closed = new Set();
  const key = (x,y) => y * MAP_W + x;
  const gScores = new Map();
  gScores.set(key(sx,sy), 0);

  while (open.length > 0) {
    open.sort((a,b) => a.f - b.f);
    const cur = open.shift();
    if (cur.x === ex && cur.y === ey) {
      const path = [];
      let n = cur;
      while (n.parent) { path.unshift({x:n.x, y:n.y}); n = n.parent; }
      return path;
    }
    closed.add(key(cur.x, cur.y));
    for (const [dx,dy] of [[0,-1],[0,1],[-1,0],[1,0],[-1,-1],[-1,1],[1,-1],[1,1]]) {
      const nx = cur.x+dx, ny = cur.y+dy;
      if (!isWalkable(nx, ny)) continue;
      const k = key(nx, ny);
      if (closed.has(k)) continue;
      if (dx !== 0 && dy !== 0) {
        if (!isWalkable(cur.x+dx, cur.y) || !isWalkable(cur.x, cur.y+dy)) continue;
      }
      const g = cur.g + (dx !== 0 && dy !== 0 ? 1.414 : 1);
      if (gScores.has(k) && g >= gScores.get(k)) continue;
      gScores.set(k, g);
      const h = Math.abs(nx-ex) + Math.abs(ny-ey);
      open.push({ x:nx, y:ny, g, h, f:g+h, parent:cur });
    }
  }
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUILDINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BUILDINGS = [
  { id:'smithy',   x:5,  y:4,  w:8, h:7, label:'Smithy',    color:'#c84' },
  { id:'workshop', x:28, y:4,  w:8, h:7, label:'Workshop',   color:'#8ac' },
  { id:'sawhouse', x:5,  y:22, w:8, h:7, label:'Sawmill',    color:'#6a4' },
  { id:'lodge',    x:28, y:22, w:8, h:7, label:'River Lodge', color:'#4aa' },
];

const PATROL_ROUTES = {
  hunter: [
    [20, 8], [20, 13], [20, 16], [28, 16], [35, 16],
    [35, 8], [28, 8], [20, 8],
  ],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ISOMETRIC DIRECTION HELPER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Map a movement vector (dx, dy) to one of SE/SW/NE/NW
// In screen coords: +x = right, +y = down
// SE = right+down, SW = left+down, NE = right+up, NW = left+up
function vectorToIsoDirection(dx, dy) {
  if (dx >= 0 && dy >= 0) return 'SE';
  if (dx < 0  && dy >= 0) return 'SW';
  if (dx >= 0 && dy < 0)  return 'NE';
  return 'NW';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FOOTSTEP SYSTEM (Environmental Integration)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const footsteps = []; // Array of {x, y, age, fade}

function addFootstep(x, y) {
  footsteps.push({ x, y, age: 0, fade: 1 });
  // Keep only recent footsteps
  if (footsteps.length > 50) {
    footsteps.shift();
  }
}

function updateFootsteps(dt) {
  for (let i = footsteps.length - 1; i >= 0; i--) {
    const step = footsteps[i];
    step.age += dt;
    step.fade = Math.max(0, 1 - step.age / 15); // fade over 15 seconds
    if (step.fade <= 0) {
      footsteps.splice(i, 1);
    }
  }
}

function renderFootsteps(ctx) {
  if (footsteps.length === 0) return;
  ctx.save();
  for (const step of footsteps) {
    ctx.fillStyle = `rgba(101, 85, 63, ${step.fade * 0.3})`;
    ctx.beginPath();
    ctx.ellipse(step.x * T, step.y * T, 3, 1.5, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENT CLASS (Kenney Mini Characters)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Agent {
  constructor(cfg) {
    this.id        = cfg.id;
    this.name      = cfg.name;
    this.role      = cfg.role;
    this.tint      = cfg.tint;
    this.homeX     = cfg.homeX;
    this.homeY     = cfg.homeY;
    this.label     = cfg.label || cfg.name;
    this.dotColor  = cfg.tint;

    this.x         = cfg.homeX;
    this.y         = cfg.homeY;
    this.direction  = 'SE';        // isometric direction
    this.animType   = 'idle';      // 'idle' or 'walk'
    this.animFrame  = 0;
    this.animTimer  = 0;
    this.status     = 'idle';
    this.currentTask = cfg.defaultTask || 'Standing by';

    this.path      = [];
    this.pathIdx   = 0;

    this.patrolRoute  = cfg.patrolRoute || null;
    this.patrolIdx    = 0;
    this.isPatrolling = cfg.patrolRoute != null;

    this.speechText  = '';
    this.speechTimer = 0;

    // Work idle timer (cycle between idle directions periodically)
    this.workTimer    = Math.random() * 5;
    this.workInterval = 3 + Math.random() * 4;
    this.isWorking    = cfg.startWorking || false;

    // Sprites for this agent
    this.sprites = characterSprites[cfg.id];
  }

  say(text, dur) {
    this.speechText  = text;
    this.speechTimer = dur || 3;
  }

  walkTo(tx, ty) {
    const path = findPath(Math.round(this.x), Math.round(this.y), tx, ty);
    if (path && path.length > 0) {
      this.path = path;
      this.pathIdx = 0;
      this.status = 'walking';
      this.animType = 'walk';
    }
  }

  update(dt, allAgents) {
    // Animation tick
    this.animTimer += dt;
    if (this.animTimer >= 1 / FPS_ANIM) {
      this.animTimer -= 1 / FPS_ANIM;
      this.animFrame = (this.animFrame + 1) % SPRITE_FRAMES;
    }

    // Path following
    if (this.path.length > 0 && this.pathIdx < this.path.length) {
      const tgt = this.path[this.pathIdx];
      const dx = tgt.x - this.x;
      const dy = tgt.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 0.12) {
        this.x = tgt.x; this.y = tgt.y;
        this.pathIdx++;
        if (this.pathIdx >= this.path.length) {
          this.path = [];
          this.pathIdx = 0;
          this.onArrival();
        }
      } else {
        const speed = MOVE_SPEED * dt;
        const oldX = this.x, oldY = this.y;
        this.x += (dx/dist) * Math.min(speed, dist);
        this.y += (dy/dist) * Math.min(speed, dist);
        this.direction = vectorToIsoDirection(dx, dy);
        this.animType = 'walk';
        
        // Add footstep markers every ~0.8 tiles traveled
        const distMoved = Math.sqrt((this.x - oldX) ** 2 + (this.y - oldY) ** 2);
        if (!this.lastFootstepX) this.lastFootstepX = this.x;
        if (!this.lastFootstepY) this.lastFootstepY = this.y;
        const stepDist = Math.sqrt((this.x - this.lastFootstepX) ** 2 + (this.y - this.lastFootstepY) ** 2);
        if (stepDist > 0.8) {
          addFootstep(this.x, this.y + 0.9); // position at agent feet
          this.lastFootstepX = this.x;
          this.lastFootstepY = this.y;
        }
      }
    }

    // Separation from other agents
    let sepX = 0, sepY = 0;
    for (const other of allAgents) {
      if (other === this) continue;
      const dx = this.x - other.x;
      const dy = this.y - other.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < SEPARATION_RADIUS && d > 0.01) {
        const f = (SEPARATION_RADIUS - d) / SEPARATION_RADIUS;
        sepX += (dx/d) * f;
        sepY += (dy/d) * f;
      }
    }
    if (sepX || sepY) {
      const nx = this.x + sepX * SEPARATION_FORCE * dt;
      const ny = this.y + sepY * SEPARATION_FORCE * dt;
      if (isWalkable(Math.round(nx), Math.round(ny))) {
        this.x = nx; this.y = ny;
      } else if (isWalkable(Math.round(nx), Math.round(this.y))) {
        this.x = nx;
      } else if (isWalkable(Math.round(this.x), Math.round(ny))) {
        this.y = ny;
      }
    }

    // Work animation: periodically change facing direction when idle at home
    if (this.path.length === 0 && this.isWorking) {
      this.workTimer += dt;
      if (this.workTimer >= this.workInterval) {
        this.workTimer = 0;
        this.workInterval = 2 + Math.random() * 3;
        // Rotate to a random direction for visual interest
        this.direction = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
      }
    }

    // Patrol logic
    if (this.isPatrolling && this.path.length === 0) {
      const wp = this.patrolRoute[this.patrolIdx % this.patrolRoute.length];
      const dx = wp[0] - this.x, dy = wp[1] - this.y;
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
        this.patrolIdx = (this.patrolIdx + 1) % this.patrolRoute.length;
      } else {
        this.walkTo(wp[0], wp[1]);
      }
    }

    // Speech timer
    if (this.speechTimer > 0) {
      this.speechTimer -= dt;
      if (this.speechTimer <= 0) this.speechText = '';
    }
  }

  onArrival() {
    if (this.isPatrolling) {
      this.patrolIdx = (this.patrolIdx + 1) % this.patrolRoute.length;
      setTimeout(() => {
        if (this.isPatrolling) {
          const wp = this.patrolRoute[this.patrolIdx % this.patrolRoute.length];
          this.walkTo(wp[0], wp[1]);
        }
      }, 800 + Math.random() * 600);
    }
    // Go to idle
    this.animType = 'idle';
    this.animFrame = 0;
    this.status = this.isWorking ? 'working' : 'idle';
  }

  draw(ctx) {
    if (!this.sprites) return;
    const animSet = this.sprites[this.animType];
    if (!animSet) return;
    const frames = animSet[this.direction];
    if (!frames) return;
    const frame = this.animFrame % frames.length;
    const img = frames[frame];
    if (!img || !img.complete || !img.naturalWidth) return;

    const drawW = SPRITE_DRAW_SIZE;
    const drawH = SPRITE_DRAW_SIZE;
    // Center sprite on tile, anchor at bottom-center
    const px = this.x * T - drawW / 2 + T / 2;
    const py = this.y * T - drawH + T + 4; // +4 to ground the feet

    // Draw shadow FIRST (underneath character)
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    // Shadow centered at agent's feet, 40px wide Ã— 15px tall ellipse
    const shadowX = this.x * T + T / 2;
    const shadowY = this.y * T + T - 2; // slightly above ground level
    ctx.ellipse(shadowX, shadowY, 20, 7.5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Draw character sprite with warm sepia tint to match village palette
    ctx.save();
    ctx.imageSmoothingEnabled = true; // smooth scaling from 256 to 56
    
    // Apply warm sepia tint overlay to match medieval village
    ctx.filter = 'sepia(25%) saturate(110%) brightness(105%) hue-rotate(-10deg)';
    ctx.drawImage(img, 0, 0, SPRITE_SRC_SIZE, SPRITE_SRC_SIZE, px, py, drawW, drawH);
    ctx.filter = 'none';
    ctx.restore();

    // Add small dust puff when walking for environmental integration
    if (this.animType === 'walk' && this.animFrame === 3) { // mid-step frame
      this.drawDustPuff(ctx);
    }

    // Status diamond
    const indicatorX = this.x * T + T / 2;
    const indicatorY = py - 6;
    const bob = Math.sin(Date.now() / 300 + this.x * 3.7) * 2;

    ctx.save();
    ctx.translate(indicatorX, indicatorY + bob);
    ctx.beginPath();
    ctx.moveTo(0, -5); ctx.lineTo(4, 0); ctx.lineTo(0, 5); ctx.lineTo(-4, 0);
    ctx.closePath();
    const dotColors = { idle:'#fd5', working:'#5f8', walking:'#5bf' };
    ctx.fillStyle = dotColors[this.status] || '#fff';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // Name label
    ctx.save();
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';
    const nw = ctx.measureText(this.name).width;
    const pillX = indicatorX - nw/2 - 4;
    const pillY = indicatorY - 18 + bob;
    const pillW = nw + 8;
    const pillH = 12;
    ctx.fillStyle = 'rgba(10,10,25,0.80)';
    roundRect(ctx, pillX, pillY, pillW, pillH, 4);
    ctx.fill();
    ctx.strokeStyle = this.tint;
    ctx.lineWidth = 1;
    roundRect(ctx, pillX, pillY, pillW, pillH, 4);
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.fillText(this.name, indicatorX, pillY + 9);
    ctx.restore();

    // Speech bubble
    if (this.speechText) {
      drawSpeechBubble(ctx, indicatorX, indicatorY - 22 + bob, this.speechText);
    }
  }

  drawDustPuff(ctx) {
    // Small dust puffs when walking on dirt paths for environmental integration
    const dustX = this.x * T + T/2 + (Math.random() - 0.5) * 8;
    const dustY = this.y * T + T - 4 + (Math.random() - 0.5) * 4;
    
    ctx.save();
    ctx.fillStyle = 'rgba(139, 117, 85, 0.4)'; // dusty brown color
    ctx.beginPath();
    ctx.arc(dustX, dustY, 2 + Math.random(), 0, Math.PI * 2);
    ctx.fill();
    
    // Smaller secondary dust particles
    for (let i = 0; i < 2; i++) {
      ctx.beginPath();
      const px = dustX + (Math.random() - 0.5) * 6;
      const py = dustY + (Math.random() - 0.5) * 6;
      ctx.arc(px, py, 0.5 + Math.random() * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  containsPoint(wx, wy) {
    const drawW = SPRITE_DRAW_SIZE;
    const drawH = SPRITE_DRAW_SIZE;
    const sx = this.x * T - drawW/2 + T/2;
    const sy = this.y * T - drawH + T + 4;
    return wx >= sx && wx < sx+drawW && wy >= sy && wy < sy+drawH;
  }
}

// â”€â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y, x+w,y+r); ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h, x+w-r,y+h); ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h, x,y+h-r); ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y, x+r,y);
  ctx.closePath();
}

function wrapText(ctx, text, maxW) {
  const words = text.split(' ');
  const lines = [];
  let line = '';
  for (const w of words) {
    const test = line ? line + ' ' + w : w;
    if (ctx.measureText(test).width > maxW && line) {
      lines.push(line); line = w;
    } else { line = test; }
  }
  if (line) lines.push(line);
  return lines.length ? lines : [''];
}

function drawSpeechBubble(ctx, bx, by, text) {
  ctx.save();
  ctx.font = '6px "Press Start 2P"';
  const lines = wrapText(ctx, text, 90);
  const lineH = 9;
  const padX = 5, padY = 3;
  const bw = Math.max(...lines.map(l => ctx.measureText(l).width)) + padX*2;
  const bh = lines.length * lineH + padY*2;
  const rx = bx - bw/2, ry = by - bh;
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  roundRect(ctx, rx, ry, bw, bh, 3);
  ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx-3,by); ctx.lineTo(bx,by+5); ctx.lineTo(bx+3,by);
  ctx.fillStyle = 'rgba(255,255,255,0.92)'; ctx.fill();
  ctx.fillStyle = '#222';
  ctx.textAlign = 'left';
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], rx+padX, ry+padY+lineH*(i+0.7));
  }
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VILLAGE AGENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const agents = [];

const AGENT_DEFS = [
  {
    id:'apomac', name:'ApoMac', role:'CEO / Architect',
    tint:'#4488ff',
    homeX:30, homeY:7,
    defaultTask:'Building the future',
    startWorking:true,
    label:'ApoMac',
  },
  {
    id:'forge', name:'Forge', role:'CTO / Blacksmith',
    tint:'#ff3322',
    homeX:8, homeY:7,
    defaultTask:'Forging tools',
    startWorking:true,
    label:'Forge',
  },
  {
    id:'hunter', name:'Hunter', role:'CRO / Scout',
    tint:'#33cc44',
    homeX:20, homeY:12,
    defaultTask:'Patrolling the village',
    startWorking:false,
    patrolRoute: PATROL_ROUTES.hunter,
    label:'Hunter',
  },
  {
    id:'atlas', name:'Atlas', role:'COO / Forester',
    tint:'#ddaa00',
    homeX:4, homeY:14,
    defaultTask:'Managing operations',
    startWorking:true,
    label:'Atlas',
  },
  {
    id:'echo', name:'Echo', role:'CMO / Herbalist',
    tint:'#aa44ff',
    homeX:22, homeY:31,
    defaultTask:'Tending the riverside',
    startWorking:true,
    label:'Echo',
  },
  {
    id:'sentinel', name:'Sentinel', role:'Auditor / Fisher',
    tint:'#00ccdd',
    homeX:19, homeY:31,
    defaultTask:'Watching the river',
    startWorking:true,
    label:'Sentinel',
  },
];

for (const def of AGENT_DEFS) {
  agents.push(new Agent(def));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCENE PROPS (stations, trees, decorations)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TREES = [
  // Top border
  {m:0, x:1,  y:0,  s:'large'},
  {m:1, x:7,  y:-1, s:'large'},
  {m:2, x:13, y:0,  s:'large'},
  {m:0, x:19, y:-1, s:'large'},
  {m:1, x:25, y:0,  s:'large'},
  {m:2, x:31, y:-1, s:'large'},
  {m:0, x:37, y:0,  s:'large'},
  // Bottom border
  {m:1, x:1,  y:39, s:'medium'},
  {m:2, x:7,  y:40, s:'medium'},
  {m:0, x:14, y:39, s:'medium'},
  {m:1, x:22, y:40, s:'medium'},
  {m:2, x:29, y:39, s:'medium'},
  {m:0, x:36, y:40, s:'medium'},
  // Left border
  {m:0, x:0,  y:5,  s:'medium'},
  {m:1, x:-1, y:11, s:'medium'},
  {m:2, x:0,  y:17, s:'medium'},
  {m:0, x:-1, y:23, s:'medium'},
  {m:1, x:0,  y:29, s:'medium'},
  {m:2, x:-1, y:35, s:'medium'},
  // Right border
  {m:2, x:40, y:4,  s:'medium'},
  {m:0, x:41, y:10, s:'medium'},
  {m:1, x:40, y:16, s:'medium'},
  {m:2, x:41, y:22, s:'medium'},
  {m:0, x:40, y:28, s:'medium'},
  {m:1, x:41, y:34, s:'medium'},
  // Cluster near sawmill (SW)
  {m:2, x:2,  y:20, s:'large'},
  {m:0, x:4,  y:19, s:'medium'},
  {m:1, x:2,  y:18, s:'medium'},
  // Cluster near river (S)
  {m:0, x:10, y:35, s:'medium'},
  {m:2, x:16, y:36, s:'medium'},
  {m:1, x:27, y:36, s:'medium'},
  {m:0, x:33, y:35, s:'medium'},
];

const PROPS = [];

function buildProps() {
  PROPS.push({ img: IMG.anvil,
    srcX:0, srcY:0, srcW:192, srcH:128,
    tx:6, ty:8, tw:3, th:2, label:'Anvil' });
  PROPS.push({ img: IMG.workbench,
    srcX:0, srcY:0, srcW:192, srcH:64,
    tx:29, ty:8, tw:3, th:2, label:'Workbench' });
  PROPS.push({ img: IMG.sawmill,
    srcX:0, srcY:0, srcW:160, srcH:128,
    tx:6, ty:23, tw:3, th:2, label:'Sawmill' });
  PROPS.push({ img: IMG.bonfire,
    srcX:0, srcY:0, srcW:64, srcH:64,
    tx:20, ty:34, tw:2, th:2,
    animated:true, frames:6, fps:8, label:'Bonfire' });
  PROPS.push({ img: IMG.bonfire,
    srcX:0, srcY:0, srcW:64, srcH:64,
    tx:30, ty:25, tw:2, th:2,
    animated:true, frames:6, fps:8, label:'Campfire' });
}
buildProps();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS & CAMERA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let camX = 0, camY = 0;
let zoom = 1.5;
let isDragging = false;
let dragStartX, dragStartY, dragCamX, dragCamY;
let clickMoved = false;

function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight - 36 - 32;
  canvas.style.marginTop = '36px';
}
window.addEventListener('resize', () => { resize(); centerCamera(); });
resize();

function centerCamera() {
  camX = -(MAP_W * T / 2) + canvas.width  / (2 * zoom);
  camY = -(MAP_H * T / 2) + canvas.height / (2 * zoom);
}
centerCamera();

// Pan
canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  isDragging = true; clickMoved = false;
  canvas.classList.add('dragging');
  dragStartX = e.clientX; dragStartY = e.clientY;
  dragCamX = camX; dragCamY = camY;
});
window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - dragStartX, dy = e.clientY - dragStartY;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) clickMoved = true;
  camX = dragCamX + dx / zoom;
  camY = dragCamY + dy / zoom;
});
window.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.classList.remove('dragging');
});

// Zoom
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldZoom = zoom;
  zoom *= e.deltaY < 0 ? 1.15 : 0.87;
  zoom = Math.max(0.5, Math.min(6, zoom));
  const mx = e.clientX, my = e.clientY - 36;
  camX += mx/zoom - mx/oldZoom;
  camY += my/zoom - my/oldZoom;
  document.getElementById('zoom-info').textContent = Math.round(zoom*100) + '%';
}, { passive:false });

// Click agent
canvas.addEventListener('click', e => {
  if (clickMoved) return;
  const rect = canvas.getBoundingClientRect();
  const wx = (e.clientX - rect.left)  / zoom - camX;
  const wy = (e.clientY - rect.top)   / zoom - camY;
  for (let i = agents.length-1; i >= 0; i--) {
    if (agents[i].containsPoint(wx, wy)) {
      selectAgent(agents[i]); return;
    }
  }
  closePanel();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawTile(img, srcX, srcY, srcW, srcH, tx, ty, tw, th) {
  if (!img || !img.complete || !img.naturalWidth) return;
  tw = tw||1; th = th||1;
  ctx.drawImage(img, srcX, srcY, srcW, srcH, tx*T, ty*T, tw*T, th*T);
}

let waterAnimFrame = 0;
let waterAnimTimer = 0;
const WATER_FRAMES = 4;

function renderGround() {
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      const t = tileMap[y][x];
      if (t === 2) {
        if (IMG.waterTiles && IMG.waterTiles.complete && IMG.waterTiles.naturalWidth) {
          const wframe = waterAnimFrame % WATER_FRAMES;
          drawTile(IMG.waterTiles, wframe * 16, 0, 16, 16, x, y);
        } else {
          ctx.fillStyle = '#1155aa';
          ctx.fillRect(x*T, y*T, T, T);
          ctx.fillStyle = 'rgba(100,180,255,0.25)';
          const shimmer = Math.sin(Date.now()/600 + x*0.8 + y*0.5) * 0.5 + 0.5;
          ctx.globalAlpha = shimmer * 0.4;
          ctx.fillRect(x*T, y*T, T, T);
          ctx.globalAlpha = 1;
        }
      } else if (t === 3) {
        const variant = (x + y*3) % 3;
        drawTile(IMG.floorTiles, variant*16, 32, 16, 16, x, y);
      } else {
        const variant = (x*7 + y*3) % 4;
        drawTile(IMG.floorTiles, variant*16, 0, 16, 16, x, y);
      }
    }
  }
}

function renderRiverOverlay() {
  for (let x = 0; x < MAP_W; x++) {
    const bankY = RIVER_ROW_START;
    if (x !== 20 && x !== 21) {
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#0a3a7a';
      ctx.fillRect(x*T, bankY*T, T, 4);
      ctx.restore();
    }
  }
  for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
    for (const bx of [20, 21]) {
      drawTile(IMG.floorTiles, 0, 16, 16, 16, bx, ry);
      ctx.save();
      ctx.strokeStyle = '#7a5530';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bx*T + 3, ry*T);
      ctx.lineTo(bx*T + 3, (ry+1)*T);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo((bx+1)*T - 3, ry*T);
      ctx.lineTo((bx+1)*T - 3, (ry+1)*T);
      ctx.stroke();
      ctx.restore();
    }
  }
}

function renderBuildings() {
  for (const b of BUILDINGS) {
    for (let dy = 1; dy < b.h-1; dy++) {
      for (let dx = 1; dx < b.w-1; dx++) {
        drawTile(IMG.floorTiles, 0, 16, 16, 16, b.x+dx, b.y+dy);
      }
    }
    if (IMG.buildWalls && IMG.buildWalls.complete && IMG.buildWalls.naturalWidth) {
      for (let dx = 0; dx < b.w; dx++) {
        const isCorner = (dx === 0 || dx === b.w-1);
        const wallSrcX = isCorner ? (dx===0 ? 0 : 32) : 16;
        ctx.drawImage(IMG.buildWalls, wallSrcX, 0, 16, 16, (b.x+dx)*T, b.y*T, T, T);
      }
      for (let dx = 0; dx < b.w; dx++) {
        const isCorner = (dx === 0 || dx === b.w-1);
        const wallSrcX = isCorner ? (dx===0 ? 0 : 32) : 16;
        ctx.drawImage(IMG.buildWalls, wallSrcX, 32, 16, 16, (b.x+dx)*T, (b.y+b.h-1)*T, T, T);
      }
      for (let dy = 1; dy < b.h-1; dy++) {
        ctx.drawImage(IMG.buildWalls, 48, 16, 16, 16, b.x*T, (b.y+dy)*T, T, T);
        ctx.drawImage(IMG.buildWalls, 64, 16, 16, 16, (b.x+b.w-1)*T, (b.y+dy)*T, T, T);
      }
    } else {
      ctx.save();
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2;
      ctx.fillStyle = 'rgba(30,25,20,0.6)';
      ctx.fillRect(b.x*T, b.y*T, b.w*T, b.h*T);
      ctx.strokeRect(b.x*T+1, b.y*T+1, b.w*T-2, b.h*T-2);
      ctx.restore();
    }
    if (IMG.buildRoofs && IMG.buildRoofs.complete && IMG.buildRoofs.naturalWidth) {
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.drawImage(IMG.buildRoofs, 0, 0, b.w*16, 32, b.x*T, b.y*T, b.w*T, 2*T);
      ctx.restore();
    } else {
      ctx.save();
      ctx.fillStyle = b.color;
      ctx.globalAlpha = 0.5;
      ctx.fillRect(b.x*T, b.y*T, b.w*T, 2*T);
      ctx.restore();
    }
    ctx.save();
    ctx.font = '6px "Press Start 2P"';
    ctx.textAlign = 'center';
    const lw = ctx.measureText(b.label).width;
    const lx = (b.x + b.w/2) * T;
    const ly = (b.y + 0.7) * T;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    roundRect(ctx, lx - lw/2 - 3, ly - 8, lw + 6, 11, 2);
    ctx.fill();
    ctx.fillStyle = b.color;
    ctx.fillText(b.label, lx, ly);
    ctx.restore();
  }
}

function renderTreeShadows() {
  if (!IMG.shadows || !IMG.shadows.complete || !IMG.shadows.naturalWidth) return;
  for (const t of TREES) {
    const large = t.s === 'large';
    ctx.save();
    ctx.globalAlpha = 0.35;
    const sw = large ? 4*T : 2*T;
    const sh = large ? 2*T : T;
    ctx.drawImage(IMG.shadows, 0, large?48:96, large?80:32, large?32:16,
      (t.x + 0.5)*T, (t.y + 1.5)*T, sw, sh);
    ctx.restore();
  }
}

function renderTrees() {
  const imgs = [IMG.tree1, IMG.tree2, IMG.tree3];
  for (const t of TREES) {
    const img = imgs[t.m % 3];
    if (!img || !img.complete || !img.naturalWidth) continue;
    const scale = t.s === 'medium' ? 0.7 : 1.0;
    const w = img.naturalWidth  * SCALE * scale;
    const h = img.naturalHeight * SCALE * scale;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, t.x*T, t.y*T - h + 2*T, w, h);
    ctx.restore();
  }
}

function renderProp(p) {
  if (!p.img || !p.img.complete || !p.img.naturalWidth) {
    ctx.fillStyle = 'rgba(80,60,30,0.8)';
    ctx.fillRect(p.tx*T, p.ty*T, p.tw*T, p.th*T);
    ctx.strokeStyle = '#a85';
    ctx.lineWidth = 1;
    ctx.strokeRect(p.tx*T, p.ty*T, p.tw*T, p.th*T);
    if (p.label) {
      ctx.font = '6px "Press Start 2P"';
      ctx.fillStyle = '#dca';
      ctx.textAlign = 'center';
      ctx.fillText(p.label, (p.tx + p.tw/2)*T, (p.ty + p.th/2)*T + 3);
    }
    return;
  }
  let sy = p.srcY;
  if (p.animated) {
    const frame = Math.floor(Date.now() / (1000 / (p.fps||8))) % p.frames;
    sy = frame * p.srcH;
  }
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(p.img, p.srcX, sy, p.srcW, p.srcH,
    p.tx*T, p.ty*T, p.tw*T, p.th*T);
  ctx.restore();
}

function renderBankVegetation() {
  const t = Date.now() / 1000;
  ctx.save();
  for (let x = 0; x < MAP_W; x++) {
    if (x === 20 || x === 21) continue;
    const bankTopY = (RIVER_ROW_START - 1) * T + T - 4;
    const bankBotY = (RIVER_ROW_END + 1) * T;
    const sway = Math.sin(t * 1.5 + x * 0.8) * 2;
    ctx.strokeStyle = '#4a8a2a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x*T + 6, bankTopY);
    ctx.lineTo(x*T + 8 + sway, bankTopY - 5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x*T + 14, bankTopY);
    ctx.lineTo(x*T + 16 + sway, bankTopY - 4);
    ctx.stroke();
    if (x % 3 === 1) {
      ctx.fillStyle = '#dd88aa';
      ctx.beginPath();
      ctx.arc(x*T + 10 + sway/2, bankTopY - 7, 2, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffcc44';
      ctx.beginPath();
      ctx.arc(x*T + 10 + sway/2, bankTopY - 7, 1, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.strokeStyle = '#3a7a1a';
    ctx.beginPath();
    ctx.moveTo(x*T + 8, bankBotY + 2);
    ctx.lineTo(x*T + 10 + sway, bankBotY + 6);
    ctx.stroke();
  }
  ctx.restore();
}

function renderWaterEffects() {
  const t = Date.now() / 1000;
  ctx.save();
  ctx.globalAlpha = 0.18;
  for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
    for (let x = 0; x < MAP_W; x++) {
      if (x === 20 || x === 21) continue;
      const wave = Math.sin(t * 1.2 + x * 0.6 - ry * 0.3) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(150,210,255,${wave * 0.4 + 0.1})`;
      ctx.fillRect(x*T + 2, ry*T + 8, T-4, 4);
    }
  }
  ctx.restore();
}

function renderVillageBanner() {
  const cx = MAP_W * T / 2;
  const cy = 1.2 * T;
  ctx.save();
  ctx.font = '8px "Press Start 2P"';
  ctx.textAlign = 'center';
  const text = '~ SpawnKit Village ~';
  const tw = ctx.measureText(text).width;
  ctx.fillStyle = 'rgba(10,15,30,0.75)';
  roundRect(ctx, cx - tw/2 - 8, cy - 12, tw + 16, 18, 4);
  ctx.fill();
  ctx.strokeStyle = '#3a5';
  ctx.lineWidth = 1;
  roundRect(ctx, cx - tw/2 - 8, cy - 12, tw + 16, 18, 4);
  ctx.stroke();
  ctx.fillStyle = '#5f8';
  ctx.fillText(text, cx, cy);
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENT SELECTION PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let selectedAgent = null;

function selectAgent(agent) {
  selectedAgent = agent;
  document.getElementById('panel-name').textContent      = agent.name;
  document.getElementById('panel-role').textContent      = agent.role;
  document.getElementById('panel-status').textContent    = agent.status;
  document.getElementById('panel-anim').textContent      = agent.animType + ' / ' + agent.direction;
  document.getElementById('panel-location').textContent  = `(${Math.round(agent.x)}, ${Math.round(agent.y)})`;
  const tasksEl = document.getElementById('panel-tasks');
  tasksEl.innerHTML = '';
  const div = document.createElement('div');
  div.className = 'task';
  div.textContent = agent.currentTask;
  tasksEl.appendChild(div);
  const charModel = CHARACTER_MODELS[agent.id] || '?';
  document.getElementById('panel-anim-info').textContent =
    `Model: ${charModel}\nAnim: ${agent.animType}\nDir: ${agent.direction}\nFrame: ${agent.animFrame}/${SPRITE_FRAMES}`;
  document.getElementById('agent-panel').classList.add('open');
}

function closePanel() {
  selectedAgent = null;
  document.getElementById('agent-panel').classList.remove('open');
}
window.closePanel = closePanel;

function updateBottomBar() {
  const bar = document.getElementById('bottombar');
  bar.innerHTML = '';
  for (const agent of agents) {
    const div = document.createElement('div');
    div.className = 'agent-stat';
    div.onclick = () => selectAgent(agent);
    const dot = document.createElement('div');
    dot.className = 'dot';
    dot.style.background = agent.tint;
    const nm = document.createElement('span');
    nm.className = 'aname';
    nm.textContent = agent.name;
    const tk = document.createElement('span');
    tk.className = 'atask';
    tk.textContent = agent.currentTask;
    div.appendChild(dot); div.appendChild(nm); div.appendChild(tk);
    bar.appendChild(div);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMBIENT BEHAVIORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let behaviorTimer = 0;
const BEHAVIOR_INTERVAL = 8;

const TASK_PHRASES = {
  apomac:   ['Building the future','Reviewing blueprints','Planning architecture','Hauling materials'],
  forge:    ['Forging tools','Hammering iron','Smithing blades','Tempering steel'],
  hunter:   ['Patrolling the path','Scouting ahead','Checking the perimeter','On watch duty'],
  atlas:    ['Managing operations','Organizing resources','Directing logistics','Checking inventory'],
  echo:     ['Crafting campaigns','Tending herbs','Gathering flowers','River watch'],
  sentinel: ['Auditing systems','Casting the line','Waiting for a bite','River patrol'],
};

const WANDER_ZONES = {
  apomac:   { x1:27, y1:4,  x2:37, y2:14 },
  forge:    { x1:4,  y1:4,  x2:15, y2:14 },
  hunter:   null,
  atlas:    { x1:2,  y1:12, x2:10, y2:21 },
  echo:     { x1:14, y1:28, x2:24, y2:35 },
  sentinel: { x1:16, y1:28, x2:22, y2:35 },
};

function getWanderTile(agentId) {
  const zone = WANDER_ZONES[agentId];
  if (!zone) return null;
  const tx = zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1));
  const ty = zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1));
  return isWalkable(tx, ty) ? { tx, ty } : null;
}

function updateAmbientBehavior(dt) {
  behaviorTimer += dt;
  if (behaviorTimer < BEHAVIOR_INTERVAL) return;
  behaviorTimer = Math.random() * 2;

  for (const agent of agents) {
    if (agent.path.length > 0) continue;
    if (agent.isPatrolling) continue;

    const roll = Math.random();
    const tasks = TASK_PHRASES[agent.id] || [];

    if (roll < 0.3) {
      const wp = getWanderTile(agent.id);
      if (wp) {
        agent.walkTo(wp.tx, wp.ty);
        agent.status = 'walking';
        const task = tasks[Math.floor(Math.random() * tasks.length)];
        if (task) {
          agent.currentTask = task;
          if (Math.random() < 0.35) agent.say(task, 4);
        }
      }
    } else if (roll < 0.55) {
      agent.walkTo(agent.homeX, agent.homeY);
      agent.isWorking = true;
      agent.status = 'working';
      const task = tasks[0];
      if (task) agent.currentTask = task;
    } else {
      agent.animType = 'idle';
      agent.status = agent.isWorking ? 'working' : 'idle';
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastTime = performance.now();
let bottomBarTimer = 0;
let panelRefreshTimer = 0;

function gameLoop(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.08);
  lastTime = now;

  waterAnimTimer += dt;
  if (waterAnimTimer >= 1/3) {
    waterAnimTimer = 0;
    waterAnimFrame = (waterAnimFrame + 1) % WATER_FRAMES;
  }

  for (const agent of agents) {
    agent.update(dt, agents);
  }

  updateFootsteps(dt);
  updateAmbientBehavior(dt);

  bottomBarTimer += dt;
  if (bottomBarTimer >= 1) {
    bottomBarTimer = 0;
    updateBottomBar();
  }

  panelRefreshTimer += dt;
  if (panelRefreshTimer >= 0.5 && selectedAgent) {
    panelRefreshTimer = 0;
    document.getElementById('panel-status').textContent   = selectedAgent.status;
    document.getElementById('panel-anim').textContent     = selectedAgent.animType + ' / ' + selectedAgent.direction;
    document.getElementById('panel-location').textContent = `(${Math.round(selectedAgent.x)}, ${Math.round(selectedAgent.y)})`;
    const charModel = CHARACTER_MODELS[selectedAgent.id] || '?';
    document.getElementById('panel-anim-info').textContent =
      `Model: ${charModel}\nAnim: ${selectedAgent.animType}\nDir: ${selectedAgent.direction}\nFrame: ${selectedAgent.animFrame}/${SPRITE_FRAMES}`;
  }

  // â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#1a2a14';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.scale(zoom, zoom);
  ctx.translate(camX, camY);
  ctx.imageSmoothingEnabled = false;

  // Layer 1: Ground
  renderGround();

  // Layer 2: River overlay
  renderRiverOverlay();

  // Layer 3: Buildings
  renderBuildings();

  // Layer 4: Bank vegetation
  renderBankVegetation();

  // Layer 5: Water effects
  renderWaterEffects();

  // Layer 6: Footstep markers
  renderFootsteps(ctx);

  // Layer 7: Tree shadows
  renderTreeShadows();

  // Layer 8: Z-sorted renderables (agents + props + trees)
  const renderables = [];

  for (const p of PROPS) {
    renderables.push({ sortY: p.ty + p.th, draw: () => renderProp(p) });
  }

  const treeImgs = [IMG.tree1, IMG.tree2, IMG.tree3];
  for (const t of TREES) {
    const img = treeImgs[t.m % 3];
    if (!img || !img.complete || !img.naturalWidth) continue;
    const scale = t.s === 'medium' ? 0.7 : 1.0;
    const w = img.naturalWidth  * SCALE * scale;
    const h = img.naturalHeight * SCALE * scale;
    const ty_bottom = t.y + 2;
    renderables.push({
      sortY: ty_bottom,
      draw: () => {
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, t.x*T, t.y*T - h + 2*T, w, h);
        ctx.restore();
      }
    });
  }

  for (const agent of agents) {
    renderables.push({ sortY: agent.y, draw: () => agent.draw(ctx) });
  }

  renderables.sort((a,b) => a.sortY - b.sortY);
  for (const r of renderables) r.draw();

  // Layer 9: Village banner
  renderVillageBanner();

  // Layer 10: Selection highlight
  if (selectedAgent) {
    const sa = selectedAgent;
    const dw = SPRITE_DRAW_SIZE;
    const dh = SPRITE_DRAW_SIZE;
    ctx.save();
    ctx.strokeStyle = '#5f8';
    ctx.lineWidth = 1;
    ctx.setLineDash([3,3]);
    ctx.strokeRect(sa.x*T - dw/2 + T/2 - 2, sa.y*T - dh + T + 2, dw+4, dh+4);
    ctx.restore();
  }

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOADING SCREEN & INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawLoadingScreen() {
  ctx.fillStyle = '#1a2a14';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.font = '12px "Press Start 2P"';
  ctx.fillStyle = '#5f8';
  ctx.textAlign = 'center';
  ctx.fillText('ğŸŒ¿ SPAWNKIT VILLAGE', canvas.width/2, canvas.height/2 - 20);
  ctx.font = '8px "Press Start 2P"';
  ctx.fillStyle = '#8ab';
  const pct = totalImages > 0 ? Math.round((loadedCount / totalImages) * 100) : 0;
  ctx.fillText(`Loading ${loadedCount}/${totalImages} sprites... ${pct}%`, canvas.width/2, canvas.height/2 + 10);
  const bw = 200, bh = 8;
  const bx = canvas.width/2 - bw/2, by = canvas.height/2 + 24;
  ctx.strokeStyle = '#3a5';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx, by, bw, bh);
  ctx.fillStyle = '#3a5';
  ctx.fillRect(bx, by, bw * (loadedCount / Math.max(totalImages, 1)), bh);
}

function waitForLoad() {
  drawLoadingScreen();
  if (loadedCount >= totalImages && totalImages > 0) {
    console.log('[SpawnKit Village] All assets loaded (' + totalImages + '). Starting game loop.');
    updateBottomBar();
    for (const agent of agents) {
      agent.x = agent.homeX + (Math.random() - 0.5) * 0.5;
      agent.y = agent.homeY + (Math.random() - 0.5) * 0.5;
    }
    requestAnimationFrame(gameLoop);
  } else {
    requestAnimationFrame(waitForLoad);
  }
}

requestAnimationFrame(waitForLoad);

console.log('[SpawnKit Village] Kenney Mini Characters initialized. Loading', totalImages, 'sprites...');
</script>
</body>
</html>