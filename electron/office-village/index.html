<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SpawnKit Village â€” Cozy Pixel Village</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#1a1a2e; overflow:hidden; font-family:'Press Start 2P',monospace; }
  canvas { display:block; image-rendering:pixelated; image-rendering:crisp-edges; cursor:grab; }
  canvas.dragging { cursor:grabbing; }

  /* â”€â”€â”€ Top Bar â”€â”€â”€ */
  #topbar {
    position:fixed; top:0; left:0; right:0; height:36px; z-index:100;
    background:rgba(20,20,40,0.92); border-bottom:2px solid #3a5; display:flex;
    align-items:center; padding:0 12px; gap:12px;
  }
  #topbar .title { color:#5f8; font-size:10px; letter-spacing:2px; }
  #topbar .mode { color:#fa5; font-size:7px; padding:2px 6px; border:1px solid #fa5; border-radius:3px; }
  #topbar .sep { flex:1; }
  #topbar .zoom-info { color:#8ab; font-size:7px; }

  /* â”€â”€â”€ Bottom Bar â”€â”€â”€ */
  #bottombar {
    position:fixed; bottom:0; left:0; right:0; min-height:32px; z-index:100;
    background:rgba(20,20,40,0.92); border-top:2px solid #3a5; display:flex;
    align-items:center; padding:0 8px; gap:10px; font-size:6px; color:#8ab;
    flex-wrap:wrap;
  }
  .agent-stat { display:flex; align-items:center; gap:4px; cursor:pointer; padding:2px 4px; border-radius:3px; }
  .agent-stat:hover { background:rgba(60,170,90,0.15); }
  .agent-stat .dot { width:7px; height:7px; border-radius:50%; flex-shrink:0; }
  .agent-stat .aname { color:#cde; }
  .agent-stat .atask { color:#8ab; max-width:100px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

  /* â”€â”€â”€ Agent Detail Panel â”€â”€â”€ */
  #agent-panel {
    position:fixed; top:36px; right:0; width:260px; bottom:32px; z-index:99;
    background:rgba(20,20,40,0.97); border-left:2px solid #3a5;
    transform:translateX(100%); transition:transform .3s ease;
    padding:16px; overflow-y:auto; color:#cde;
  }
  #agent-panel.open { transform:translateX(0); }
  #agent-panel h2 { font-size:10px; color:#5f8; margin-bottom:6px; }
  #agent-panel .role { font-size:7px; color:#fa5; margin-bottom:10px; }
  #agent-panel .field { font-size:7px; margin-bottom:5px; line-height:1.6; }
  #agent-panel .field label { color:#8ab; }
  #agent-panel .close-btn {
    position:absolute; top:8px; right:8px; background:none; border:1px solid #f55;
    color:#f55; font-size:8px; cursor:pointer; padding:2px 6px; font-family:inherit;
  }
  #agent-panel .task-list { margin-top:8px; }
  #agent-panel .task { font-size:6px; color:#acd; padding:4px; background:rgba(50,70,50,0.3); margin-bottom:3px; border-left:2px solid #3a5; }
  #agent-panel .anim-info { font-size:6px; color:#7bc; margin-top:8px; padding:6px; background:rgba(30,50,80,0.4); border:1px solid #3a5; border-radius:3px; }
</style>
</head>
<body>

<div id="topbar">
  <span class="title">ğŸŒ¿ SPAWNKIT VILLAGE</span>
  <span class="mode" id="mode-badge">VILLAGE</span>
  <span class="sep"></span>
  <span id="zoom-info" class="zoom-info">100%</span>
</div>

<canvas id="game"></canvas>

<div id="bottombar" id="bottombar-inner">
  <!-- populated by JS -->
</div>

<div id="agent-panel">
  <button class="close-btn" onclick="closePanel()">âœ•</button>
  <h2 id="panel-name">â€”</h2>
  <div class="role" id="panel-role">â€”</div>
  <div class="field"><label>Status: </label><span id="panel-status">â€”</span></div>
  <div class="field"><label>Animation: </label><span id="panel-anim">â€”</span></div>
  <div class="field"><label>Location: </label><span id="panel-location">â€”</span></div>
  <div class="field"><label>Current Task: </label></div>
  <div class="task-list" id="panel-tasks"></div>
  <div class="anim-info" id="panel-anim-info">â€”</div>
</div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TILE = 16;
const SCALE = 2;
const T = TILE * SCALE;       // 32px rendered tile
const FPS_ANIM = 8;
const MOVE_SPEED = 1.0;       // tiles/second
const RENDER_SIZE = 64;       // sprite render size in source pixels
const SEPARATION_RADIUS = 1.5;
const SEPARATION_FORCE = 1.8;

// All assets relative to THIS file â†’ ../office-green-iso/assets/
const ASSETS = '../office-green-iso/assets/';

// â”€â”€â”€ Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MAP_W = 42;
const MAP_H = 42;

// Tile types: 0=grass, 1=walkable(path/bridge/open), 2=water, 3=dirt path
const tileMap = [];
for (let y = 0; y < MAP_H; y++) {
  tileMap[y] = new Uint8Array(MAP_W); // 0 = grass
}

// â”€â”€â”€ River (row 28â€“30 horizontal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RIVER_ROW_START = 28;
const RIVER_ROW_END   = 30;

// â”€â”€â”€ Dirt path network â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Central vertical path col 20-21
// Central horizontal path row 18-19
// Paths lead to each building, river, trees

function buildTileMap() {
  // Vertical spine: col 20, rows 2..MAP_H-3  (excluding river â†’ bridge)
  for (let y = 2; y < MAP_H - 2; y++) {
    tileMap[y][20] = (y >= RIVER_ROW_START && y <= RIVER_ROW_END) ? 2 : 3;
    tileMap[y][21] = (y >= RIVER_ROW_START && y <= RIVER_ROW_END) ? 2 : 3;
  }
  // Horizontal upper path row 16-17
  for (let x = 2; x < MAP_W - 2; x++) {
    tileMap[16][x] = 3;
    tileMap[17][x] = 3;
  }
  // Horizontal lower path row 33-34
  for (let x = 2; x < MAP_W - 2; x++) {
    tileMap[33][x] = 3;
    tileMap[34][x] = 3;
  }
  // River rows
  for (let x = 0; x < MAP_W; x++) {
    for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
      tileMap[ry][x] = 2;
    }
  }
  // Bridge over river at col 20-21 (override water)
  for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
    tileMap[ry][20] = 3;
    tileMap[ry][21] = 3;
  }
  // Mark all path/bridge tiles walkable: tile 3 = dirt path (walkable)
  // Water (2) is NOT walkable except bridge
}

buildTileMap();

function isWalkable(tx, ty) {
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return false;
  const t = tileMap[ty][tx];
  return t === 0 || t === 3; // grass + dirt path walkable; water not
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IMAGE LOADER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const imageCache = {};
let loadedCount = 0;
let totalImages = 0;

function loadImage(path) {
  if (imageCache[path]) return imageCache[path];
  totalImages++;
  const img = new Image();
  img.src = ASSETS + path;
  img.onload = () => { loadedCount++; };
  img.onerror = () => { console.warn('Failed:', ASSETS + path); loadedCount++; };
  imageCache[path] = img;
  return img;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPRITE DEFINITIONS  (Body_A only, village animations)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SPRITE_DEFS = {
  bodyA: {
    idle_down:       { path:'Entities/Characters/Body_A/Animations/Idle_Base/Idle_Down-Sheet.png',         fw:64, fh:64, frames:4 },
    idle_side:       { path:'Entities/Characters/Body_A/Animations/Idle_Base/Idle_Side-Sheet.png',         fw:64, fh:64, frames:4 },
    idle_up:         { path:'Entities/Characters/Body_A/Animations/Idle_Base/Idle_Up-Sheet.png',           fw:64, fh:64, frames:4 },
    walk_down:       { path:'Entities/Characters/Body_A/Animations/Walk_Base/Walk_Down-Sheet.png',         fw:64, fh:64, frames:6 },
    walk_side:       { path:'Entities/Characters/Body_A/Animations/Walk_Base/Walk_Side-Sheet.png',         fw:64, fh:64, frames:6 },
    walk_up:         { path:'Entities/Characters/Body_A/Animations/Walk_Base/Walk_Up-Sheet.png',           fw:64, fh:64, frames:6 },
    carry_idle_down: { path:'Entities/Characters/Body_A/Animations/Carry_Idle/Carry_Idle_Down-Sheet.png',  fw:64, fh:64, frames:4 },
    carry_idle_side: { path:'Entities/Characters/Body_A/Animations/Carry_Idle/Carry_Idle_Side-Sheet.png',  fw:64, fh:64, frames:4 },
    carry_idle_up:   { path:'Entities/Characters/Body_A/Animations/Carry_Idle/Carry_Idle_Up-Sheet.png',    fw:64, fh:64, frames:4 },
    crush_down:      { path:'Entities/Characters/Body_A/Animations/Crush_Base/Crush_Down-Sheet.png',       fw:64, fh:64, frames:8 },
    crush_side:      { path:'Entities/Characters/Body_A/Animations/Crush_Base/Crush_Side-Sheet.png',       fw:64, fh:64, frames:8 },
    crush_up:        { path:'Entities/Characters/Body_A/Animations/Crush_Base/Crush_Up-Sheet.png',         fw:64, fh:64, frames:8 },
    collect_down:    { path:'Entities/Characters/Body_A/Animations/Collect_Base/Collect_Down-Sheet.png',   fw:64, fh:64, frames:8 },
    collect_side:    { path:'Entities/Characters/Body_A/Animations/Collect_Base/Collect_Side-Sheet.png',   fw:64, fh:64, frames:8 },
    collect_up:      { path:'Entities/Characters/Body_A/Animations/Collect_Base/Collect_Up-Sheet.png',     fw:64, fh:64, frames:8 },
    watering_down:   { path:'Entities/Characters/Body_A/Animations/Watering_Base/Watering_Down-Sheet.png', fw:64, fh:64, frames:8 },
    watering_side:   { path:'Entities/Characters/Body_A/Animations/Watering_Base/Watering_Side-Sheet.png', fw:64, fh:64, frames:8 },
    watering_up:     { path:'Entities/Characters/Body_A/Animations/Watering_Base/Watering_Up-Sheet.png',   fw:64, fh:64, frames:8 },
    fishing_down:    { path:'Entities/Characters/Body_A/Animations/Fishing_Base/Fishing_Down-Sheet.png',   fw:64, fh:64, frames:8 },
    fishing_side:    { path:'Entities/Characters/Body_A/Animations/Fishing_Base/Fishing_Side-Sheet.png',   fw:64, fh:64, frames:8 },
    fishing_up:      { path:'Entities/Characters/Body_A/Animations/Fishing_Base/Fishing_Up-Sheet.png',     fw:64, fh:64, frames:8 },
    // aliases
    idle:  { path:'Entities/Characters/Body_A/Animations/Idle_Base/Idle_Down-Sheet.png',  fw:64, fh:64, frames:4 },
    walk:  { path:'Entities/Characters/Body_A/Animations/Walk_Base/Walk_Down-Sheet.png',  fw:64, fh:64, frames:6 },
  },
};

// Preload all sprites
for (const char of Object.values(SPRITE_DEFS)) {
  for (const anim of Object.values(char)) {
    loadImage(anim.path);
  }
}

// Environment images
const IMG = {
  floorTiles:  loadImage('Environment/Tilesets/Floors_Tiles.png'),
  waterTiles:  loadImage('Environment/Tilesets/Water_tiles.png'),
  wallTiles:   loadImage('Environment/Tilesets/Wall_Tiles.png'),
  buildWalls:  loadImage('Environment/Structures/Buildings/Walls.png'),
  buildFloors: loadImage('Environment/Structures/Buildings/Floors.png'),
  buildRoofs:  loadImage('Environment/Structures/Buildings/Roofs.png'),
  buildProps:  loadImage('Environment/Structures/Buildings/Props.png'),
  tree1:       loadImage('Environment/Props/Static/Trees/Model_01/Size_03.png'),
  tree2:       loadImage('Environment/Props/Static/Trees/Model_02/Size_03.png'),
  tree3:       loadImage('Environment/Props/Static/Trees/Model_03/Size_02.png'),
  anvil:       loadImage('Environment/Structures/Stations/Anvil/Anvil.png'),
  workbench:   loadImage('Environment/Structures/Stations/Workbench/Workbench.png'),
  bonfire:     loadImage('Environment/Structures/Stations/Bonfire/Bonfire.png'),
  sawmill:     loadImage('Environment/Structures/Stations/Sawmill/Base.png'),
  shadows:     loadImage('Environment/Props/Static/Shadows.png'),
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// A* PATHFINDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function findPath(sx, sy, ex, ey) {
  sx = Math.round(sx); sy = Math.round(sy);
  ex = Math.round(ex); ey = Math.round(ey);
  if (!isWalkable(ex, ey)) {
    // Try nearby walkable tile
    for (const [dx,dy] of [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]) {
      if (isWalkable(ex+dx, ey+dy)) { ex += dx; ey += dy; break; }
    }
    if (!isWalkable(ex, ey)) return null;
  }
  if (sx === ex && sy === ey) return [];

  const open = [{ x:sx, y:sy, g:0, h:0, f:0, parent:null }];
  const closed = new Set();
  const key = (x,y) => y * MAP_W + x;
  const gScores = new Map();
  gScores.set(key(sx,sy), 0);

  while (open.length > 0) {
    open.sort((a,b) => a.f - b.f);
    const cur = open.shift();
    if (cur.x === ex && cur.y === ey) {
      const path = [];
      let n = cur;
      while (n.parent) { path.unshift({x:n.x, y:n.y}); n = n.parent; }
      return path;
    }
    closed.add(key(cur.x, cur.y));
    for (const [dx,dy] of [[0,-1],[0,1],[-1,0],[1,0],[-1,-1],[-1,1],[1,-1],[1,1]]) {
      const nx = cur.x+dx, ny = cur.y+dy;
      if (!isWalkable(nx, ny)) continue;
      const k = key(nx, ny);
      if (closed.has(k)) continue;
      if (dx !== 0 && dy !== 0) {
        if (!isWalkable(cur.x+dx, cur.y) || !isWalkable(cur.x, cur.y+dy)) continue;
      }
      const g = cur.g + (dx !== 0 && dy !== 0 ? 1.414 : 1);
      if (gScores.has(k) && g >= gScores.get(k)) continue;
      gScores.set(k, g);
      const h = Math.abs(nx-ex) + Math.abs(ny-ey);
      open.push({ x:nx, y:ny, g, h, f:g+h, parent:cur });
    }
  }
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUILDINGS (village structures, placed as decorative + floor areas)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Each building: { x, y, w, h, label, color }
const BUILDINGS = [
  { id:'smithy',   x:5,  y:4,  w:8, h:7, label:'Smithy',    color:'#c84' },    // NW â€” Forge + Anvil
  { id:'workshop', x:28, y:4,  w:8, h:7, label:'Workshop',   color:'#8ac' },    // NE â€” ApoMac + Workbench
  { id:'sawhouse', x:5,  y:22, w:8, h:7, label:'Sawmill',    color:'#6a4' },    // SW â€” Sawmill area
  { id:'lodge',    x:28, y:22, w:8, h:7, label:'River Lodge', color:'#4aa' },   // SE
];

// Mark building interiors as walkable grass (tile 0) â€” they're open structures
// We just draw them as prop decorations on top

// Patrol waypoints per agent (array of [tx, ty])
const PATROL_ROUTES = {
  hunter: [
    [20, 8], [20, 13], [20, 16], [28, 16], [35, 16],
    [35, 8], [28, 8], [20, 8],
  ],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENT CLASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Agent {
  constructor(cfg) {
    this.id        = cfg.id;
    this.name      = cfg.name;
    this.role      = cfg.role;
    this.tint      = cfg.tint;        // CSS color string e.g. '#4488ff'
    this.tintAlpha = cfg.tintAlpha || 0.35;
    this.workAnim  = cfg.workAnim;    // base anim name e.g. 'carry_idle'
    this.homeX     = cfg.homeX;
    this.homeY     = cfg.homeY;
    this.label     = cfg.label || cfg.name;
    this.dotColor  = cfg.tint;

    this.x         = cfg.homeX;
    this.y         = cfg.homeY;
    this.facing    = 'down';
    this.facingLeft= false;
    this.animState = 'idle_down';
    this.animFrame = 0;
    this.animTimer = 0;
    this.status    = 'idle';
    this.currentTask = cfg.defaultTask || 'Standing by';

    this.path      = [];
    this.pathIdx   = 0;

    // Patrol state
    this.patrolRoute  = cfg.patrolRoute || null;
    this.patrolIdx    = 0;
    this.isPatrolling = cfg.patrolRoute != null;

    // Speech
    this.speechText  = '';
    this.speechTimer = 0;

    // Work animation idle timer (cycle work anim periodically)
    this.workTimer    = Math.random() * 5;
    this.workInterval = 3 + Math.random() * 4;
    this.isWorking    = cfg.startWorking || false;

    if (this.isWorking) {
      this.animState = this.workAnim + '_down';
      this.status = 'working';
    }
  }

  say(text, dur) {
    this.speechText  = text;
    this.speechTimer = dur || 3;
  }

  setFacing(dx, dy) {
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if (ady > adx * 1.2) {
      this.facing = dy > 0 ? 'down' : 'up';
    } else {
      this.facing = 'side';
    }
    this.facingLeft = dx < 0;
  }

  setDirectionalAnim(base) {
    const key = base + '_' + this.facing;
    const def = SPRITE_DEFS.bodyA;
    this.animState = (def[key]) ? key : (base + '_down');
  }

  walkTo(tx, ty) {
    const path = findPath(Math.round(this.x), Math.round(this.y), tx, ty);
    if (path && path.length > 0) {
      this.path = path;
      this.pathIdx = 0;
      this.status = 'walking';
      this.setDirectionalAnim('walk');
    }
  }

  update(dt, allAgents) {
    // Animation tick
    this.animTimer += dt;
    const def = SPRITE_DEFS.bodyA;
    const anim = def[this.animState] || def.idle_down;
    if (this.animTimer >= 1 / FPS_ANIM) {
      this.animTimer -= 1 / FPS_ANIM;
      this.animFrame = (this.animFrame + 1) % anim.frames;
    }

    // Path following
    if (this.path.length > 0 && this.pathIdx < this.path.length) {
      const tgt = this.path[this.pathIdx];
      const dx = tgt.x - this.x;
      const dy = tgt.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 0.12) {
        this.x = tgt.x; this.y = tgt.y;
        this.pathIdx++;
        if (this.pathIdx >= this.path.length) {
          this.path = [];
          this.pathIdx = 0;
          this.onArrival();
        }
      } else {
        const speed = MOVE_SPEED * dt;
        this.x += (dx/dist) * Math.min(speed, dist);
        this.y += (dy/dist) * Math.min(speed, dist);
        this.setFacing(dx, dy);
        this.setDirectionalAnim('walk');
      }
    }

    // Separation from other agents
    let sepX = 0, sepY = 0;
    for (const other of allAgents) {
      if (other === this) continue;
      const dx = this.x - other.x;
      const dy = this.y - other.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < SEPARATION_RADIUS && d > 0.01) {
        const f = (SEPARATION_RADIUS - d) / SEPARATION_RADIUS;
        sepX += (dx/d) * f;
        sepY += (dy/d) * f;
      }
    }
    if (sepX || sepY) {
      const nx = this.x + sepX * SEPARATION_FORCE * dt;
      const ny = this.y + sepY * SEPARATION_FORCE * dt;
      if (isWalkable(Math.round(nx), Math.round(ny))) {
        this.x = nx; this.y = ny;
      } else if (isWalkable(Math.round(nx), Math.round(this.y))) {
        this.x = nx;
      } else if (isWalkable(Math.round(this.x), Math.round(ny))) {
        this.y = ny;
      }
    }

    // Work animation idle when standing
    if (this.path.length === 0 && this.isWorking) {
      this.workTimer += dt;
      if (this.workTimer >= this.workInterval) {
        this.workTimer = 0;
        this.workInterval = 2 + Math.random() * 3;
        this.setDirectionalAnim(this.workAnim);
        this.animFrame = 0;
      }
    }

    // Patrol logic
    if (this.isPatrolling && this.path.length === 0) {
      const wp = this.patrolRoute[this.patrolIdx % this.patrolRoute.length];
      const dx = wp[0] - this.x, dy = wp[1] - this.y;
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
        this.patrolIdx = (this.patrolIdx + 1) % this.patrolRoute.length;
      } else {
        this.walkTo(wp[0], wp[1]);
      }
    }

    // Speech timer
    if (this.speechTimer > 0) {
      this.speechTimer -= dt;
      if (this.speechTimer <= 0) this.speechText = '';
    }
  }

  onArrival() {
    if (this.isPatrolling) {
      this.patrolIdx = (this.patrolIdx + 1) % this.patrolRoute.length;
      // Brief idle before continuing patrol
      setTimeout(() => {
        if (this.isPatrolling) {
          const wp = this.patrolRoute[this.patrolIdx % this.patrolRoute.length];
          this.walkTo(wp[0], wp[1]);
        }
      }, 800 + Math.random() * 600);
    } else if (this.isWorking) {
      this.setDirectionalAnim(this.workAnim);
      this.animFrame = 0;
      this.status = 'working';
    } else {
      this.setDirectionalAnim('idle');
      this.status = 'idle';
    }
  }

  draw(ctx) {
    const def = SPRITE_DEFS.bodyA;
    const anim = def[this.animState] || def.idle_down;
    const img = imageCache[anim.path];
    if (!img || !img.complete) return;

    const sx = this.animFrame * anim.fw;
    const drawW = RENDER_SIZE * SCALE;
    const drawH = RENDER_SIZE * SCALE;
    const px = this.x * T - drawW / 2 + T / 2;
    const py = this.y * T - drawH + T;

    ctx.save();
    ctx.imageSmoothingEnabled = false;

    if (this.facingLeft) {
      ctx.translate(px + drawW, py);
      ctx.scale(-1, 1);
      ctx.drawImage(img, sx, 0, anim.fw, anim.fh, 0, 0, drawW, drawH);
      // Tint overlay
      ctx.globalCompositeOperation = 'source-atop';
      ctx.globalAlpha = this.tintAlpha;
      ctx.fillStyle = this.tint;
      ctx.fillRect(0, 0, drawW, drawH);
    } else {
      ctx.drawImage(img, sx, 0, anim.fw, anim.fh, px, py, drawW, drawH);
      ctx.globalCompositeOperation = 'source-atop';
      ctx.globalAlpha = this.tintAlpha;
      ctx.fillStyle = this.tint;
      ctx.fillRect(px, py, drawW, drawH);
    }

    ctx.restore();

    // Status diamond
    const indicatorX = this.x * T + T / 2;
    const indicatorY = py - 6;
    const bob = Math.sin(Date.now() / 300 + this.x * 3.7) * 2;

    ctx.save();
    ctx.translate(indicatorX, indicatorY + bob);
    ctx.beginPath();
    ctx.moveTo(0, -5); ctx.lineTo(4, 0); ctx.lineTo(0, 5); ctx.lineTo(-4, 0);
    ctx.closePath();
    const dotColors = { idle:'#fd5', working:'#5f8', walking:'#5bf' };
    ctx.fillStyle = dotColors[this.status] || '#fff';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // Name label
    ctx.save();
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';
    const nw = ctx.measureText(this.name).width;
    const pillX = indicatorX - nw/2 - 4;
    const pillY = indicatorY - 18 + bob;
    const pillW = nw + 8;
    const pillH = 12;
    ctx.fillStyle = 'rgba(10,10,25,0.80)';
    roundRect(ctx, pillX, pillY, pillW, pillH, 4);
    ctx.fill();
    ctx.strokeStyle = this.tint;
    ctx.lineWidth = 1;
    roundRect(ctx, pillX, pillY, pillW, pillH, 4);
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.fillText(this.name, indicatorX, pillY + 9);
    ctx.restore();

    // Speech bubble
    if (this.speechText) {
      drawSpeechBubble(ctx, indicatorX, indicatorY - 22 + bob, this.speechText);
    }
  }

  containsPoint(wx, wy) {
    const drawW = RENDER_SIZE * SCALE;
    const drawH = RENDER_SIZE * SCALE;
    const sx = this.x * T - drawW/2 + T/2;
    const sy = this.y * T - drawH + T;
    return wx >= sx && wx < sx+drawW && wy >= sy && wy < sy+drawH;
  }
}

// â”€â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y, x+w,y+r); ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h, x+w-r,y+h); ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h, x,y+h-r); ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y, x+r,y);
  ctx.closePath();
}

function wrapText(ctx, text, maxW) {
  const words = text.split(' ');
  const lines = [];
  let line = '';
  for (const w of words) {
    const test = line ? line + ' ' + w : w;
    if (ctx.measureText(test).width > maxW && line) {
      lines.push(line); line = w;
    } else { line = test; }
  }
  if (line) lines.push(line);
  return lines.length ? lines : [''];
}

function drawSpeechBubble(ctx, bx, by, text) {
  ctx.save();
  ctx.font = '6px "Press Start 2P"';
  const lines = wrapText(ctx, text, 90);
  const lineH = 9;
  const padX = 5, padY = 3;
  const bw = Math.max(...lines.map(l => ctx.measureText(l).width)) + padX*2;
  const bh = lines.length * lineH + padY*2;
  const rx = bx - bw/2, ry = by - bh;
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  roundRect(ctx, rx, ry, bw, bh, 3);
  ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx-3,by); ctx.lineTo(bx,by+5); ctx.lineTo(bx+3,by);
  ctx.fillStyle = 'rgba(255,255,255,0.92)'; ctx.fill();
  ctx.fillStyle = '#222';
  ctx.textAlign = 'left';
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], rx+padX, ry+padY+lineH*(i+0.7));
  }
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VILLAGE AGENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const agents = [];

const AGENT_DEFS = [
  {
    id:'apomac', name:'ApoMac', role:'Architect',
    tint:'#4488ff', tintAlpha:0.35,
    workAnim:'carry_idle',
    homeX:30, homeY:7,
    defaultTask:'Building the future',
    startWorking:true,
    label:'ApoMac',
  },
  {
    id:'forge', name:'Forge', role:'Blacksmith',
    tint:'#ff3322', tintAlpha:0.35,
    workAnim:'crush',
    homeX:8, homeY:7,
    defaultTask:'Forging tools',
    startWorking:true,
    label:'Forge',
  },
  {
    id:'hunter', name:'Hunter', role:'Scout',
    tint:'#33cc44', tintAlpha:0.35,
    workAnim:'walk',
    homeX:20, homeY:12,
    defaultTask:'Patrolling the village',
    startWorking:false,
    patrolRoute: PATROL_ROUTES.hunter,
    label:'Hunter',
  },
  {
    id:'atlas', name:'Atlas', role:'Forester',
    tint:'#ddaa00', tintAlpha:0.35,
    workAnim:'collect',
    homeX:4, homeY:14,
    defaultTask:'Collecting timber',
    startWorking:true,
    label:'Atlas',
  },
  {
    id:'echo', name:'Echo', role:'Herbalist',
    tint:'#aa44ff', tintAlpha:0.35,
    workAnim:'watering',
    homeX:22, homeY:31,
    defaultTask:'Tending the riverside',
    startWorking:true,
    label:'Echo',
  },
  {
    id:'sentinel', name:'Sentinel', role:'Fisher',
    tint:'#00ccdd', tintAlpha:0.35,
    workAnim:'fishing',
    homeX:19, homeY:31,
    defaultTask:'Fishing at the river',
    startWorking:true,
    label:'Sentinel',
  },
];

for (const def of AGENT_DEFS) {
  agents.push(new Agent(def));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCENE PROPS (stations, trees, decorations)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trees: border + forest clusters
const TREES = [
  // Top border
  {m:0, x:1,  y:0,  s:'large'},
  {m:1, x:7,  y:-1, s:'large'},
  {m:2, x:13, y:0,  s:'large'},
  {m:0, x:19, y:-1, s:'large'},
  {m:1, x:25, y:0,  s:'large'},
  {m:2, x:31, y:-1, s:'large'},
  {m:0, x:37, y:0,  s:'large'},
  // Bottom border
  {m:1, x:1,  y:39, s:'medium'},
  {m:2, x:7,  y:40, s:'medium'},
  {m:0, x:14, y:39, s:'medium'},
  {m:1, x:22, y:40, s:'medium'},
  {m:2, x:29, y:39, s:'medium'},
  {m:0, x:36, y:40, s:'medium'},
  // Left border
  {m:0, x:0,  y:5,  s:'medium'},
  {m:1, x:-1, y:11, s:'medium'},
  {m:2, x:0,  y:17, s:'medium'},
  {m:0, x:-1, y:23, s:'medium'},
  {m:1, x:0,  y:29, s:'medium'},
  {m:2, x:-1, y:35, s:'medium'},
  // Right border
  {m:2, x:40, y:4,  s:'medium'},
  {m:0, x:41, y:10, s:'medium'},
  {m:1, x:40, y:16, s:'medium'},
  {m:2, x:41, y:22, s:'medium'},
  {m:0, x:40, y:28, s:'medium'},
  {m:1, x:41, y:34, s:'medium'},
  // Cluster near sawmill (SW)
  {m:2, x:2,  y:20, s:'large'},
  {m:0, x:4,  y:19, s:'medium'},
  {m:1, x:2,  y:18, s:'medium'},
  // Cluster near river (S)
  {m:0, x:10, y:35, s:'medium'},
  {m:2, x:16, y:36, s:'medium'},
  {m:1, x:27, y:36, s:'medium'},
  {m:0, x:33, y:35, s:'medium'},
];

// Static prop items: { img, srcX, srcY, srcW, srcH, tx, ty, tw, th, animated?, frames?, fps? }
const PROPS = [];

function buildProps() {
  // Anvil at smithy (building NW, x:5 y:4)
  PROPS.push({ img: IMG.anvil,
    srcX:0, srcY:0, srcW:192, srcH:128,
    tx:6, ty:8, tw:3, th:2, label:'Anvil' });

  // Workbench at workshop (building NE, x:28 y:4)
  PROPS.push({ img: IMG.workbench,
    srcX:0, srcY:0, srcW:192, srcH:64,
    tx:29, ty:8, tw:3, th:2, label:'Workbench' });

  // Sawmill base at sawhouse (building SW, x:5 y:22)
  PROPS.push({ img: IMG.sawmill,
    srcX:0, srcY:0, srcW:160, srcH:128,
    tx:6, ty:23, tw:3, th:2, label:'Sawmill' });

  // Bonfire near river (animated) â€” south of path
  PROPS.push({ img: IMG.bonfire,
    srcX:0, srcY:0, srcW:64, srcH:64,
    tx:20, ty:34, tw:2, th:2,
    animated:true, frames:6, fps:8, label:'Bonfire' });

  // Extra bonfire at lodge (x:28 y:22)
  PROPS.push({ img: IMG.bonfire,
    srcX:0, srcY:0, srcW:64, srcH:64,
    tx:30, ty:25, tw:2, th:2,
    animated:true, frames:6, fps:8, label:'Campfire' });
}
buildProps();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS & CAMERA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let camX = 0, camY = 0;
let zoom = 1.5;
let isDragging = false;
let dragStartX, dragStartY, dragCamX, dragCamY;
let clickMoved = false;

function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight - 36 - 32; // minus bars
  canvas.style.marginTop = '36px';
}
window.addEventListener('resize', () => { resize(); centerCamera(); });
resize();

function centerCamera() {
  camX = -(MAP_W * T / 2) + canvas.width  / (2 * zoom);
  camY = -(MAP_H * T / 2) + canvas.height / (2 * zoom);
}
centerCamera();

// Pan
canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  isDragging = true; clickMoved = false;
  canvas.classList.add('dragging');
  dragStartX = e.clientX; dragStartY = e.clientY;
  dragCamX = camX; dragCamY = camY;
});
window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - dragStartX, dy = e.clientY - dragStartY;
  if (Math.abs(dx) > 3 || Math.abs(dy) > 3) clickMoved = true;
  camX = dragCamX + dx / zoom;
  camY = dragCamY + dy / zoom;
});
window.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.classList.remove('dragging');
});

// Zoom
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldZoom = zoom;
  zoom *= e.deltaY < 0 ? 1.15 : 0.87;
  zoom = Math.max(0.5, Math.min(6, zoom));
  const mx = e.clientX, my = e.clientY - 36;
  camX += mx/zoom - mx/oldZoom;
  camY += my/zoom - my/oldZoom;
  document.getElementById('zoom-info').textContent = Math.round(zoom*100) + '%';
}, { passive:false });

// Click agent
canvas.addEventListener('click', e => {
  if (clickMoved) return;
  const rect = canvas.getBoundingClientRect();
  const wx = (e.clientX - rect.left)  / zoom - camX;
  const wy = (e.clientY - rect.top)   / zoom - camY;
  for (let i = agents.length-1; i >= 0; i--) {
    if (agents[i].containsPoint(wx, wy)) {
      selectAgent(agents[i]); return;
    }
  }
  closePanel();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawTile(img, srcX, srcY, srcW, srcH, tx, ty, tw, th) {
  if (!img || !img.complete || !img.naturalWidth) return;
  tw = tw||1; th = th||1;
  ctx.drawImage(img, srcX, srcY, srcW, srcH, tx*T, ty*T, tw*T, th*T);
}

// â”€â”€â”€ Ground layer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Floors_Tiles.png: 16px-grid sheet
//   Row 0: grass variants (green) cols 0-3
//   Row 1: wood floor (brown) cols 0-3
//   Row 2: stone floor / dirt cols 0-3
//   Row 3: more stone / gray cols 0-3
// Water_tiles.png: animated water tiles

let waterAnimFrame = 0;
let waterAnimTimer = 0;
const WATER_FRAMES = 4;

function renderGround() {
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      const t = tileMap[y][x];
      if (t === 2) {
        // Water â€” use water tiles or blue tint fallback
        if (IMG.waterTiles && IMG.waterTiles.complete && IMG.waterTiles.naturalWidth) {
          const wframe = waterAnimFrame % WATER_FRAMES;
          drawTile(IMG.waterTiles, wframe * 16, 0, 16, 16, x, y);
        } else {
          ctx.fillStyle = '#1155aa';
          ctx.fillRect(x*T, y*T, T, T);
          // shimmer
          ctx.fillStyle = 'rgba(100,180,255,0.25)';
          const shimmer = Math.sin(Date.now()/600 + x*0.8 + y*0.5) * 0.5 + 0.5;
          ctx.globalAlpha = shimmer * 0.4;
          ctx.fillRect(x*T, y*T, T, T);
          ctx.globalAlpha = 1;
        }
      } else if (t === 3) {
        // Dirt path â€” row 2 of floor tiles
        const variant = (x + y*3) % 3;
        drawTile(IMG.floorTiles, variant*16, 32, 16, 16, x, y);
      } else {
        // Grass â€” row 0 of floor tiles
        const variant = (x*7 + y*3) % 4;
        drawTile(IMG.floorTiles, variant*16, 0, 16, 16, x, y);
      }
    }
  }
}

// â”€â”€â”€ River overlay (wave effect, bridge) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderRiverOverlay() {
  // Draw river bank edge decoration
  for (let x = 0; x < MAP_W; x++) {
    // Top bank of river
    const bankY = RIVER_ROW_START;
    // Darker edge strip
    if (x !== 20 && x !== 21) { // skip bridge
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#0a3a7a';
      ctx.fillRect(x*T, bankY*T, T, 4);
      ctx.restore();
    }
  }

  // Bridge planks at col 20-21
  for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
    for (const bx of [20, 21]) {
      // Draw row 1 (wood floor) to show bridge planks
      drawTile(IMG.floorTiles, 0, 16, 16, 16, bx, ry);
      // Bridge rail lines
      ctx.save();
      ctx.strokeStyle = '#7a5530';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bx*T + 3, ry*T);
      ctx.lineTo(bx*T + 3, (ry+1)*T);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo((bx+1)*T - 3, ry*T);
      ctx.lineTo((bx+1)*T - 3, (ry+1)*T);
      ctx.stroke();
      ctx.restore();
    }
  }
}

// â”€â”€â”€ Building structures â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBuildings() {
  for (const b of BUILDINGS) {
    // Floor inside building
    for (let dy = 1; dy < b.h-1; dy++) {
      for (let dx = 1; dx < b.w-1; dx++) {
        drawTile(IMG.floorTiles, 0, 16, 16, 16, b.x+dx, b.y+dy);
      }
    }

    // Wall border using Buildings/Walls.png (if loaded) or colored rect
    if (IMG.buildWalls && IMG.buildWalls.complete && IMG.buildWalls.naturalWidth) {
      // Top wall: srcY=0 for top row
      for (let dx = 0; dx < b.w; dx++) {
        const isCorner = (dx === 0 || dx === b.w-1);
        const wallSrcX = isCorner ? (dx===0 ? 0 : 32) : 16;
        ctx.drawImage(IMG.buildWalls, wallSrcX, 0, 16, 16, (b.x+dx)*T, b.y*T, T, T);
      }
      // Bottom wall
      for (let dx = 0; dx < b.w; dx++) {
        const isCorner = (dx === 0 || dx === b.w-1);
        const wallSrcX = isCorner ? (dx===0 ? 0 : 32) : 16;
        ctx.drawImage(IMG.buildWalls, wallSrcX, 32, 16, 16, (b.x+dx)*T, (b.y+b.h-1)*T, T, T);
      }
      // Left/right walls
      for (let dy = 1; dy < b.h-1; dy++) {
        ctx.drawImage(IMG.buildWalls, 48, 16, 16, 16, b.x*T, (b.y+dy)*T, T, T);
        ctx.drawImage(IMG.buildWalls, 64, 16, 16, 16, (b.x+b.w-1)*T, (b.y+dy)*T, T, T);
      }
    } else {
      // Fallback: colored border
      ctx.save();
      ctx.strokeStyle = b.color;
      ctx.lineWidth = 2;
      ctx.fillStyle = 'rgba(30,25,20,0.6)';
      ctx.fillRect(b.x*T, b.y*T, b.w*T, b.h*T);
      ctx.strokeRect(b.x*T+1, b.y*T+1, b.w*T-2, b.h*T-2);
      ctx.restore();
    }

    // Roof on top portion (rows 0-1 of building)
    if (IMG.buildRoofs && IMG.buildRoofs.complete && IMG.buildRoofs.naturalWidth) {
      ctx.save();
      ctx.globalAlpha = 0.85;
      // Use first 64x64 region of roofs sheet, scaled to building width Ã— 2 tiles
      ctx.drawImage(IMG.buildRoofs, 0, 0, b.w*16, 32, b.x*T, b.y*T, b.w*T, 2*T);
      ctx.restore();
    } else {
      // Fallback roof: darkened strip
      ctx.save();
      ctx.fillStyle = b.color;
      ctx.globalAlpha = 0.5;
      ctx.fillRect(b.x*T, b.y*T, b.w*T, 2*T);
      ctx.restore();
    }

    // Building label
    ctx.save();
    ctx.font = '6px "Press Start 2P"';
    ctx.textAlign = 'center';
    const lw = ctx.measureText(b.label).width;
    const lx = (b.x + b.w/2) * T;
    const ly = (b.y + 0.7) * T;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    roundRect(ctx, lx - lw/2 - 3, ly - 8, lw + 6, 11, 2);
    ctx.fill();
    ctx.fillStyle = b.color;
    ctx.fillText(b.label, lx, ly);
    ctx.restore();
  }
}

// â”€â”€â”€ Trees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTreeShadows() {
  if (!IMG.shadows || !IMG.shadows.complete || !IMG.shadows.naturalWidth) return;
  for (const t of TREES) {
    const large = t.s === 'large';
    ctx.save();
    ctx.globalAlpha = 0.35;
    const sw = large ? 4*T : 2*T;
    const sh = large ? 2*T : T;
    ctx.drawImage(IMG.shadows, 0, large?48:96, large?80:32, large?32:16,
      (t.x + 0.5)*T, (t.y + 1.5)*T, sw, sh);
    ctx.restore();
  }
}

function renderTrees() {
  const imgs = [IMG.tree1, IMG.tree2, IMG.tree3];
  for (const t of TREES) {
    const img = imgs[t.m % 3];
    if (!img || !img.complete || !img.naturalWidth) continue;
    const scale = t.s === 'medium' ? 0.7 : 1.0;
    const w = img.naturalWidth  * SCALE * scale;
    const h = img.naturalHeight * SCALE * scale;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, t.x*T, t.y*T - h + 2*T, w, h);
    ctx.restore();
  }
}

// â”€â”€â”€ Props â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderProp(p) {
  if (!p.img || !p.img.complete || !p.img.naturalWidth) {
    // Fallback: colored placeholder
    ctx.fillStyle = 'rgba(80,60,30,0.8)';
    ctx.fillRect(p.tx*T, p.ty*T, p.tw*T, p.th*T);
    ctx.strokeStyle = '#a85';
    ctx.lineWidth = 1;
    ctx.strokeRect(p.tx*T, p.ty*T, p.tw*T, p.th*T);
    if (p.label) {
      ctx.font = '6px "Press Start 2P"';
      ctx.fillStyle = '#dca';
      ctx.textAlign = 'center';
      ctx.fillText(p.label, (p.tx + p.tw/2)*T, (p.ty + p.th/2)*T + 3);
    }
    return;
  }
  let sy = p.srcY;
  if (p.animated) {
    const frame = Math.floor(Date.now() / (1000 / (p.fps||8))) % p.frames;
    sy = frame * p.srcH;
  }
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(p.img, p.srcX, sy, p.srcW, p.srcH,
    p.tx*T, p.ty*T, p.tw*T, p.th*T);
  ctx.restore();
}

// â”€â”€â”€ Vegetation deco: small flowers/grass along river banks â”€â”€â”€â”€â”€â”€â”€
function renderBankVegetation() {
  // Simple green dots / small grass tufts near river
  const t = Date.now() / 1000;
  ctx.save();
  for (let x = 0; x < MAP_W; x++) {
    if (x === 20 || x === 21) continue; // skip bridge
    // Above river row
    const bankTopY = (RIVER_ROW_START - 1) * T + T - 4;
    const bankBotY = (RIVER_ROW_END + 1) * T;
    const sway = Math.sin(t * 1.5 + x * 0.8) * 2;
    // Grass blade above
    ctx.strokeStyle = '#4a8a2a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x*T + 6, bankTopY);
    ctx.lineTo(x*T + 8 + sway, bankTopY - 5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x*T + 14, bankTopY);
    ctx.lineTo(x*T + 16 + sway, bankTopY - 4);
    ctx.stroke();
    // Flowers (every 3rd tile)
    if (x % 3 === 1) {
      ctx.fillStyle = '#dd88aa';
      ctx.beginPath();
      ctx.arc(x*T + 10 + sway/2, bankTopY - 7, 2, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#ffcc44';
      ctx.beginPath();
      ctx.arc(x*T + 10 + sway/2, bankTopY - 7, 1, 0, Math.PI*2);
      ctx.fill();
    }
    // Below river
    ctx.strokeStyle = '#3a7a1a';
    ctx.beginPath();
    ctx.moveTo(x*T + 8, bankBotY + 2);
    ctx.lineTo(x*T + 10 + sway, bankBotY + 6);
    ctx.stroke();
  }
  ctx.restore();
}

// â”€â”€â”€ Water ripple overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderWaterEffects() {
  const t = Date.now() / 1000;
  ctx.save();
  ctx.globalAlpha = 0.18;
  for (let ry = RIVER_ROW_START; ry <= RIVER_ROW_END; ry++) {
    for (let x = 0; x < MAP_W; x++) {
      if (x === 20 || x === 21) continue;
      const wave = Math.sin(t * 1.2 + x * 0.6 - ry * 0.3) * 0.5 + 0.5;
      ctx.fillStyle = `rgba(150,210,255,${wave * 0.4 + 0.1})`;
      ctx.fillRect(x*T + 2, ry*T + 8, T-4, 4);
    }
  }
  ctx.restore();
}

// â”€â”€â”€ Village name banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderVillageBanner() {
  const cx = MAP_W * T / 2;
  const cy = 1.2 * T;
  ctx.save();
  ctx.font = '8px "Press Start 2P"';
  ctx.textAlign = 'center';
  const text = '~ SpawnKit Village ~';
  const tw = ctx.measureText(text).width;
  ctx.fillStyle = 'rgba(10,15,30,0.75)';
  roundRect(ctx, cx - tw/2 - 8, cy - 12, tw + 16, 18, 4);
  ctx.fill();
  ctx.strokeStyle = '#3a5';
  ctx.lineWidth = 1;
  roundRect(ctx, cx - tw/2 - 8, cy - 12, tw + 16, 18, 4);
  ctx.stroke();
  ctx.fillStyle = '#5f8';
  ctx.fillText(text, cx, cy);
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AGENT SELECTION PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let selectedAgent = null;

function selectAgent(agent) {
  selectedAgent = agent;
  document.getElementById('panel-name').textContent      = agent.name;
  document.getElementById('panel-role').textContent      = agent.role;
  document.getElementById('panel-status').textContent    = agent.status;
  document.getElementById('panel-anim').textContent      = agent.animState;
  document.getElementById('panel-location').textContent  = `(${Math.round(agent.x)}, ${Math.round(agent.y)})`;
  const tasksEl = document.getElementById('panel-tasks');
  tasksEl.innerHTML = '';
  const div = document.createElement('div');
  div.className = 'task';
  div.textContent = agent.currentTask;
  tasksEl.appendChild(div);
  document.getElementById('panel-anim-info').textContent =
    `Anim: ${agent.animState}\nFacing: ${agent.facing}\nFrame: ${agent.animFrame}`;
  document.getElementById('agent-panel').classList.add('open');
}

function closePanel() {
  selectedAgent = null;
  document.getElementById('agent-panel').classList.remove('open');
}
window.closePanel = closePanel;

// â”€â”€â”€ Bottom bar agent dots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateBottomBar() {
  const bar = document.getElementById('bottombar');
  bar.innerHTML = '';
  for (const agent of agents) {
    const div = document.createElement('div');
    div.className = 'agent-stat';
    div.onclick = () => selectAgent(agent);
    const dot = document.createElement('div');
    dot.className = 'dot';
    dot.style.background = agent.tint;
    const nm = document.createElement('span');
    nm.className = 'aname';
    nm.textContent = agent.name;
    const tk = document.createElement('span');
    tk.className = 'atask';
    tk.textContent = agent.currentTask;
    div.appendChild(dot); div.appendChild(nm); div.appendChild(tk);
    bar.appendChild(div);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMBIENT BEHAVIORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let behaviorTimer = 0;
const BEHAVIOR_INTERVAL = 8;

const TASK_PHRASES = {
  apomac:   ['Building the future','Reviewing blueprints','Planning architecture','Hauling materials'],
  forge:    ['Forging tools','Hammering iron','Smithing blades','Tempering steel'],
  hunter:   ['Patrolling the path','Scouting ahead','Checking the perimeter','On watch duty'],
  atlas:    ['Collecting timber','Chopping trees','Gathering wood','Hauling logs'],
  echo:     ['Watering plants','Tending herbs','Gathering flowers','River watch'],
  sentinel: ['Fishing at the river','Casting the line','Waiting for a bite','River patrol'],
};

// Wander zones per agent (fallback wander when not in work mode)
const WANDER_ZONES = {
  apomac:   { x1:27, y1:4,  x2:37, y2:14 },
  forge:    { x1:4,  y1:4,  x2:15, y2:14 },
  hunter:   null,  // uses patrol
  atlas:    { x1:2,  y1:12, x2:10, y2:21 },
  echo:     { x1:14, y1:28, x2:24, y2:35 },
  sentinel: { x1:16, y1:28, x2:22, y2:35 },
};

function getWanderTile(agentId) {
  const zone = WANDER_ZONES[agentId];
  if (!zone) return null;
  const tx = zone.x1 + Math.floor(Math.random() * (zone.x2 - zone.x1));
  const ty = zone.y1 + Math.floor(Math.random() * (zone.y2 - zone.y1));
  return isWalkable(tx, ty) ? { tx, ty } : null;
}

function updateAmbientBehavior(dt) {
  behaviorTimer += dt;
  if (behaviorTimer < BEHAVIOR_INTERVAL) return;
  behaviorTimer = Math.random() * 2; // stagger

  for (const agent of agents) {
    if (agent.path.length > 0) continue;
    if (agent.isPatrolling) continue; // hunter handles itself

    const roll = Math.random();
    const tasks = TASK_PHRASES[agent.id] || [];

    if (roll < 0.3) {
      // Wander
      const wp = getWanderTile(agent.id);
      if (wp) {
        agent.walkTo(wp.tx, wp.ty);
        agent.status = 'walking';
        const task = tasks[Math.floor(Math.random() * tasks.length)];
        if (task) {
          agent.currentTask = task;
          if (Math.random() < 0.35) agent.say(task, 4);
        }
      }
    } else if (roll < 0.55) {
      // Return to home and work
      agent.walkTo(agent.homeX, agent.homeY);
      agent.isWorking = true;
      agent.status = 'working';
      const task = tasks[0];
      if (task) agent.currentTask = task;
    } else {
      // Just stand and do work anim
      if (agent.isWorking) {
        agent.setDirectionalAnim(agent.workAnim);
        agent.animFrame = 0;
        agent.status = 'working';
      } else {
        agent.setDirectionalAnim('idle');
        agent.status = 'idle';
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastTime = performance.now();
let bottomBarTimer = 0;
let panelRefreshTimer = 0;

function gameLoop(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.08);
  lastTime = now;

  // Update water animation
  waterAnimTimer += dt;
  if (waterAnimTimer >= 1/3) {
    waterAnimTimer = 0;
    waterAnimFrame = (waterAnimFrame + 1) % WATER_FRAMES;
  }

  // Update agents
  for (const agent of agents) {
    agent.update(dt, agents);
  }

  // Ambient behaviors
  updateAmbientBehavior(dt);

  // Bottom bar refresh
  bottomBarTimer += dt;
  if (bottomBarTimer >= 1) {
    bottomBarTimer = 0;
    updateBottomBar();
  }

  // Panel live refresh
  panelRefreshTimer += dt;
  if (panelRefreshTimer >= 0.5 && selectedAgent) {
    panelRefreshTimer = 0;
    document.getElementById('panel-status').textContent   = selectedAgent.status;
    document.getElementById('panel-anim').textContent     = selectedAgent.animState;
    document.getElementById('panel-location').textContent = `(${Math.round(selectedAgent.x)}, ${Math.round(selectedAgent.y)})`;
    document.getElementById('panel-anim-info').textContent =
      `Anim: ${selectedAgent.animState}\nFacing: ${selectedAgent.facing}\nFrame: ${selectedAgent.animFrame}`;
  }

  // â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#1a2a14';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.scale(zoom, zoom);
  ctx.translate(camX, camY);
  ctx.imageSmoothingEnabled = false;

  // Layer 1: Ground (grass, paths, water)
  renderGround();

  // Layer 2: River overlay (bridge planks + bank edges)
  renderRiverOverlay();

  // Layer 3: Building floors + walls
  renderBuildings();

  // Layer 4: Bank vegetation (behind agents)
  renderBankVegetation();

  // Layer 5: Water effects
  renderWaterEffects();

  // Layer 6: Tree shadows
  renderTreeShadows();

  // Layer 7: Z-sorted renderables (agents + props + trees interleaved by Y)
  const renderables = [];

  // Props
  for (const p of PROPS) {
    renderables.push({ sortY: p.ty + p.th, draw: () => renderProp(p) });
  }
  // Trees
  const treeImgs = [IMG.tree1, IMG.tree2, IMG.tree3];
  for (const t of TREES) {
    const img = treeImgs[t.m % 3];
    if (!img || !img.complete || !img.naturalWidth) continue;
    const scale = t.s === 'medium' ? 0.7 : 1.0;
    const w = img.naturalWidth  * SCALE * scale;
    const h = img.naturalHeight * SCALE * scale;
    const ty_bottom = t.y + 2;
    renderables.push({
      sortY: ty_bottom,
      draw: () => {
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, t.x*T, t.y*T - h + 2*T, w, h);
        ctx.restore();
      }
    });
  }
  // Agents
  for (const agent of agents) {
    renderables.push({ sortY: agent.y, draw: () => agent.draw(ctx) });
  }

  renderables.sort((a,b) => a.sortY - b.sortY);
  for (const r of renderables) r.draw();

  // Layer 8: Village banner (top)
  renderVillageBanner();

  // Layer 9: Selection highlight
  if (selectedAgent) {
    const sa = selectedAgent;
    const dw = RENDER_SIZE * SCALE;
    const dh = RENDER_SIZE * SCALE;
    ctx.save();
    ctx.strokeStyle = '#5f8';
    ctx.lineWidth = 1;
    ctx.setLineDash([3,3]);
    ctx.strokeRect(sa.x*T - dw/2 + T/2 - 2, sa.y*T - dh + T - 2, dw+4, dh+4);
    ctx.restore();
  }

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOADING SCREEN & INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawLoadingScreen() {
  ctx.fillStyle = '#1a2a14';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.font = '12px "Press Start 2P"';
  ctx.fillStyle = '#5f8';
  ctx.textAlign = 'center';
  ctx.fillText('ğŸŒ¿ SPAWNKIT VILLAGE', canvas.width/2, canvas.height/2 - 20);
  ctx.font = '8px "Press Start 2P"';
  ctx.fillStyle = '#8ab';
  const pct = totalImages > 0 ? Math.round((loadedCount / totalImages) * 100) : 0;
  ctx.fillText(`Loading... ${pct}%`, canvas.width/2, canvas.height/2 + 10);
  // Progress bar
  const bw = 200, bh = 8;
  const bx = canvas.width/2 - bw/2, by = canvas.height/2 + 24;
  ctx.strokeStyle = '#3a5';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx, by, bw, bh);
  ctx.fillStyle = '#3a5';
  ctx.fillRect(bx, by, bw * (loadedCount / Math.max(totalImages, 1)), bh);
}

function waitForLoad() {
  drawLoadingScreen();
  if (loadedCount >= totalImages && totalImages > 0) {
    console.log('[SpawnKit Village] All assets loaded. Starting game loop.');
    updateBottomBar();
    // Scatter agents slightly
    for (const agent of agents) {
      agent.x = agent.homeX + (Math.random() - 0.5) * 0.5;
      agent.y = agent.homeY + (Math.random() - 0.5) * 0.5;
    }
    requestAnimationFrame(gameLoop);
  } else {
    requestAnimationFrame(waitForLoad);
  }
}

requestAnimationFrame(waitForLoad);

console.log('[SpawnKit Village] Initialized. Assets loading:', totalImages);
</script>
</body>
</html>
