<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpawnKit â€” Medieval Castle 3D</title>
    <script>window.OC_RELAY_URL = window.OC_RELAY_URL || 'https://fleet.spawnkit.ai';</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel:wght@400;500;600;700&family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SpawnKit Medieval Castle v4.0 â€” Three.js 3D Diorama
           Real Kenney .glb models, isometric camera, animated characters
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        :root {
            --castle-dark-navy: #1a1a2e;
            --castle-navy: #16213e;
            --castle-blue: #0f3460;
            --castle-red: #e94560;
            --castle-gold: #c9a959;
            --castle-brown: #8b7355;
            --castle-parchment: #f4e4bc;
            --castle-stone-light: #a8a299;
            --castle-stone-dark: #5c5750;
            --castle-black: #0d0d0d;
            --castle-silver: #c0c0c0;
            --bg-primary: var(--castle-dark-navy);
            --bg-secondary: var(--castle-navy);
            --bg-tertiary: var(--castle-blue);
            --bg-parchment: var(--castle-parchment);
            --bg-scroll: linear-gradient(145deg, #f4e4bc 0%, #e8d5a3 100%);
            --text-primary: var(--castle-parchment);
            --text-secondary: var(--castle-stone-light);
            --text-accent: var(--castle-gold);
            --text-dark: var(--castle-navy);
            --text-red: var(--castle-red);
            --border-stone: rgba(168, 162, 153, 0.3);
            --border-gold: rgba(201, 169, 89, 0.5);
            --status-active: #4ade80;
            --status-busy: #fbbf24;
            --status-idle: #64748b;
            --status-error: var(--castle-red);
            --font-medieval: 'MedievalSharp', fantasy;
            --font-serif: 'Cinzel', serif;
            --font-body: 'Crimson Text', serif;
            --font-mono: 'Courier New', monospace;
            --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px;
            --space-5: 20px; --space-6: 24px; --space-8: 32px;
            --radius-sm: 4px; --radius-md: 8px; --radius-lg: 12px;
            --shadow-deep: 0 8px 32px rgba(0,0,0,0.6);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--castle-dark-navy);
            color: var(--text-primary);
            font-family: var(--font-body);
            overflow: hidden;
            height: 100vh;
        }

        /* â”€â”€ Main Grid Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-layout {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            grid-template-rows: 70px 1fr;
            grid-template-areas:
                "header header header"
                "sidebar main rightpanel";
            height: 100vh;
        }

        /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-header {
            grid-area: header;
            background: linear-gradient(135deg, #0d0d1a 0%, var(--castle-navy) 50%, #0d0d1a 100%);
            border-bottom: 2px solid var(--border-gold);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 var(--space-6);
            z-index: 10;
        }
        .castle-banner { display: flex; align-items: center; gap: var(--space-4); }
        .castle-crest { font-size: 32px; filter: drop-shadow(0 0 8px rgba(201,169,89,0.6)); }
        .castle-name { font-family: var(--font-medieval); font-size: 22px; color: var(--castle-gold); letter-spacing: 2px; }
        .castle-subtitle { font-family: var(--font-serif); font-size: 11px; color: var(--castle-stone-light); text-transform: uppercase; letter-spacing: 3px; }
        .castle-status-bar { display: flex; gap: var(--space-6); align-items: center; }
        .status-indicator { display: flex; align-items: center; gap: var(--space-2); font-size: 13px; font-family: var(--font-serif); }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.active { background: var(--status-active); box-shadow: 0 0 6px var(--status-active); }
        .status-dot.busy { background: var(--status-busy); box-shadow: 0 0 6px var(--status-busy); }

        /* â”€â”€ Left Sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-sidebar {
            grid-area: sidebar;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-stone);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .sidebar-header {
            padding: var(--space-5) var(--space-4);
            border-bottom: 1px solid var(--border-stone);
            background: linear-gradient(135deg, var(--castle-stone-dark), var(--castle-navy));
        }
        .sidebar-title { font-family: var(--font-medieval); font-size: 18px; color: var(--castle-gold); text-align: center; }
        .agents-scroll { flex: 1; overflow-y: auto; padding: var(--space-3); }

        .agent-card {
            background: linear-gradient(135deg, rgba(22,33,62,0.9), rgba(15,52,96,0.4));
            border: 1px solid var(--border-stone);
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .agent-card:hover { border-color: var(--castle-gold); transform: translateX(3px); box-shadow: 0 2px 8px rgba(201,169,89,0.15); }
        .agent-card.selected { border-color: var(--castle-red); box-shadow: 0 0 12px rgba(233,69,96,0.3); background: linear-gradient(135deg, rgba(233,69,96,0.1), rgba(15,52,96,0.4)); }
        .agent-header { display: flex; align-items: center; gap: var(--space-3); }
        .agent-avatar {
            width: 40px; height: 40px; border-radius: var(--radius-md);
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; background: var(--castle-stone-dark);
        }
        .agent-avatar img { width: 100%; height: 100%; object-fit: cover; image-rendering: pixelated; }
        .agent-name { font-family: var(--font-serif); font-size: 14px; color: var(--text-primary); font-weight: 600; }
        .agent-role { font-size: 11px; color: var(--text-secondary); font-style: italic; }
        .agent-status { margin-left: auto; display: flex; align-items: center; gap: 4px; }
        .agent-metrics { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-2); margin-top: var(--space-2); padding-top: var(--space-2); border-top: 1px solid rgba(168,162,153,0.15); }
        .metric-item { text-align: center; }
        .metric-label { font-size: 9px; color: var(--text-secondary); text-transform: uppercase; display: block; }
        .metric-value { font-family: var(--font-serif); font-size: 13px; color: var(--castle-gold); font-weight: 600; }

        /* â”€â”€ Main Scene (Three.js Canvas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-main {
            grid-area: main;
            position: relative;
            overflow: hidden;
            background: #0a0a1a;
        }
        .castle-main canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* â”€â”€ Scene Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .scene-controls {
            position: absolute;
            top: var(--space-3); left: var(--space-3);
            z-index: 30;
            display: flex; gap: var(--space-2);
        }
        .control-btn {
            width: 32px; height: 32px;
            border: 1px solid var(--border-gold);
            border-radius: var(--radius-sm);
            background: rgba(201,169,89,0.9);
            color: var(--castle-navy);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 14px;
            transition: all 0.2s;
        }
        .control-btn:hover { background: var(--castle-parchment); transform: translateY(-1px); }

        /* â”€â”€ Character Name Labels (HTML overlay) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .character-label {
            position: absolute;
            pointer-events: none;
            font-family: var(--font-serif);
            font-size: 11px;
            color: var(--castle-gold);
            text-shadow: 0 0 6px rgba(0,0,0,0.95), 0 1px 3px black, 0 0 12px rgba(0,0,0,0.8);
            white-space: nowrap;
            transform: translate(-50%, -100%);
            padding: 2px 8px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(201,169,89,0.4);
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            font-weight: 600;
        }
        .character-label.visible { opacity: 1; }
        .character-label.selected {
            opacity: 1;
            color: var(--castle-red);
            border-color: rgba(233,69,96,0.6);
            background: rgba(0,0,0,0.7);
        }

        /* â”€â”€ Loading Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .loading-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #0d0d1a, var(--castle-navy));
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100;
            transition: opacity 0.8s ease;
        }
        .loading-screen.hidden { opacity: 0; pointer-events: none; }
        .loading-title {
            font-family: var(--font-medieval);
            font-size: 28px;
            color: var(--castle-gold);
            margin-bottom: 24px;
            text-shadow: 0 0 20px rgba(201,169,89,0.4);
        }
        .loading-bar-container {
            width: 300px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border-gold);
        }
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--castle-gold), var(--castle-red));
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        .loading-text {
            font-family: var(--font-serif);
            font-size: 12px;
            color: var(--castle-stone-light);
            margin-top: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* â”€â”€ Right Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-rightpanel {
            grid-area: rightpanel;
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-stone);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .rightpanel-header {
            padding: var(--space-5) var(--space-4);
            border-bottom: 1px solid var(--border-stone);
            background: linear-gradient(135deg, var(--castle-stone-dark), var(--castle-navy));
        }
        .rightpanel-title { font-family: var(--font-medieval); font-size: 18px; color: var(--castle-gold); text-align: center; }
        .activity-scroll { flex: 1; overflow-y: auto; padding: var(--space-3); }

        .activity-item {
            background: var(--bg-scroll);
            border: 1px solid var(--border-gold);
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            margin-bottom: var(--space-3);
            color: var(--text-dark);
            transition: transform 0.2s ease;
        }
        .activity-item:first-child { border-color: var(--castle-gold); box-shadow: 0 1px 6px rgba(201,169,89,0.15); }
        .activity-time { font-size: 11px; color: var(--castle-brown); margin-bottom: 2px; }
        .activity-message { font-size: 13px; line-height: 1.5; color: var(--castle-navy); }
        .activity-agent { font-weight: 600; color: var(--castle-red); }

        /* â”€â”€ Stats Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .stats-panel {
            background: var(--bg-scroll);
            border: 2px solid var(--castle-gold);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            margin: var(--space-3);
        }
        .stats-title { font-family: var(--font-medieval); font-size: 16px; color: var(--castle-navy); text-align: center; margin-bottom: var(--space-3); }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-3); }
        .stat-item { text-align: center; }
        .stat-value { font-family: var(--font-serif); font-size: 20px; font-weight: 600; color: var(--castle-red); display: block; }
        .stat-label { font-size: 12px; color: var(--castle-brown); text-transform: uppercase; letter-spacing: 0.5px; }

        /* â”€â”€ Demo Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .demo-badge {
            position: fixed; top: 6px; right: 6px;
            background: var(--castle-red); color: white;
            padding: 2px 8px; border-radius: var(--radius-sm);
            font-family: var(--font-serif); font-size: 11px; font-weight: 600;
            text-transform: uppercase; z-index: 1000;
        }

        /* â”€â”€ Scrollbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .agents-scroll::-webkit-scrollbar, .activity-scroll::-webkit-scrollbar { width: 8px; }
        .agents-scroll::-webkit-scrollbar-track, .activity-scroll::-webkit-scrollbar-track { background: var(--castle-stone-dark); }
        .agents-scroll::-webkit-scrollbar-thumb, .activity-scroll::-webkit-scrollbar-thumb { background: var(--castle-gold); border-radius: 4px; }

        /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        @media (max-width: 1200px) { .castle-layout { grid-template-columns: 260px 1fr 280px; } }
        @media (max-width: 1024px) {
            .castle-layout { grid-template-columns: 1fr; grid-template-rows: 70px 1fr; grid-template-areas: "header" "main"; }
            .castle-sidebar, .castle-rightpanel { display: none; }
        }
    </style>
</head>
<body>
    <script>
        window.OC_RELAY_URL = 'https://fleet.spawnkit.ai';
        window.OC_RELAY_TOKEN = 'sk-oc-proxy-spawnkit-2026';
    </script>

    <div class="castle-layout">
        <header class="castle-header">
            <div class="castle-banner">
                <div class="castle-crest">ğŸ°</div>
                <div>
                    <h1 class="castle-name">Royal Command</h1>
                    <div class="castle-subtitle">Medieval AI Fleet</div>
                </div>
            </div>
            <div class="castle-status-bar">
                <div class="status-indicator"><div class="status-dot active"></div><span>Castle Online</span></div>
                <div class="status-indicator"><div class="status-dot busy"></div><span id="active-agents">8 Knights Active</span></div>
            </div>
        </header>

        <aside class="castle-sidebar">
            <div class="sidebar-header"><h2 class="sidebar-title">âš”ï¸ Royal Court</h2></div>
            <div class="agents-scroll" id="agents-list"></div>
        </aside>

        <main class="castle-main" id="scene-container">
            <!-- Loading Screen -->
            <div class="loading-screen" id="loading-screen">
                <div class="loading-title">âš”ï¸ Summoning the Castle</div>
                <div class="loading-bar-container">
                    <div class="loading-bar" id="loading-bar"></div>
                </div>
                <div class="loading-text" id="loading-text">Preparing siege...</div>
            </div>

            <!-- Character label overlays -->
            <div id="labels-container"></div>

            <!-- Controls -->
            <div class="scene-controls">
                <button class="control-btn" id="btn-toggle-sound" title="Toggle Sound">ğŸ”Š</button>
                <button class="control-btn" id="btn-fullscreen" title="Fullscreen">â›¶</button>
                <button class="control-btn" id="btn-reset-camera" title="Reset Camera">ğŸ¯</button>
            </div>
        </main>

        <aside class="castle-rightpanel">
            <div class="rightpanel-header"><h2 class="rightpanel-title">ğŸ“œ Royal Decrees</h2></div>
            <div class="stats-panel">
                <h3 class="stats-title">Castle Status</h3>
                <div class="stats-grid">
                    <div class="stat-item"><span class="stat-value" id="stat-missions">12</span><span class="stat-label">Quests</span></div>
                    <div class="stat-item"><span class="stat-value" id="stat-completed">8</span><span class="stat-label">Done</span></div>
                    <div class="stat-item"><span class="stat-value" id="stat-resources">2.4k</span><span class="stat-label">Gold</span></div>
                    <div class="stat-item"><span class="stat-value" id="stat-uptime">99.8%</span><span class="stat-label">Uptime</span></div>
                </div>
            </div>
            <div class="activity-scroll" id="activity-log"></div>
        </aside>
    </div>

    <div class="demo-badge" id="demo-badge" style="display: none;">Demo Mode</div>

    <script src="../src/data-bridge.js"></script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MedievalCastle3D â€” Three.js Scene
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class MedievalCastle3D {
        constructor() {
            this.agents = new Map();
            this.selectedAgent = null;
            this.soundEnabled = true;
            this.audioContext = null;
            this.sounds = new Map();

            // Three.js
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.controls = null;
            this.loader = new GLTFLoader();
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            this.clock = new THREE.Clock();

            // Characters
            this.characterModels = new Map(); // agentId â†’ { group, mixer, waypoints, waypointIndex, speed, ... }
            this.animationMixers = [];
            this.hoveredAgent = null;
            this.labelElements = new Map();

            // Loading
            this.totalModels = 0;
            this.loadedModels = 0;

            this.init();
        }

        async init() {
            this.setupThreeJS();
            this.setupAudio();
            this.setupAgents();
            this.setupEventListeners();
            this.setupUI();
            await this.loadAllModels();
            this.setupDataBridge();
            this.animate();
            this.playSound('horn');
        }

        // â”€â”€ Three.js Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupThreeJS() {
            const container = document.getElementById('scene-container');
            const w = container.clientWidth;
            const h = container.clientHeight;

            // Scene
            this.scene = new THREE.Scene();

            // Sky gradient background
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 2;
            skyCanvas.height = 512;
            const ctx = skyCanvas.getContext('2d');
            const grad = ctx.createLinearGradient(0, 0, 0, 512);
            grad.addColorStop(0, '#0a1025');
            grad.addColorStop(0.2, '#1a2545');
            grad.addColorStop(0.45, '#2a4a7a');
            grad.addColorStop(0.65, '#5a8ab0');
            grad.addColorStop(0.8, '#8ab8d0');
            grad.addColorStop(0.92, '#d4a574');
            grad.addColorStop(1.0, '#e8c49a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 2, 512);
            const skyTex = new THREE.CanvasTexture(skyCanvas);
            skyTex.needsUpdate = true;
            this.scene.background = skyTex;

            // Fog for depth
            this.scene.fog = new THREE.FogExp2(0x5a7a9a, 0.006);

            // Orthographic camera for isometric view
            const aspect = w / h;
            const frustum = 9;
            this.camera = new THREE.OrthographicCamera(
                -frustum * aspect, frustum * aspect,
                frustum, -frustum,
                0.1, 200
            );
            // Isometric angle: ~45Â° azimuth, ~42Â° elevation (slightly more top-down)
            const dist = 40;
            const azimuth = Math.PI / 4; // 45Â°
            const elevation = Math.atan(Math.sin(Math.PI / 4.2)); // ~42Â°
            this.camera.position.set(
                dist * Math.cos(elevation) * Math.sin(azimuth),
                dist * Math.sin(elevation),
                dist * Math.cos(elevation) * Math.cos(azimuth)
            );
            this.camera.lookAt(0, 2, 0);

            // Renderer
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            this.renderer.setSize(w, h);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            this.renderer.toneMappingExposure = 1.2;
            this.renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.insertBefore(this.renderer.domElement, container.firstChild);

            // Orbit Controls
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.08;
            this.controls.enablePan = true;
            this.controls.minZoom = 0.5;
            this.controls.maxZoom = 3;
            this.controls.maxPolarAngle = Math.PI / 2.2; // Don't go underground
            this.controls.minPolarAngle = Math.PI / 8;
            this.controls.target.set(0, 2, 0);
            this.controls.update();

            // Lighting
            this.setupLighting();

            // Ground
            this.createGround();

            // Resize handler
            window.addEventListener('resize', () => this.onResize());
        }

        setupLighting() {
            // Ambient â€” cool dusk tone
            const ambient = new THREE.AmbientLight(0xc8d8f0, 0.35);
            this.scene.add(ambient);

            // Hemisphere: twilight sky / mossy ground
            const hemi = new THREE.HemisphereLight(0x7090c0, 0x2a4a20, 0.3);
            this.scene.add(hemi);

            // Sun â€” low angle for dramatic long shadows (golden hour)
            const sun = new THREE.DirectionalLight(0xffd080, 2.0);
            sun.position.set(30, 40, 15);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 4096;
            sun.shadow.mapSize.height = 4096;
            sun.shadow.camera.near = 1;
            sun.shadow.camera.far = 120;
            sun.shadow.camera.left = -55;
            sun.shadow.camera.right = 55;
            sun.shadow.camera.top = 55;
            sun.shadow.camera.bottom = -55;
            sun.shadow.bias = -0.0005;
            sun.shadow.normalBias = 0.02;
            this.scene.add(sun);

            // Fill light from opposite side (blue-ish moonrise)
            const fill = new THREE.DirectionalLight(0x6080ff, 0.4);
            fill.position.set(-20, 15, -10);
            this.scene.add(fill);

            this.torchLights = [];

            // Gate torches
            const addTorch = (x, y, z) => {
                const t = new THREE.PointLight(0xff8800, 3.0, 9, 2);
                t.position.set(x, y, z);
                this.scene.add(t);
                this.torchLights.push(t);
            };
            addTorch(-1.8, 2.8, 6.2);
            addTorch( 1.8, 2.8, 6.2);

            // Keep courtyard fire
            const keepLight = new THREE.PointLight(0xffaa44, 2.0, 14, 2);
            keepLight.position.set(0, 1.5, 0);
            this.scene.add(keepLight);
            this.torchLights.push(keepLight);

            // Graveyard eerie green light
            const graveLight = new THREE.PointLight(0x44ff88, 1.2, 18, 2);
            graveLight.position.set(-16, 3, -13);
            this.scene.add(graveLight);
            this.torchLights.push(graveLight);

            // Village fire basket lights
            addTorch(-4, 1.5, 9.5);
            addTorch( 4, 1.5, 9.5);

            // Training grounds torch
            addTorch(16, 2, -2);

            // Chapel candle window glow
            const chapelGlow = new THREE.PointLight(0xffcc66, 1.5, 8, 2);
            chapelGlow.position.set(-8, 2, 15);
            this.scene.add(chapelGlow);
            this.torchLights.push(chapelGlow);
        }

        createGround() {
            // â”€â”€ Base ground â€” 120Ã—120 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const groundGeo = new THREE.PlaneGeometry(120, 120, 60, 60);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3d6b22,
                roughness: 0.97,
                metalness: 0.01,
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            this.scene.add(ground);

            // Organic terrain bumps â€” gentle rolling hills
            const pos = groundGeo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const dist = Math.sqrt(x * x + y * y);
                if (dist > 10) {
                    pos.setZ(i, (
                        Math.sin(x * 0.35) * Math.cos(y * 0.28) * 0.5 +
                        Math.sin(x * 0.9 + 1.5) * 0.2 +
                        Math.random() * 0.12
                    ));
                }
            }
            groundGeo.computeVertexNormals();

            // â”€â”€ Graveyard dark ground patch (NW zone) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const graveGeo = new THREE.PlaneGeometry(20, 22, 4, 4);
            const graveGround = new THREE.Mesh(graveGeo, new THREE.MeshStandardMaterial({
                color: 0x1a2410, roughness: 0.99,
            }));
            graveGround.rotation.x = -Math.PI / 2;
            graveGround.position.set(-16, 0.005, -13);
            graveGround.receiveShadow = true;
            this.scene.add(graveGround);

            // â”€â”€ Dirt road: gate â†’ village â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const pathGeo = new THREE.PlaneGeometry(3.5, 24, 2, 10);
            const path = new THREE.Mesh(pathGeo, new THREE.MeshStandardMaterial({ color: 0x7a5530, roughness: 0.98 }));
            path.rotation.x = -Math.PI / 2;
            path.position.set(0, 0.008, 16);
            path.receiveShadow = true;
            this.scene.add(path);

            // â”€â”€ Training ground dirt patch (NE zone) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const trainGeo = new THREE.PlaneGeometry(18, 16, 4, 4);
            const trainGround = new THREE.Mesh(trainGeo, new THREE.MeshStandardMaterial({ color: 0x5e4020, roughness: 0.98 }));
            trainGround.rotation.x = -Math.PI / 2;
            trainGround.position.set(16, 0.005, -5);
            trainGround.receiveShadow = true;
            this.scene.add(trainGround);

            // â”€â”€ Moat â€” wider ring, deeper blue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const moatShape = new THREE.Shape();
            moatShape.absarc(0, 0, 9.0, 0, Math.PI * 2, false);
            const moatHole = new THREE.Path();
            moatHole.absarc(0, 0, 7.0, 0, Math.PI * 2, true);
            moatShape.holes.push(moatHole);
            const moatGeo = new THREE.ShapeGeometry(moatShape, 80);
            const moat = new THREE.Mesh(moatGeo, new THREE.MeshStandardMaterial({
                color: 0x0a2f48, transparent: true, opacity: 0.88,
                roughness: 0.12, metalness: 0.45, side: THREE.DoubleSide,
            }));
            moat.rotation.x = -Math.PI / 2;
            moat.position.y = -0.005;
            this.scene.add(moat);

            // Shimmer layer
            const shim = new THREE.Mesh(
                new THREE.RingGeometry(7.02, 8.98, 80),
                new THREE.MeshStandardMaterial({
                    color: 0x1a5a80, transparent: true, opacity: 0.28,
                    roughness: 0.06, metalness: 0.7, side: THREE.DoubleSide,
                })
            );
            shim.rotation.x = -Math.PI / 2;
            shim.position.y = 0.04;
            this.scene.add(shim);
            this.moatShimmer = shim;

            // â”€â”€ Winding River â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Catmull-Rom curve points: NW â†’ castle south â†’ E
            const riverPoints = [
                new THREE.Vector2(-20, -25),
                new THREE.Vector2(-14, -18),
                new THREE.Vector2(-10, -10),
                new THREE.Vector2(-6,  -4),
                new THREE.Vector2(-2,   2),
                new THREE.Vector2( 0,   7),   // passes near drawbridge (castle gate z=7)
                new THREE.Vector2( 4,   9),
                new THREE.Vector2( 8,   8),
                new THREE.Vector2(12,   5),
                new THREE.Vector2(18,   4),
                new THREE.Vector2(24,   5),
                new THREE.Vector2(30,   5),
            ];

            // Build river as a series of quads along the curve
            const riverWidth = 2.5;
            const riverMat = new THREE.MeshStandardMaterial({
                color: 0x1a5a8a, transparent: true, opacity: 0.7,
                roughness: 0.15, metalness: 0.3, side: THREE.DoubleSide,
            });
            const riverGroup = new THREE.Group();
            riverGroup.position.y = -0.01;

            for (let i = 0; i < riverPoints.length - 1; i++) {
                const a = riverPoints[i];
                const b = riverPoints[i + 1];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                const segGeo = new THREE.PlaneGeometry(len + 0.2, riverWidth);
                const seg = new THREE.Mesh(segGeo, riverMat);
                seg.rotation.x = -Math.PI / 2;
                seg.rotation.z = -angle;   // PlaneGeometry on XZ, rotate to align
                // Wait â€” PlaneGeometry is in XY after rotation.x; rotate around Y axis:
                seg.rotation.z = 0;
                // Actually re-approach: build flat (rotation.x = -PI/2), then rotate.y
                seg.rotation.set(-Math.PI / 2, 0, 0);
                // position at midpoint (note: group is in world XZ; PlaneGeometry on XZ after rotation)
                seg.position.set((a.x + b.x) / 2, 0, (a.y + b.y) / 2);
                seg.rotation.y = -angle;
                riverGroup.add(seg);
            }
            this.scene.add(riverGroup);

            // River shimmer layer â€” lighter blue on top
            const riverShimmerGroup = new THREE.Group();
            riverShimmerGroup.position.y = 0.03;
            const riverShimMat = new THREE.MeshStandardMaterial({
                color: 0x4aa8e8, transparent: true, opacity: 0.3,
                roughness: 0.06, metalness: 0.7, side: THREE.DoubleSide,
            });
            for (let i = 0; i < riverPoints.length - 1; i++) {
                const a = riverPoints[i];
                const b = riverPoints[i + 1];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const segGeo = new THREE.PlaneGeometry(len + 0.2, riverWidth * 0.7);
                const seg = new THREE.Mesh(segGeo, riverShimMat.clone());
                seg.rotation.set(-Math.PI / 2, 0, 0);
                seg.position.set((a.x + b.x) / 2, 0, (a.y + b.y) / 2);
                seg.rotation.y = -angle;
                riverShimmerGroup.add(seg);
            }
            this.scene.add(riverShimmerGroup);
            this.riverShimmer = riverShimmerGroup;

            // â”€â”€ Campfire factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const makeFire = (x, z, scale = 1) => {
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.18 * scale, 0.22 * scale, 0.12, 8),
                    new THREE.MeshStandardMaterial({ color: 0x5a3a1a, roughness: 0.9 })
                );
                base.position.set(x, 0.06, z);
                base.castShadow = true;
                this.scene.add(base);

                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.14 * scale, 0.42 * scale, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xff5500, emissive: 0xff3300, emissiveIntensity: 2.8,
                        transparent: true, opacity: 0.88,
                    })
                );
                flame.position.set(x, 0.30 * scale, z);
                this.scene.add(flame);

                const inner = new THREE.Mesh(
                    new THREE.ConeGeometry(0.07 * scale, 0.24 * scale, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xffee00, emissive: 0xffcc00, emissiveIntensity: 3.5,
                        transparent: true, opacity: 0.95,
                    })
                );
                inner.position.set(x, 0.44 * scale, z);
                this.scene.add(inner);

                const fLight = new THREE.PointLight(0xff7722, 4.5 * scale, 9 * scale, 2);
                fLight.position.set(x, 0.8 * scale, z);
                this.scene.add(fLight);
                if (this.torchLights) this.torchLights.push(fLight);

                return { flame, inner, light: fLight, scale };
            };

            // One central campfire in courtyard
            this.campFires = [makeFire(1.5, 1.5, 1)];
            this.campflame = this.campFires[0].flame;
            this.campflameInner = this.campFires[0].inner;
            this.campFireLight = this.campFires[0].light;
        }

        animateCampfire(elapsed) {
            if (!this.campFires) return;
            this.campFires.forEach((cf, i) => {
                if (!cf || !cf.flame) return;
                const phase = elapsed + i * 1.7;
                const flicker = 0.85 + Math.sin(phase * 11.3) * 0.12 + Math.sin(phase * 17.7) * 0.08;
                cf.flame.scale.set(flicker, flicker + Math.sin(phase * 9) * 0.14, flicker);
                cf.inner.scale.set(flicker, flicker + Math.cos(phase * 13.2) * 0.16, flicker);
                cf.flame.rotation.y = elapsed * 1.8 + i;
                if (cf.light) {
                    cf.light.intensity = 4.5 * (cf.scale || 1) * (0.82 + Math.sin(phase * 12 + 1) * 0.18);
                }
            });
            // Shimmer moat water
            if (this.moatShimmer) {
                this.moatShimmer.material.opacity = 0.22 + Math.sin(elapsed * 0.7) * 0.08;
            }
            // Animate river shimmer â€” flowing pulse along segments
            if (this.riverShimmer) {
                this.riverShimmer.children.forEach((seg, i) => {
                    if (seg.material) {
                        const wave = Math.sin(elapsed * 1.2 + i * 0.45) * 0.10;
                        seg.material.opacity = 0.25 + wave;
                        seg.position.y = Math.sin(elapsed * 0.8 + i * 0.3) * 0.005;
                    }
                });
            }
        }

        onResize() {
            const container = document.getElementById('scene-container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const aspect = w / h;
            const frustum = 9;

            this.camera.left = -frustum * aspect;
            this.camera.right = frustum * aspect;
            this.camera.top = frustum;
            this.camera.bottom = -frustum;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(w, h);
        }

        // â”€â”€ Model Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async loadAllModels() {
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');
            const loadingScreen = document.getElementById('loading-screen');

            // Define all models to load
            const modelDefs = this.getModelDefinitions();
            this.totalModels = modelDefs.length;

            const updateProgress = (label) => {
                this.loadedModels++;
                const pct = Math.round((this.loadedModels / this.totalModels) * 100);
                loadingBar.style.width = pct + '%';
                loadingText.textContent = label;
            };

            // Load models in batches
            const batchSize = 6;
            for (let i = 0; i < modelDefs.length; i += batchSize) {
                const batch = modelDefs.slice(i, i + batchSize);
                await Promise.all(batch.map(async (def) => {
                    try {
                        const gltf = await this.loadModel(def.path);
                        this.placeModel(gltf, def);
                        updateProgress(def.label || def.path.split('/').pop());
                    } catch (e) {
                        console.warn(`Failed to load ${def.path}:`, e);
                        updateProgress('(skipped) ' + def.path.split('/').pop());
                    }
                }));
            }

            // Load characters
            await this.loadCharacters(updateProgress);

            // Hide loading screen
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                setTimeout(() => loadingScreen.remove(), 1000);
            }, 500);
        }

        loadModel(path) {
            // Cache loaded models to avoid re-downloading same file
            if (!this._modelCache) this._modelCache = new Map();
            if (this._modelCache.has(path)) {
                // Return a deep clone of the cached model
                const cached = this._modelCache.get(path);
                return Promise.resolve({
                    scene: cached.scene.clone(true),
                    animations: cached.animations,
                });
            }
            return new Promise((resolve, reject) => {
                this.loader.load(path, (gltf) => {
                    this._modelCache.set(path, gltf);
                    resolve({
                        scene: gltf.scene.clone(true),
                        animations: gltf.animations,
                    });
                }, undefined, reject);
            });
        }

        getModelDefinitions() {
            const defs = [];
            const P = (path, x, y, z, ry = 0, s = 1, label = '') => {
                defs.push({ path, x, y, z, ry, scale: s, label });
                this.totalModels++;
            };

            // â”€â”€ Corner Towers (4 corners) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Each tower: base + mid + top stacked vertically
            // Kenney models are typically ~1 unit each, we need to figure out exact stack heights
            
            // Tower positions (square castle layout)
            const towerPositions = [
                { x: -5, z: -5, label: 'NW Tower' },
                { x:  5, z: -5, label: 'NE Tower' },
                { x: -5, z:  5, label: 'SW Tower' },
                { x:  5, z:  5, label: 'SE Tower' },
            ];

            towerPositions.forEach(tp => {
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: tp.x, y: 0, z: tp.z, ry: 0, scale: 1, label: tp.label + ' base' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tp.x, y: 1, z: tp.z, ry: 0, scale: 1, label: tp.label + ' mid' });
                defs.push({ path: 'assets/castle/tower-square-top-roof.glb', x: tp.x, y: 2, z: tp.z, ry: 0, scale: 1, label: tp.label + ' top' });
            });

            // â”€â”€ Central Keep (taller, larger â€” focal point) â”€â”€â”€â”€â”€â”€
            const ks = 1.4; // keep scale â€” bigger than towers
            defs.push({ path: 'assets/castle/tower-square-base-color.glb', x: 0, y: 0, z: 0, ry: 0, scale: ks, label: 'Keep base' });
            defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: 0, y: 1 * ks, z: 0, ry: 0, scale: ks, label: 'Keep mid 1' });
            defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: 0, y: 2 * ks, z: 0, ry: 0, scale: ks, label: 'Keep mid 2' });
            defs.push({ path: 'assets/castle/tower-square-top-roof-high.glb', x: 0, y: 3 * ks, z: 0, ry: 0, scale: ks, label: 'Keep roof' });

            // â”€â”€ Walls between towers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Wall model is 1 unit wide. Towers at Â±5.
            // North wall (z = -5)
            for (let x = -4; x <= 4; x += 1) {
                defs.push({ path: 'assets/castle/wall.glb', x, y: 0, z: -5, ry: 0, scale: 1, label: 'North wall' });
            }
            // South wall (z = 5) â€” with doorway in center
            for (let x = -4; x <= 4; x += 1) {
                if (x === 0) {
                    defs.push({ path: 'assets/castle/wall-doorway.glb', x, y: 0, z: 5, ry: 0, scale: 1, label: 'Gate doorway' });
                } else {
                    defs.push({ path: 'assets/castle/wall.glb', x, y: 0, z: 5, ry: 0, scale: 1, label: 'South wall' });
                }
            }
            // East wall (x = 5)
            for (let z = -4; z <= 4; z += 1) {
                defs.push({ path: 'assets/castle/wall.glb', x: 5, y: 0, z, ry: Math.PI / 2, scale: 1, label: 'East wall' });
            }
            // West wall (x = -5)
            for (let z = -4; z <= 4; z += 1) {
                defs.push({ path: 'assets/castle/wall.glb', x: -5, y: 0, z, ry: Math.PI / 2, scale: 1, label: 'West wall' });
            }

            // â”€â”€ Gate & Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/castle/gate.glb', x: 0, y: 0, z: 5.5, ry: 0, scale: 1, label: 'Gate' });
            defs.push({ path: 'assets/castle/bridge-draw.glb', x: 0, y: 0, z: 7, ry: 0, scale: 1, label: 'Drawbridge' });

            // â”€â”€ Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/castle/flag-banner-long.glb', x: 0, y: 4 * 1.4, z: 0, ry: 0, scale: 1.4, label: 'Keep flag' });
            towerPositions.forEach((tp, i) => {
                defs.push({ path: i % 2 === 0 ? 'assets/castle/flag.glb' : 'assets/castle/flag-pennant.glb', x: tp.x, y: 3, z: tp.z, ry: 0, scale: 1, label: 'Tower flag' });
            });

            // â”€â”€ Trees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const treePlacements = [
                { path: 'assets/castle/tree-large.glb', x: -9, z: -8 },
                { path: 'assets/castle/tree-large.glb', x: -10, z: 2 },
                { path: 'assets/castle/tree-small.glb', x: -8, z: -3 },
                { path: 'assets/castle/tree-large.glb', x: 9, z: -7 },
                { path: 'assets/castle/tree-small.glb', x: 10, z: 4 },
                { path: 'assets/castle/tree-large.glb', x: 8, z: 9 },
                { path: 'assets/castle/tree-small.glb', x: -8, z: 9 },
                { path: 'assets/castle/tree-small.glb', x: 3, z: -9 },
            ];
            treePlacements.forEach(t => {
                defs.push({ path: t.path, x: t.x, y: 0, z: t.z, ry: Math.random() * Math.PI * 2, scale: 1.3, label: 'Tree' });
            });

            // â”€â”€ Rocks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const rockPlacements = [
                { path: 'assets/castle/rocks-large.glb', x: -7, z: 7 },
                { path: 'assets/castle/rocks-small.glb', x: 8, z: 8 },
                { path: 'assets/castle/rocks-large.glb', x: 9, z: -2 },
                { path: 'assets/castle/rocks-small.glb', x: -9, z: -6 },
                { path: 'assets/castle/rocks-small.glb', x: 3, z: 9 },
            ];
            rockPlacements.forEach(r => {
                defs.push({ path: r.path, x: r.x, y: 0, z: r.z, ry: Math.random() * Math.PI * 2, scale: 1, label: 'Rocks' });
            });

            // â”€â”€ Siege Equipment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/castle/siege-catapult.glb', x: -4, y: 0, z: 10, ry: Math.PI, scale: 1.2, label: 'Catapult' });
            defs.push({ path: 'assets/castle/siege-trebuchet.glb', x: 5, y: 0, z: 11, ry: Math.PI + 0.3, scale: 1.2, label: 'Trebuchet' });
            defs.push({ path: 'assets/castle/siege-ballista.glb', x: 0, y: 0, z: 12, ry: Math.PI, scale: 1.2, label: 'Ballista' });

            // â”€â”€ Logs & Trunks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/castle/tree-log.glb', x: -7, y: 0, z: 4, ry: 0.8, scale: 1, label: 'Log' });
            defs.push({ path: 'assets/castle/tree-trunk.glb', x: 7, y: 0, z: -5, ry: 1.2, scale: 1, label: 'Trunk' });
            defs.push({ path: 'assets/castle/tree-log.glb', x: 2, y: 0, z: 10, ry: -0.5, scale: 1, label: 'Log' });

            // â”€â”€ Stairs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/castle/stairs-stone.glb', x: 0, y: 0, z: 4.5, ry: 0, scale: 1, label: 'Stairs' });


            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ENRICHED SCENERY â€” Dense forest, village, graveyard
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // â”€â”€ Dense Forest Ring (30+ trees) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const forestTrees = [
                {x:-12,z:-14,s:1.5},{x:-8,z:-13,s:1.3},{x:-4,z:-15,s:1.6},
                {x:0,z:-14,s:1.4},{x:4,z:-13,s:1.5},{x:8,z:-15,s:1.3},
                {x:12,z:-14,s:1.6},{x:-14,z:-10,s:1.4},{x:14,z:-10,s:1.5},
                {x:-6,z:-11,s:1.2},{x:6,z:-12,s:1.4},
                {x:-14,z:-6,s:1.5},{x:-15,z:0,s:1.6},{x:-13,z:4,s:1.3},
                {x:-14,z:8,s:1.5},{x:-12,z:12,s:1.4},{x:-15,z:-2,s:1.2},
                {x:14,z:-4,s:1.4},{x:15,z:2,s:1.5},{x:13,z:6,s:1.3},
                {x:14,z:10,s:1.6},{x:12,z:14,s:1.4},
                {x:-12,z:14,s:1.4},{x:-8,z:16,s:1.5},{x:8,z:16,s:1.3},
                {x:12,z:15,s:1.6},{x:0,z:18,s:1.4},{x:-4,z:17,s:1.2},
                {x:-16,z:-12,s:1.8},{x:16,z:-12,s:1.7},
                {x:-16,z:6,s:1.6},{x:16,z:8,s:1.5},
            ];
            forestTrees.forEach((t, i) => {
                defs.push({
                    path: i % 3 !== 0 ? 'assets/castle/tree-large.glb' : 'assets/castle/tree-small.glb',
                    x: t.x, y: 0, z: t.z, ry: Math.random() * Math.PI * 2, scale: t.s, label: 'Forest tree'
                });
            });

            // â”€â”€ Village outside gate (z > 8) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/castle/wall.glb', x: -3, y: 0, z: 10, ry: 0, scale: 0.8, label: 'Tavern' });
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: -3, y: 0, z: 11, ry: 0, scale: 0.8, label: 'Tavern door' });
            defs.push({ path: 'assets/castle/wall.glb', x: -3, y: 0, z: 12, ry: 0, scale: 0.8, label: 'Tavern' });
            defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: -3, y: 0.8, z: 11, ry: 0, scale: 0.8, label: 'Tavern roof' });
            defs.push({ path: 'assets/castle/wall.glb', x: 3, y: 0, z: 10, ry: 0, scale: 0.8, label: 'Smithy' });
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: 3, y: 0, z: 11, ry: 0, scale: 0.8, label: 'Smithy door' });
            defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: 3, y: 0.8, z: 11, ry: Math.PI, scale: 0.8, label: 'Smithy roof' });
            defs.push({ path: 'assets/castle/wall-half.glb', x: 5, y: 0, z: 9, ry: Math.PI/2, scale: 0.7, label: 'Market' });
            defs.push({ path: 'assets/castle/wall-half.glb', x: 5, y: 0, z: 10, ry: Math.PI/2, scale: 0.7, label: 'Market' });
            defs.push({ path: 'assets/castle/tower-square-base.glb', x: -6, y: 0, z: 13, ry: 0, scale: 0.7, label: 'Chapel' });
            defs.push({ path: 'assets/castle/tower-square-top-roof-high.glb', x: -6, y: 0.7, z: 13, ry: 0, scale: 0.7, label: 'Chapel spire' });

            // Village fences
            [{x:-5,z:9},{x:-6,z:9},{x:-7,z:9},{x:5,z:12},{x:6,z:12},{x:7,z:12}].forEach(f => {
                defs.push({ path: 'assets/castle/wall-narrow-wood-fence.glb', x: f.x, y: 0, z: f.z, ry: 0, scale: 0.8, label: 'Fence' });
            });

            // Hay bales + benches
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: -5, y: 0, z: 11, ry: 0.5, scale: 1, label: 'Hay' });
            defs.push({ path: 'assets/graveyard/hay-bale-bundled.glb', x: 6, y: 0, z: 10, ry: 1.2, scale: 1, label: 'Hay' });
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: 4, y: 0, z: 13, ry: 2.1, scale: 1, label: 'Hay' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: -1, y: 0, z: 12, ry: Math.PI/2, scale: 1, label: 'Bench' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: 1, y: 0, z: 12, ry: -Math.PI/2, scale: 1, label: 'Bench' });

            // â”€â”€ Graveyard (northwest) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            [{x:-8,z:-6},{x:-9,z:-6},{x:-10,z:-6},{x:-11,z:-6},{x:-12,z:-6},{x:-12,z:-7},{x:-12,z:-8},{x:-12,z:-9}].forEach(f => {
                defs.push({ path: 'assets/graveyard/iron-fence.glb', x: f.x, y: 0, z: f.z, ry: f.z===-6 ? 0 : Math.PI/2, scale: 1, label: 'Grave fence' });
            });
            defs.push({ path: 'assets/graveyard/iron-fence-border-gate.glb', x: -8, y: 0, z: -7, ry: Math.PI/2, scale: 1, label: 'Grave gate' });
            defs.push({ path: 'assets/graveyard/gravestone-cross.glb', x: -9, y: 0, z: -7, ry: 0, scale: 1, label: 'Gravestone' });
            defs.push({ path: 'assets/graveyard/gravestone-round.glb', x: -10, y: 0, z: -7.5, ry: 0.2, scale: 1, label: 'Gravestone' });
            defs.push({ path: 'assets/graveyard/gravestone-wide.glb', x: -11, y: 0, z: -7, ry: -0.1, scale: 1, label: 'Gravestone' });
            defs.push({ path: 'assets/graveyard/gravestone-decorative.glb', x: -9.5, y: 0, z: -8.5, ry: 0, scale: 1, label: 'Gravestone' });
            defs.push({ path: 'assets/graveyard/gravestone-broken.glb', x: -10.5, y: 0, z: -9, ry: 0.3, scale: 1, label: 'Gravestone' });
            defs.push({ path: 'assets/graveyard/cross-wood.glb', x: -11, y: 0, z: -8.5, ry: 0, scale: 1, label: 'Cross' });
            defs.push({ path: 'assets/graveyard/crypt-large.glb', x: -10.5, y: 0, z: -10.5, ry: 0, scale: 1, label: 'Crypt' });
            defs.push({ path: 'assets/graveyard/crypt-large-roof.glb', x: -10.5, y: 1, z: -10.5, ry: 0, scale: 1, label: 'Crypt roof' });
            defs.push({ path: 'assets/graveyard/pine.glb', x: -12, y: 0, z: -10, ry: 0, scale: 1.2, label: 'Pine' });
            defs.push({ path: 'assets/graveyard/pine-crooked.glb', x: -9, y: 0, z: -11, ry: 1.5, scale: 1.1, label: 'Pine' });
            defs.push({ path: 'assets/graveyard/candle-multiple.glb', x: -10.8, y: 0, z: -8, ry: 0, scale: 1, label: 'Candles' });
            defs.push({ path: 'assets/graveyard/lantern-candle.glb', x: -8.5, y: 0, z: -6.5, ry: 0, scale: 1, label: 'Lantern' });
            defs.push({ path: 'assets/graveyard/pumpkin-carved.glb', x: -10, y: 0, z: -6.5, ry: 0, scale: 1, label: 'Pumpkin' });

            // â”€â”€ Lightposts along paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/graveyard/lightpost-single.glb', x: -1.5, y: 0, z: 8, ry: 0, scale: 1, label: 'Lightpost' });
            defs.push({ path: 'assets/graveyard/lightpost-single.glb', x: 1.5, y: 0, z: 8, ry: 0, scale: 1, label: 'Lightpost' });
            defs.push({ path: 'assets/graveyard/lightpost-double.glb', x: 0, y: 0, z: 14, ry: 0, scale: 1, label: 'Lightpost' });

            // â”€â”€ Extra rocks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            [{x:-11,z:3,s:1.2},{x:11,z:-3,s:1.1},{x:7,z:13,s:1.3},{x:-10,z:10,s:1},{x:13,z:4,s:1.2},{x:10,z:12,s:1.1}].forEach(r => {
                defs.push({ path: Math.random()>0.5 ? 'assets/castle/rocks-large.glb' : 'assets/castle/rocks-small.glb', x: r.x, y: 0, z: r.z, ry: Math.random()*Math.PI*2, scale: r.s, label: 'Rocks' });
            });

            // â”€â”€ Fire baskets at village entrance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: -3, y: 0, z: 8.5, ry: 0, scale: 1, label: 'Fire basket' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: 3, y: 0, z: 8.5, ry: 0, scale: 1, label: 'Fire basket' });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RIVER BRIDGES â€” 3 crossings
            // River flows NWâ†’E through: (-10,-10), (0,7), (15,2)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Bridge 1 â€” Main drawbridge near castle gate (river at xâ‰ˆ0, zâ‰ˆ7)
            // River direction angle at that point â‰ˆ atan2(9-7, 4-0) â‰ˆ atan2(2,4) â‰ˆ 0.46 rad
            // Bridge perpendicular: ry = 0.46 + PI/2
            defs.push({ path: 'assets/castle/bridge-draw.glb', x: 0, y: 0, z: 7.5, ry: Math.PI / 2 + 0.46, scale: 1.2, label: 'River main bridge' });

            // Bridge 2 â€” Stone bridge through forest area (river at xâ‰ˆ-10, zâ‰ˆ-10)
            // River direction angle â‰ˆ atan2(-4-(-10), -6-(-10)) = atan2(6,4) â‰ˆ 0.98 rad
            // Bridge perpendicular: ry = 0.98 + PI/2
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: -10, y: 0, z: -10, ry: Math.PI / 2 + 0.98, scale: 1.2, label: 'River forest bridge' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: -10, y: 0, z: -10, ry: Math.PI / 2 + 0.98, scale: 1.2, label: 'River forest bridge pillar' });

            // Bridge 3 â€” Small bridge near training grounds (river at xâ‰ˆ15, zâ‰ˆ2)
            // River direction angle â‰ˆ atan2(4-5, 18-12) = atan2(-1,6) â‰ˆ -0.165 rad
            // Bridge perpendicular: ry = -0.165 + PI/2
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: 15, y: 0, z: 2, ry: Math.PI / 2 - 0.165, scale: 1.2, label: 'River training bridge' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: 15, y: 0, z: 2, ry: Math.PI / 2 - 0.165, scale: 1.2, label: 'River training bridge pillar' });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RIVERBANKS â€” rocks & trees scattered naturally
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Rocks along the river â€” both banks, scattered
            const riverBankRocks = [
                // NW stretch
                { path: 'assets/castle/rocks-small.glb', x: -19, z: -24, ry: 0.3 },
                { path: 'assets/castle/rocks-large.glb', x: -18, z: -22, ry: 1.1 },
                { path: 'assets/castle/rocks-small.glb', x: -16, z: -21, ry: 2.4 },
                { path: 'assets/castle/rocks-small.glb', x: -13, z: -17, ry: 0.7 },
                { path: 'assets/castle/rocks-large.glb', x: -12, z: -16, ry: 1.9 },
                // Middle stretch
                { path: 'assets/castle/rocks-small.glb', x: -7, z:  -3, ry: 0.5 },
                { path: 'assets/castle/rocks-large.glb', x: -5, z:  -5, ry: 2.1 },
                { path: 'assets/castle/rocks-small.glb', x:  5, z:   9, ry: 1.3 },
                { path: 'assets/castle/rocks-large.glb', x:  6, z:  10, ry: 0.8 },
                // East stretch
                { path: 'assets/castle/rocks-small.glb', x: 19, z:   6, ry: 1.7 },
                { path: 'assets/castle/rocks-large.glb', x: 22, z:   4, ry: 0.4 },
                { path: 'assets/castle/rocks-small.glb', x: 25, z:   6, ry: 2.9 },
                { path: 'assets/castle/rocks-small.glb', x: 28, z:   4, ry: 1.0 },
                { path: 'assets/castle/rocks-large.glb', x: 16, z:   3, ry: 0.6 },
                { path: 'assets/castle/rocks-small.glb', x: 13, z:   7, ry: 1.8 },
                { path: 'assets/castle/rocks-small.glb', x: -8, z:  -8, ry: 2.2 },
                { path: 'assets/castle/rocks-large.glb', x: -9, z: -12, ry: 0.9 },
            ];
            riverBankRocks.forEach(r => {
                defs.push({ path: r.path, x: r.x, y: 0, z: r.z, ry: r.ry, scale: 0.9 + Math.random() * 0.3, label: 'River rock' });
            });

            // Trees leaning toward the water along the banks
            const riverBankTrees = [
                { x: -17, z: -23, s: 1.2 },
                { x: -15, z: -19, s: 1.4 },
                { x: -11, z: -12, s: 1.3 },
                { x:  -9, z:  -6, s: 1.1 },
                { x:   3, z:   8, s: 1.3 },
                { x:   7, z:  11, s: 1.2 },
                { x:  17, z:   6, s: 1.1 },
                { x:  23, z:   6, s: 1.4 },
            ];
            riverBankTrees.forEach((t, i) => {
                defs.push({
                    path: i % 3 === 0 ? 'assets/castle/tree-large.glb' : 'assets/castle/tree-small.glb',
                    x: t.x, y: 0, z: t.z,
                    ry: Math.PI * 0.15 + (i * 0.7),   // slight lean toward water
                    scale: t.s, label: 'Riverbank tree'
                });
            });

            return defs;
        }

        placeModel(gltf, def) {
            const model = gltf.scene;
            model.position.set(def.x, def.y, def.z);
            model.rotation.y = def.ry || 0;
            if (def.scale && def.scale !== 1) {
                model.scale.setScalar(def.scale);
            }

            // Enable shadows + apply fallback colors if textures didn't load
            const castleColors = {
                'wall': 0xa89a85, 'tower': 0x9a8c78, 'gate': 0x8b7d6a,
                'door': 0x7a5c3a, 'bridge': 0x8b6f4e, 'stairs': 0x9a8c78,
                'flag': 0xcc3333, 'tree': 0x4a8a2e, 'rock': 0x7a7570,
                'siege': 0x8b6f4e, 'log': 0x6b5030, 'trunk': 0x5a4020,
            };
            const pathKey = (def.path || '').split('/').pop().replace('.glb', '');
            const colorKey = Object.keys(castleColors).find(k => pathKey.includes(k));
            const fallbackColor = castleColors[colorKey] || 0xa89a85;

            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // If material has no map (texture didn't load), apply fallback color
                    if (child.material && !child.material.map) {
                        child.material = new THREE.MeshStandardMaterial({
                            color: fallbackColor,
                            roughness: 0.85,
                            metalness: 0.05,
                        });
                    }
                }
            });

            this.scene.add(model);
            return model;
        }

        async loadCharacters(updateProgress) {
            const agentDefs = [
                { id: 'ApoMac',   char: 'a', speed: 0.4 },
                { id: 'Forge',    char: 'b', speed: 0.7 },
                { id: 'Atlas',    char: 'c', speed: 0.6 },
                { id: 'Hunter',   char: 'd', speed: 1.0 },
                { id: 'Echo',     char: 'e', speed: 0.5 },
                { id: 'Sentinel', char: 'f', speed: 0.8 },
                { id: 'Mystic',   char: 'g', speed: 0.55 },
                { id: 'Smith',    char: 'h', speed: 0.65 },
            ];

            // Define patrol waypoints for each character (inside castle courtyard + around gate)
            // Courtyard bounds: x: -4 to 4, z: -4 to 4 (walls at Â±5)
            const waypoints = [
                // ApoMac â€” King, slow stately patrol through center
                [{ x: 0, z: 0 }, { x: 1.5, z: 1.5 }, { x: -1, z: 2 }, { x: -1.5, z: -1 }, { x: 1, z: -1.5 }],
                // Forge â€” Builder, moves between inner corners
                [{ x: -3, z: -3 }, { x: -3, z: 3 }, { x: 3, z: 3 }, { x: 3, z: -3 }],
                // Atlas â€” Navigator, scouts inner wall perimeter
                [{ x: -4, z: 0 }, { x: 0, z: -4 }, { x: 4, z: 0 }, { x: 0, z: 3.5 }],
                // Hunter â€” Scout, fast, exits through gate then returns
                [{ x: 0, z: 3.5 }, { x: 0, z: 4.5 }, { x: 0, z: 6 }, { x: 3, z: 10 }, { x: -2, z: 9 }, { x: 0, z: 6 }, { x: 0, z: 4.5 }, { x: 0, z: 3.5 }],
                // Echo â€” Bard, wanders courtyard safely
                [{ x: -2, z: 1 }, { x: 1, z: 3 }, { x: 2, z: 0 }, { x: 1, z: -2 }, { x: -1, z: -1 }],
                // Sentinel â€” Guard, patrols INSIDE the gate area (not on wall)
                [{ x: -2, z: 3.5 }, { x: 2, z: 3.5 }, { x: 2, z: 2 }, { x: -2, z: 2 }],
                // Mystic â€” Wizard, slow circle around keep
                [{ x: -2, z: -2 }, { x: 2, z: -2 }, { x: 2, z: 2 }, { x: -2, z: 2 }],
                // Smith â€” Blacksmith, near forge area
                [{ x: 3, z: -1 }, { x: 4, z: -3 }, { x: 3, z: -4 }, { x: 2, z: -2 }],
            ];

            for (let i = 0; i < agentDefs.length; i++) {
                const def = agentDefs[i];
                try {
                    const gltf = await this.loadModel(`assets/characters/character-${def.char}.glb`);
                    const model = gltf.scene;
                    model.scale.setScalar(0.25);

                    const wp = waypoints[i];
                    model.position.set(wp[0].x, 0, wp[0].z);

                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.userData.agentId = def.id;
                        }
                    });

                    // Create a group for the character (so we can add glow, etc.)
                    const group = new THREE.Group();
                    group.add(model);
                    group.position.copy(model.position);
                    model.position.set(0, 0, 0);
                    group.userData.agentId = def.id;
                    this.scene.add(group);

                    // Setup animation mixer for walk animation
                    let mixer = null;
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(model);
                        this.animationMixers.push(mixer);
                        // Find walk animation, fallback to idle
                        const walkClip = gltf.animations.find(a => a.name === 'walk') 
                            || gltf.animations.find(a => a.name === 'idle');
                        if (walkClip) {
                            const action = mixer.clipAction(walkClip);
                            action.play();
                            action.timeScale = 0.6 + def.speed * 0.8;
                        }
                    }

                    this.characterModels.set(def.id, {
                        group,
                        model,
                        mixer,
                        animations: gltf.animations || [],
                        waypoints: wp,
                        waypointIndex: 0,
                        nextWaypointIndex: 1,
                        speed: def.speed,
                        progress: 0,
                        pauseTimer: 0,
                        bobPhase: Math.random() * Math.PI * 2,
                        glowMesh: null,
                    });

                    // Create HTML label
                    const label = document.createElement('div');
                    label.className = 'character-label';
                    label.textContent = def.id;
                    document.getElementById('labels-container').appendChild(label);
                    this.labelElements.set(def.id, label);

                    updateProgress(`Character ${def.id}`);
                } catch (e) {
                    console.warn(`Failed to load character ${def.char}:`, e);
                    updateProgress(`(skipped) character-${def.char}`);
                }
            }
        }

        // â”€â”€ Animation Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        animate() {
            requestAnimationFrame(() => this.animate());

            const delta = this.clock.getDelta();
            const elapsed = this.clock.getElapsedTime();

            // Update controls
            this.controls.update();

            // Update animation mixers
            this.animationMixers.forEach(mixer => mixer.update(delta));

            // Animate characters
            this.animateCharacters(delta, elapsed);

            // Animate torch flicker
            this.animateTorches(elapsed);

            // Animate campfire
            this.animateCampfire(elapsed);

            // Update label positions
            this.updateLabels();

            // Render
            this.renderer.render(this.scene, this.camera);
        }

        animateCharacters(delta, elapsed) {
            this.characterModels.forEach((charData, agentId) => {
                const { group, waypoints, speed } = charData;

                // Handle waypoint pause
                if (charData.pauseTimer > 0) {
                    charData.pauseTimer -= delta;
                    return; // Wait at waypoint
                }

                // Move along waypoints
                const from = waypoints[charData.waypointIndex];
                const to = waypoints[charData.nextWaypointIndex];

                charData.progress += delta * speed * 0.3;

                if (charData.progress >= 1) {
                    // Snap exactly to target waypoint before resetting (prevents teleport frame-skip)
                    group.position.set(to.x, 0, to.z);
                    charData.progress = 0;
                    charData.waypointIndex = charData.nextWaypointIndex;
                    charData.nextWaypointIndex = (charData.nextWaypointIndex + 1) % waypoints.length;
                    // Small pause at each waypoint (0.3â€“0.5s)
                    charData.pauseTimer = 0.3 + Math.random() * 0.2;
                    return;
                }

                // Lerp position
                const t = this.smoothstep(charData.progress);
                const x = from.x + (to.x - from.x) * t;
                const z = from.z + (to.z - from.z) * t;

                group.position.set(x, 0, z);

                // Face direction of movement
                const dx = to.x - from.x;
                const dz = to.z - from.z;
                if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
                    const targetAngle = Math.atan2(dx, dz);
                    // Smooth rotation
                    let currentAngle = group.rotation.y;
                    let diff = targetAngle - currentAngle;
                    // Normalize
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    group.rotation.y += diff * Math.min(delta * 5, 1);
                }

                // Selected glow effect
                if (agentId === this.selectedAgent) {
                    if (!charData.glowMesh) {
                        this.addGlowToCharacter(charData);
                    }
                    if (charData.glowMesh) {
                        charData.glowMesh.material.opacity = 0.3 + Math.sin(elapsed * 4) * 0.15;
                    }
                } else if (charData.glowMesh) {
                    group.remove(charData.glowMesh);
                    charData.glowMesh.geometry.dispose();
                    charData.glowMesh.material.dispose();
                    charData.glowMesh = null;
                }
            });
        }

        smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        addGlowToCharacter(charData) {
            const glowGeo = new THREE.CylinderGeometry(0.6, 0.6, 2, 16, 1, true);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xe94560,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            glowMesh.position.y = 1;
            charData.group.add(glowMesh);
            charData.glowMesh = glowMesh;
        }

        animateTorches(elapsed) {
            if (!this.torchLights) return;
            this.torchLights.forEach((light, i) => {
                const flicker = 1 + Math.sin(elapsed * 8 + i * 2.5) * 0.15 + Math.sin(elapsed * 13 + i) * 0.1;
                light.intensity = (i < 2 ? 2 : 1.5) * flicker;
            });
        }

        updateLabels() {
            const container = document.getElementById('scene-container');
            const rect = container.getBoundingClientRect();

            this.characterModels.forEach((charData, agentId) => {
                const label = this.labelElements.get(agentId);
                if (!label) return;

                // Project 3D position to screen
                const pos = new THREE.Vector3();
                charData.group.getWorldPosition(pos);
                pos.y += 0.8; // Above character head (0.25x scale)

                const projected = pos.clone().project(this.camera);
                const x = (projected.x * 0.5 + 0.5) * rect.width;
                const y = (-projected.y * 0.5 + 0.5) * rect.height;

                label.style.left = x + 'px';
                label.style.top = y + 'px';

                // Show label if hovered or selected
                if (agentId === this.hoveredAgent) {
                    label.classList.add('visible');
                    label.classList.toggle('selected', agentId === this.selectedAgent);
                } else if (agentId === this.selectedAgent) {
                    label.classList.add('visible');
                    label.classList.add('selected');
                } else {
                    label.classList.remove('visible');
                    label.classList.remove('selected');
                }
            });
        }

        // â”€â”€ Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupEventListeners() {
            const container = document.getElementById('scene-container');

            // Click to select
            container.addEventListener('click', (e) => this.onSceneClick(e));

            // Hover
            container.addEventListener('mousemove', (e) => this.onSceneHover(e));

            // UI buttons
            document.getElementById('btn-toggle-sound').addEventListener('click', () => {
                this.soundEnabled = !this.soundEnabled;
                document.getElementById('btn-toggle-sound').textContent = this.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            });
            document.getElementById('btn-fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });
            document.getElementById('btn-reset-camera').addEventListener('click', () => {
                this.resetCamera();
            });
        }

        getMouseNDC(event) {
            const container = document.getElementById('scene-container');
            const rect = container.getBoundingClientRect();
            return new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
        }

        onSceneClick(event) {
            this.mouse = this.getMouseNDC(event);
            this.raycaster.setFromCamera(this.mouse, this.camera);

            // Collect all character meshes
            const charMeshes = [];
            this.characterModels.forEach((charData) => {
                charData.group.traverse((child) => {
                    if (child.isMesh) charMeshes.push(child);
                });
            });

            const intersects = this.raycaster.intersectObjects(charMeshes, false);
            if (intersects.length > 0) {
                // Find the agent ID
                let obj = intersects[0].object;
                while (obj && !obj.userData.agentId) obj = obj.parent;
                if (obj && obj.userData.agentId) {
                    this.selectAgent(obj.userData.agentId);
                    return;
                }
            }
        }

        onSceneHover(event) {
            this.mouse = this.getMouseNDC(event);
            this.raycaster.setFromCamera(this.mouse, this.camera);

            const charMeshes = [];
            this.characterModels.forEach((charData) => {
                charData.group.traverse((child) => {
                    if (child.isMesh) charMeshes.push(child);
                });
            });

            const intersects = this.raycaster.intersectObjects(charMeshes, false);
            let newHovered = null;
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj && !obj.userData.agentId) obj = obj.parent;
                if (obj) newHovered = obj.userData.agentId;
            }

            if (newHovered !== this.hoveredAgent) {
                this.hoveredAgent = newHovered;
                document.getElementById('scene-container').style.cursor = newHovered ? 'pointer' : '';
            }
        }

        resetCamera() {
            // Smooth reset to default isometric view
            const dist = 40;
            const azimuth = Math.PI / 4;
            const elevation = Math.atan(Math.sin(Math.PI / 4.2));

            this.camera.position.set(
                dist * Math.cos(elevation) * Math.sin(azimuth),
                dist * Math.sin(elevation),
                dist * Math.cos(elevation) * Math.cos(azimuth)
            );
            this.camera.zoom = 1;
            this.camera.updateProjectionMatrix();
            this.controls.target.set(0, 2, 0);
            this.controls.update();
        }

        // â”€â”€ Agent Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupAgents() {
            const defs = [
                { id: 'ApoMac',   role: 'CEO / King',     char: 'a', color: '#c9a959' },
                { id: 'Forge',    role: 'Builder',         char: 'b', color: '#f97316' },
                { id: 'Atlas',    role: 'Navigator',       char: 'c', color: '#3b82f6' },
                { id: 'Hunter',   role: 'Scout',           char: 'd', color: '#10b981' },
                { id: 'Echo',     role: 'Bard',            char: 'e', color: '#8b5cf6' },
                { id: 'Sentinel', role: 'Guard',           char: 'f', color: '#ef4444' },
                { id: 'Mystic',   role: 'Wizard',          char: 'g', color: '#7c3aed' },
                { id: 'Smith',    role: 'Blacksmith',      char: 'h', color: '#ea580c' },
            ];

            defs.forEach(d => {
                const status = Math.random() > 0.6 ? 'active' : Math.random() > 0.4 ? 'busy' : 'idle';
                const metrics = {
                    tasks: 1 + Math.floor(Math.random() * 15),
                    completed: Math.floor(Math.random() * 10),
                    success: Math.floor(50 + Math.random() * 50) + '%',
                    uptime: (90 + Math.random() * 10).toFixed(1) + 'h'
                };
                this.agents.set(d.id, { ...d, status, metrics });
            });
        }

        selectAgent(agentId) {
            // Deselect previous
            if (this.selectedAgent) {
                document.querySelector(`.courtyard-avatar[data-agent-id="${this.selectedAgent}"]`)?.classList.remove('selected');
                document.querySelector(`[data-agent="${this.selectedAgent}"]`)?.classList.remove('selected');
            }
            this.selectedAgent = agentId;

            // Highlight sidebar card
            const card = document.querySelector(`[data-agent="${agentId}"]`);
            if (card) {
                card.classList.add('selected');
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            this.playSound('select');
            this.addActivityLog(`Selected ${agentId}`, 'system');
        }

        // â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupAudio() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const tone = (dur, freq, decay, vol) => {
                    const sr = this.audioContext.sampleRate;
                    const buf = this.audioContext.createBuffer(1, dur * sr, sr);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = Math.sin(2 * Math.PI * freq * (i / sr)) * Math.exp(-(i / sr) * decay) * vol;
                    return buf;
                };
                this.sounds.set('select', tone(0.15, 600, 10, 0.2));
                this.sounds.set('horn', (() => {
                    const sr = this.audioContext.sampleRate;
                    const buf = this.audioContext.createBuffer(1, 1.2 * sr, sr);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) { const t = i / sr; d[i] = Math.sin(2 * Math.PI * 220 * t) * Math.sin(Math.PI * t / 1.2) * 0.3; }
                    return buf;
                })());
            } catch (e) { this.soundEnabled = false; }
        }

        playSound(name) {
            if (!this.soundEnabled || !this.audioContext || !this.sounds.has(name)) return;
            try {
                const s = this.audioContext.createBufferSource();
                s.buffer = this.sounds.get(name);
                s.connect(this.audioContext.destination);
                s.start();
            } catch (e) {}
        }

        // â”€â”€ Data Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupDataBridge() {
            if (typeof SpawnKit === 'undefined') { setTimeout(() => this.setupDataBridge(), 100); return; }
            if (SpawnKit.mode === 'demo') document.getElementById('demo-badge').style.display = 'block';
            SpawnKit.on('update', data => this.updateDashboard(data));
            if (SpawnKit.data) this.updateDashboard(SpawnKit.data);
        }

        updateDashboard(data) {
            this.updateAgentRoster(data.agents || []);
            const m = data.metrics || {};
            document.getElementById('stat-missions').textContent = m.missions || '12';
            document.getElementById('stat-completed').textContent = m.completed || '8';
            document.getElementById('stat-resources').textContent = m.resources || '2.4k';
            document.getElementById('stat-uptime').textContent = m.uptime || '99.8%';
            if (data.events) data.events.slice(-10).forEach(ev => this.addActivityLog(ev.message, ev.agent || 'system', ev.timestamp));
        }

        updateAgentRoster(agents) {
            const c = document.getElementById('agents-list');
            if (!agents.length) agents = Array.from(this.agents.entries()).map(([id, a]) => ({ id, name: id, role: a.role, status: a.status, metrics: a.metrics }));
            c.innerHTML = agents.map(a => {
                const d = this.agents.get(a.id);
                const st = a.status || 'idle';
                const emoji = { active: 'âš”ï¸', busy: 'ğŸ”¥', idle: 'ğŸ’¤', error: 'âš ï¸' }[st] || 'ğŸ’¤';
                return `<div class="agent-card${a.id === this.selectedAgent ? ' selected' : ''}" data-agent="${a.id}" onclick="window.castleApp.selectAgent('${a.id}')">
                    <div class="agent-header">
                        <div class="agent-avatar" style="background:${d?.color || '#555'}">
                            ${d ? `<img src="assets/characters/character-${d.char}.png">` : a.name.slice(0, 2)}
                        </div>
                        <div><div class="agent-name">${a.name}</div><div class="agent-role">${a.role || 'Knight'}</div></div>
                        <div class="agent-status"><div class="status-dot ${st}"></div><span>${emoji}</span></div>
                    </div>
                    <div class="agent-metrics">
                        <div class="metric-item"><span class="metric-label">Tasks</span><span class="metric-value">${a.metrics?.tasks || '-'}</span></div>
                        <div class="metric-item"><span class="metric-label">Done</span><span class="metric-value">${a.metrics?.completed || '-'}</span></div>
                        <div class="metric-item"><span class="metric-label">Win</span><span class="metric-value">${a.metrics?.success || '-'}</span></div>
                        <div class="metric-item"><span class="metric-label">Up</span><span class="metric-value">${a.metrics?.uptime || '-'}</span></div>
                    </div>
                </div>`;
            }).join('');
        }

        addActivityLog(msg, agent = 'system', ts = null) {
            const c = document.getElementById('activity-log');
            const time = ts ? new Date(ts) : new Date();
            const item = document.createElement('div');
            item.className = 'activity-item';
            item.innerHTML = `<div class="activity-time">${time.toLocaleTimeString()}</div><div class="activity-message">${agent !== 'system' ? `<span class="activity-agent">${agent}</span>: ` : ''}${msg}</div>`;
            c.insertBefore(item, c.firstChild);
            while (c.children.length > 20) c.removeChild(c.lastChild);
        }

        setupUI() {
            const msgs = [
                'Castle defenses initialized',
                'ApoMac completed strategic session',
                'Forge built new siege weapons',
                'Hunter scouted northern territories',
                'Echo composed victory ballad',
                'Sentinel: all towers secure',
                'Mystic enchanted castle walls',
                'Smith forged royal armor'
            ];
            msgs.forEach((m, i) => setTimeout(() => this.addActivityLog(m), i * 400));
            this.updateAgentRoster([]);
        }
    }

    // Initialize
    window.addEventListener('load', () => {
        const app = new MedievalCastle3D();
        window._app = app;
        window.castleApp = app;
    });
    </script>
</body>
</html>
