<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpawnKit â€” Medieval Castle 3D</title>
    <script>window.OC_RELAY_URL = window.OC_RELAY_URL || 'https://fleet.spawnkit.ai';</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel:wght@400;500;600;700&family=Crimson+Text:wght@400;600&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SpawnKit Medieval Castle v4.0 â€” Three.js 3D Diorama
           Real Kenney .glb models, isometric camera, animated characters
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        :root {
            --castle-dark-navy: #1a1a2e;
            --castle-navy: #16213e;
            --castle-blue: #0f3460;
            --castle-red: #e94560;
            --castle-gold: #c9a959;
            --castle-brown: #8b7355;
            --castle-parchment: #f4e4bc;
            --castle-stone-light: #a8a299;
            --castle-stone-dark: #5c5750;
            --castle-black: #0d0d0d;
            --castle-silver: #c0c0c0;
            --bg-primary: var(--castle-dark-navy);
            --bg-secondary: var(--castle-navy);
            --bg-tertiary: var(--castle-blue);
            --bg-parchment: var(--castle-parchment);
            --bg-scroll: linear-gradient(145deg, #f4e4bc 0%, #e8d5a3 100%);
            --text-primary: var(--castle-parchment);
            --text-secondary: var(--castle-stone-light);
            --text-accent: var(--castle-gold);
            --text-dark: var(--castle-navy);
            --text-red: var(--castle-red);
            --border-stone: rgba(168, 162, 153, 0.3);
            --border-gold: rgba(201, 169, 89, 0.5);
            --status-active: #4ade80;
            --status-busy: #fbbf24;
            --status-idle: #64748b;
            --status-error: var(--castle-red);
            --font-medieval: 'MedievalSharp', fantasy;
            --font-serif: 'Cinzel', serif;
            --font-body: 'Crimson Text', serif;
            --font-mono: 'Courier New', monospace;
            --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px;
            --space-5: 20px; --space-6: 24px; --space-8: 32px;
            --radius-sm: 4px; --radius-md: 8px; --radius-lg: 12px;
            --shadow-deep: 0 8px 32px rgba(0,0,0,0.6);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--castle-dark-navy);
            color: var(--text-primary);
            font-family: var(--font-body);
            overflow: hidden;
            height: 100vh;
        }

        /* â”€â”€ Main Grid Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-layout {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            grid-template-rows: 70px 1fr;
            grid-template-areas:
                "header header header"
                "sidebar main rightpanel";
            height: 100vh;
        }

        /* â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-header {
            grid-area: header;
            background: linear-gradient(135deg, #0d0d1a 0%, var(--castle-navy) 50%, #0d0d1a 100%);
            border-bottom: 2px solid var(--border-gold);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 var(--space-6);
            z-index: 10;
        }
        .castle-banner { display: flex; align-items: center; gap: var(--space-4); }
        .castle-crest { font-size: 32px; filter: drop-shadow(0 0 8px rgba(201,169,89,0.6)); }
        .castle-name { font-family: var(--font-medieval); font-size: 22px; color: var(--castle-gold); letter-spacing: 2px; }
        .castle-subtitle { font-family: var(--font-serif); font-size: 11px; color: var(--castle-stone-light); text-transform: uppercase; letter-spacing: 3px; }
        .castle-status-bar { display: flex; gap: var(--space-6); align-items: center; }
        .status-indicator { display: flex; align-items: center; gap: var(--space-2); font-size: 13px; font-family: var(--font-serif); }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; }
        .status-dot.active { background: var(--status-active); box-shadow: 0 0 6px var(--status-active); }
        .status-dot.busy { background: var(--status-busy); box-shadow: 0 0 6px var(--status-busy); }

        /* â”€â”€ Left Sidebar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-sidebar {
            grid-area: sidebar;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-stone);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .sidebar-header {
            padding: var(--space-5) var(--space-4);
            border-bottom: 1px solid var(--border-stone);
            background: linear-gradient(135deg, var(--castle-stone-dark), var(--castle-navy));
        }
        .sidebar-title { font-family: var(--font-medieval); font-size: 18px; color: var(--castle-gold); text-align: center; }
        .agents-scroll { flex: 1; overflow-y: auto; padding: var(--space-3); }

        .agent-card {
            background: linear-gradient(135deg, rgba(22,33,62,0.9), rgba(15,52,96,0.4));
            border: 1px solid var(--border-stone);
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .agent-card:hover { border-color: var(--castle-gold); transform: translateX(3px); box-shadow: 0 2px 8px rgba(201,169,89,0.15); }
        .agent-card.selected { border-color: var(--castle-red); box-shadow: 0 0 12px rgba(233,69,96,0.3); background: linear-gradient(135deg, rgba(233,69,96,0.1), rgba(15,52,96,0.4)); }
        .agent-header { display: flex; align-items: center; gap: var(--space-3); }
        .agent-avatar {
            width: 40px; height: 40px; border-radius: var(--radius-md);
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; background: var(--castle-stone-dark);
        }
        .agent-avatar img { width: 100%; height: 100%; object-fit: cover; image-rendering: pixelated; }
        .agent-name { font-family: var(--font-serif); font-size: 14px; color: var(--text-primary); font-weight: 600; }
        .agent-role { font-size: 11px; color: var(--text-secondary); font-style: italic; }
        .agent-status { margin-left: auto; display: flex; align-items: center; gap: 4px; }
        .agent-metrics { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-2); margin-top: var(--space-2); padding-top: var(--space-2); border-top: 1px solid rgba(168,162,153,0.15); }
        .metric-item { text-align: center; }
        .metric-label { font-size: 9px; color: var(--text-secondary); text-transform: uppercase; display: block; }
        .metric-value { font-family: var(--font-serif); font-size: 13px; color: var(--castle-gold); font-weight: 600; }

        /* â”€â”€ Main Scene (Three.js Canvas) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-main {
            grid-area: main;
            position: relative;
            overflow: hidden;
            background: #0a0a1a;
        }
        .castle-main canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        /* â”€â”€ Scene Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .scene-controls {
            position: absolute;
            top: var(--space-3); left: var(--space-3);
            z-index: 30;
            display: flex; gap: var(--space-2);
        }
        .control-btn {
            width: 32px; height: 32px;
            border: 1px solid var(--border-gold);
            border-radius: var(--radius-sm);
            background: rgba(201,169,89,0.9);
            color: var(--castle-navy);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 14px;
            transition: all 0.2s;
        }
        .control-btn:hover { background: var(--castle-parchment); transform: translateY(-1px); }

        /* â”€â”€ Character Name Labels (HTML overlay) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .character-label {
            position: absolute;
            pointer-events: none;
            font-family: var(--font-serif);
            font-size: 11px;
            color: var(--castle-gold);
            text-shadow: 0 0 6px rgba(0,0,0,0.95), 0 1px 3px black, 0 0 12px rgba(0,0,0,0.8);
            white-space: nowrap;
            transform: translate(-50%, -100%);
            padding: 2px 8px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(201,169,89,0.4);
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            font-weight: 600;
        }
        .character-label.visible { opacity: 1; }
        .character-label.selected {
            opacity: 1;
            color: var(--castle-red);
            border-color: rgba(233,69,96,0.6);
            background: rgba(0,0,0,0.7);
        }

        /* â”€â”€ Loading Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .loading-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #0d0d1a, var(--castle-navy));
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100;
            transition: opacity 0.8s ease;
        }
        .loading-screen.hidden { opacity: 0; pointer-events: none; }
        .loading-title {
            font-family: var(--font-medieval);
            font-size: 28px;
            color: var(--castle-gold);
            margin-bottom: 24px;
            text-shadow: 0 0 20px rgba(201,169,89,0.4);
        }
        .loading-bar-container {
            width: 300px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border-gold);
        }
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--castle-gold), var(--castle-red));
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        .loading-text {
            font-family: var(--font-serif);
            font-size: 12px;
            color: var(--castle-stone-light);
            margin-top: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* â”€â”€ Right Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .castle-rightpanel {
            grid-area: rightpanel;
            background: var(--bg-secondary);
            border-left: 2px solid var(--border-stone);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .rightpanel-header {
            padding: var(--space-5) var(--space-4);
            border-bottom: 1px solid var(--border-stone);
            background: linear-gradient(135deg, var(--castle-stone-dark), var(--castle-navy));
        }
        .rightpanel-title { font-family: var(--font-medieval); font-size: 18px; color: var(--castle-gold); text-align: center; }
        .activity-scroll { flex: 1; overflow-y: auto; padding: var(--space-3); }

        .activity-item {
            background: var(--bg-scroll);
            border: 1px solid var(--border-gold);
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            margin-bottom: var(--space-3);
            color: var(--text-dark);
            transition: transform 0.2s ease;
        }
        .activity-item:first-child { border-color: var(--castle-gold); box-shadow: 0 1px 6px rgba(201,169,89,0.15); }
        .activity-time { font-size: 11px; color: var(--castle-brown); margin-bottom: 2px; }
        .activity-message { font-size: 13px; line-height: 1.5; color: var(--castle-navy); }
        .activity-agent { font-weight: 600; color: var(--castle-red); }

        /* â”€â”€ Stats Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .stats-panel {
            background: var(--bg-scroll);
            border: 2px solid var(--castle-gold);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            margin: var(--space-3);
        }
        .stats-title { font-family: var(--font-medieval); font-size: 16px; color: var(--castle-navy); text-align: center; margin-bottom: var(--space-3); }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-3); }
        .stat-item { text-align: center; }
        .stat-value { font-family: var(--font-serif); font-size: 20px; font-weight: 600; color: var(--castle-red); display: block; }
        .stat-label { font-size: 12px; color: var(--castle-brown); text-transform: uppercase; letter-spacing: 0.5px; }

        /* â”€â”€ Demo Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .demo-badge {
            position: fixed; top: 6px; right: 6px;
            background: var(--castle-red); color: white;
            padding: 2px 8px; border-radius: var(--radius-sm);
            font-family: var(--font-serif); font-size: 11px; font-weight: 600;
            text-transform: uppercase; z-index: 1000;
        }

        /* â”€â”€ Scrollbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        .agents-scroll::-webkit-scrollbar, .activity-scroll::-webkit-scrollbar { width: 8px; }
        .agents-scroll::-webkit-scrollbar-track, .activity-scroll::-webkit-scrollbar-track { background: var(--castle-stone-dark); }
        .agents-scroll::-webkit-scrollbar-thumb, .activity-scroll::-webkit-scrollbar-thumb { background: var(--castle-gold); border-radius: 4px; }

        /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        @media (max-width: 1200px) { .castle-layout { grid-template-columns: 260px 1fr 280px; } }
        @media (max-width: 1024px) {
            .castle-layout { grid-template-columns: 1fr; grid-template-rows: 70px 1fr; grid-template-areas: "header" "main"; }
            .castle-sidebar, .castle-rightpanel { display: none; }
        }
    </style>
</head>
<body>
    <script>
        window.OC_RELAY_URL = 'https://fleet.spawnkit.ai';
        window.OC_RELAY_TOKEN = 'sk-oc-proxy-spawnkit-2026';
    </script>

    <div class="castle-layout">
        <header class="castle-header">
            <div class="castle-banner">
                <div class="castle-crest">ğŸ°</div>
                <div>
                    <h1 class="castle-name">Royal Command</h1>
                    <div class="castle-subtitle">Medieval AI Fleet</div>
                </div>
            </div>
            <div class="castle-status-bar">
                <div class="status-indicator"><div class="status-dot active"></div><span>Castle Online</span></div>
                <div class="status-indicator"><div class="status-dot busy"></div><span id="active-agents">8 Knights Active</span></div>
            </div>
        </header>

        <aside class="castle-sidebar">
            <div class="sidebar-header"><h2 class="sidebar-title">âš”ï¸ Royal Court</h2></div>
            <div class="agents-scroll" id="agents-list"></div>
        </aside>

        <main class="castle-main" id="scene-container">
            <!-- Loading Screen -->
            <div class="loading-screen" id="loading-screen">
                <div class="loading-title">âš”ï¸ Summoning the Castle</div>
                <div class="loading-bar-container">
                    <div class="loading-bar" id="loading-bar"></div>
                </div>
                <div class="loading-text" id="loading-text">Preparing siege...</div>
            </div>

            <!-- Character label overlays -->
            <div id="labels-container"></div>

            <!-- Controls -->
            <div class="scene-controls">
                <button class="control-btn" id="btn-toggle-sound" title="Toggle Sound">ğŸ”Š</button>
                <button class="control-btn" id="btn-fullscreen" title="Fullscreen">â›¶</button>
                <button class="control-btn" id="btn-reset-camera" title="Reset Camera">ğŸ¯</button>
            </div>
        </main>

        <aside class="castle-rightpanel">
            <div class="rightpanel-header"><h2 class="rightpanel-title">ğŸ“œ Royal Decrees</h2></div>
            <div class="stats-panel">
                <h3 class="stats-title">Castle Status</h3>
                <div class="stats-grid">
                    <div class="stat-item"><span class="stat-value" id="stat-missions">12</span><span class="stat-label">Quests</span></div>
                    <div class="stat-item"><span class="stat-value" id="stat-completed">8</span><span class="stat-label">Done</span></div>
                    <div class="stat-item"><span class="stat-value" id="stat-resources">2.4k</span><span class="stat-label">Gold</span></div>
                    <div class="stat-item"><span class="stat-value" id="stat-uptime">99.8%</span><span class="stat-label">Uptime</span></div>
                </div>
            </div>
            <div class="activity-scroll" id="activity-log"></div>
        </aside>
    </div>

    <div class="demo-badge" id="demo-badge" style="display: none;">Demo Mode</div>

    <script src="../src/data-bridge.js"></script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MedievalCastle3D â€” Three.js Scene
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class MedievalCastle3D {
        constructor() {
            this.agents = new Map();
            this.selectedAgent = null;
            this.soundEnabled = true;
            this.audioContext = null;
            this.sounds = new Map();

            // Three.js
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.controls = null;
            this.loader = new GLTFLoader();
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            this.clock = new THREE.Clock();

            // Characters
            this.characterModels = new Map(); // agentId â†’ { group, mixer, waypoints, waypointIndex, speed, ... }
            this.animationMixers = [];
            this.hoveredAgent = null;
            this.labelElements = new Map();

            // Loading
            this.totalModels = 0;
            this.loadedModels = 0;

            this.init();
        }

        async init() {
            this.setupThreeJS();
            this.setupAudio();
            this.setupAgents();
            this.setupEventListeners();
            this.setupUI();
            await this.loadAllModels();
            this.setupDataBridge();
            this.animate();
            this.playSound('horn');
        }

        // â”€â”€ Three.js Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupThreeJS() {
            const container = document.getElementById('scene-container');
            const w = container.clientWidth;
            const h = container.clientHeight;

            // Scene
            this.scene = new THREE.Scene();

            // Sky gradient background
            const skyCanvas = document.createElement('canvas');
            skyCanvas.width = 2;
            skyCanvas.height = 512;
            const ctx = skyCanvas.getContext('2d');
            const grad = ctx.createLinearGradient(0, 0, 0, 512);
            grad.addColorStop(0, '#0a1025');
            grad.addColorStop(0.2, '#1a2545');
            grad.addColorStop(0.45, '#2a4a7a');
            grad.addColorStop(0.65, '#5a8ab0');
            grad.addColorStop(0.8, '#8ab8d0');
            grad.addColorStop(0.92, '#d4a574');
            grad.addColorStop(1.0, '#e8c49a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 2, 512);
            const skyTex = new THREE.CanvasTexture(skyCanvas);
            skyTex.needsUpdate = true;
            this.scene.background = skyTex;

            // Fog for depth
            this.scene.fog = new THREE.FogExp2(0x5a7a9a, 0.006);

            // Orthographic camera for isometric view
            const aspect = w / h;
            const frustum = 9;
            this.camera = new THREE.OrthographicCamera(
                -frustum * aspect, frustum * aspect,
                frustum, -frustum,
                0.1, 200
            );
            // Isometric angle: ~45Â° azimuth, ~42Â° elevation (slightly more top-down)
            const dist = 40;
            const azimuth = Math.PI / 4; // 45Â°
            const elevation = Math.atan(Math.sin(Math.PI / 4.2)); // ~42Â°
            this.camera.position.set(
                dist * Math.cos(elevation) * Math.sin(azimuth),
                dist * Math.sin(elevation),
                dist * Math.cos(elevation) * Math.cos(azimuth)
            );
            this.camera.lookAt(0, 2, 0);

            // Renderer
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            this.renderer.setSize(w, h);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
            this.renderer.toneMappingExposure = 1.2;
            this.renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.insertBefore(this.renderer.domElement, container.firstChild);

            // Orbit Controls
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.08;
            this.controls.enablePan = true;
            this.controls.minZoom = 0.5;
            this.controls.maxZoom = 3;
            this.controls.maxPolarAngle = Math.PI / 2.2; // Don't go underground
            this.controls.minPolarAngle = Math.PI / 8;
            this.controls.target.set(0, 2, 0);
            this.controls.update();

            // Lighting
            this.setupLighting();

            // Ground
            this.createGround();

            // Resize handler
            window.addEventListener('resize', () => this.onResize());
        }

        setupLighting() {
            // Ambient â€” cool dusk tone
            const ambient = new THREE.AmbientLight(0xc8d8f0, 0.35);
            this.scene.add(ambient);

            // Hemisphere: twilight sky / mossy ground
            const hemi = new THREE.HemisphereLight(0x7090c0, 0x2a4a20, 0.3);
            this.scene.add(hemi);

            // Sun â€” low angle for dramatic long shadows (golden hour)
            const sun = new THREE.DirectionalLight(0xffd080, 2.0);
            sun.position.set(30, 40, 15);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 4096;
            sun.shadow.mapSize.height = 4096;
            sun.shadow.camera.near = 1;
            sun.shadow.camera.far = 250;
            sun.shadow.camera.left = -100;
            sun.shadow.camera.right = 100;
            sun.shadow.camera.top = 100;
            sun.shadow.camera.bottom = -100;
            sun.shadow.bias = -0.0005;
            sun.shadow.normalBias = 0.02;
            this.scene.add(sun);

            // Fill light from opposite side (blue-ish moonrise)
            const fill = new THREE.DirectionalLight(0x6080ff, 0.4);
            fill.position.set(-20, 15, -10);
            this.scene.add(fill);

            this.torchLights = [];

            // Gate torches
            const addTorch = (x, y, z) => {
                const t = new THREE.PointLight(0xff8800, 3.0, 9, 2);
                t.position.set(x, y, z);
                this.scene.add(t);
                this.torchLights.push(t);
            };
            addTorch(-1.8, 2.8, 6.2);
            addTorch( 1.8, 2.8, 6.2);

            // Keep courtyard fire
            const keepLight = new THREE.PointLight(0xffaa44, 2.0, 14, 2);
            keepLight.position.set(0, 1.5, 0);
            this.scene.add(keepLight);
            this.torchLights.push(keepLight);

            // Graveyard eerie green light
            const graveLight = new THREE.PointLight(0x44ff88, 1.2, 18, 2);
            graveLight.position.set(-16, 3, -13);
            this.scene.add(graveLight);
            this.torchLights.push(graveLight);

            // Village fire basket lights
            addTorch(-4, 1.5, 9.5);
            addTorch( 4, 1.5, 9.5);

            // Training grounds torch
            addTorch(16, 2, -2);

            // Chapel candle window glow
            const chapelGlow = new THREE.PointLight(0xffcc66, 1.5, 8, 2);
            chapelGlow.position.set(-8, 2, 15);
            this.scene.add(chapelGlow);
            this.torchLights.push(chapelGlow);
        }

        createGround() {
            // Base ground 200x200
            const groundGeo = new THREE.PlaneGeometry(200, 200, 80, 80);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3d6b22,
                roughness: 0.97,
                metalness: 0.01,
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            this.scene.add(ground);

            // Organic terrain bumps - gentle rolling hills
            const pos = groundGeo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const dist = Math.sqrt(x * x + y * y);
                if (dist > 10) {
                    pos.setZ(i, (
                        Math.sin(x * 0.25) * Math.cos(y * 0.22) * 0.6 +
                        Math.sin(x * 0.7 + 1.5) * 0.25 +
                        Math.random() * 0.15
                    ));
                }
            }
            groundGeo.computeVertexNormals();

            // Graveyard dark ground patch (NW zone, x=-50, z=-20)
            const graveGeo = new THREE.PlaneGeometry(24, 26, 4, 4);
            const graveGround = new THREE.Mesh(graveGeo, new THREE.MeshStandardMaterial({
                color: 0x1a2410, roughness: 0.99,
            }));
            graveGround.rotation.x = -Math.PI / 2;
            graveGround.position.set(-50, 0.005, -20);
            graveGround.receiveShadow = true;
            this.scene.add(graveGround);

            // Training ground dirt patch (NE zone, x=50, z=-40)
            const trainGeo = new THREE.PlaneGeometry(22, 20, 4, 4);
            const trainGround = new THREE.Mesh(trainGeo, new THREE.MeshStandardMaterial({ color: 0x5e4020, roughness: 0.98 }));
            trainGround.rotation.x = -Math.PI / 2;
            trainGround.position.set(50, 0.005, -40);
            trainGround.receiveShadow = true;
            this.scene.add(trainGround);

            // Castle 1 Moat (center, outer walls +-6)
            const moatShape = new THREE.Shape();
            moatShape.absarc(0, 0, 8.5, 0, Math.PI * 2, false);
            const moatHole = new THREE.Path();
            moatHole.absarc(0, 0, 6.8, 0, Math.PI * 2, true);
            moatShape.holes.push(moatHole);
            const moatGeo = new THREE.ShapeGeometry(moatShape, 96);
            const moat = new THREE.Mesh(moatGeo, new THREE.MeshStandardMaterial({
                color: 0x2288cc, transparent: true, opacity: 0.6,
                roughness: 0.12, metalness: 0.35,
                emissive: 0x114466, emissiveIntensity: 0.3,
                side: THREE.DoubleSide,
            }));
            moat.rotation.x = -Math.PI / 2;
            moat.position.y = -0.005;
            this.scene.add(moat);

            // Shimmer layer
            const shim = new THREE.Mesh(
                new THREE.RingGeometry(6.82, 8.48, 96),
                new THREE.MeshStandardMaterial({
                    color: 0x55bbff, transparent: true, opacity: 0.25,
                    roughness: 0.06, metalness: 0.7, side: THREE.DoubleSide,
                })
            );
            shim.rotation.x = -Math.PI / 2;
            shim.position.y = 0.04;
            this.scene.add(shim);
            this.moatShimmer = shim;

            // Castle 2 Moat (x=-30, z=-35)
            const moat2Shape = new THREE.Shape();
            moat2Shape.absarc(0, 0, 6.0, 0, Math.PI * 2, false);
            const moat2Hole = new THREE.Path();
            moat2Hole.absarc(0, 0, 5.0, 0, Math.PI * 2, true);
            moat2Shape.holes.push(moat2Hole);
            const moat2 = new THREE.Mesh(new THREE.ShapeGeometry(moat2Shape, 64), new THREE.MeshStandardMaterial({
                color: 0x2288cc, transparent: true, opacity: 0.6,
                roughness: 0.12, metalness: 0.35, emissive: 0x114466, emissiveIntensity: 0.3,
                side: THREE.DoubleSide,
            }));
            moat2.rotation.x = -Math.PI / 2;
            moat2.position.set(-30, -0.005, -35);
            this.scene.add(moat2);

            // Castle 3 Moat (x=35, z=-30)
            const moat3Shape = new THREE.Shape();
            moat3Shape.absarc(0, 0, 6.0, 0, Math.PI * 2, false);
            const moat3Hole = new THREE.Path();
            moat3Hole.absarc(0, 0, 5.0, 0, Math.PI * 2, true);
            moat3Shape.holes.push(moat3Hole);
            const moat3 = new THREE.Mesh(new THREE.ShapeGeometry(moat3Shape, 64), new THREE.MeshStandardMaterial({
                color: 0x2288cc, transparent: true, opacity: 0.6,
                roughness: 0.12, metalness: 0.35, emissive: 0x114466, emissiveIntensity: 0.3,
                side: THREE.DoubleSide,
            }));
            moat3.rotation.x = -Math.PI / 2;
            moat3.position.set(35, -0.005, -30);
            this.scene.add(moat3);

            // Helper: build river from point array
            const buildRiver = (points, yOff) => {
                if (yOff === undefined) yOff = -0.01;
                const riverWidth = 3.0;
                const riverMat = new THREE.MeshStandardMaterial({
                    color: 0x2288cc, transparent: true, opacity: 0.6,
                    roughness: 0.15, metalness: 0.3,
                    emissive: 0x114466, emissiveIntensity: 0.3,
                    side: THREE.DoubleSide,
                });
                const shimMat = new THREE.MeshStandardMaterial({
                    color: 0x77ccff, transparent: true, opacity: 0.2,
                    roughness: 0.06, metalness: 0.7, side: THREE.DoubleSide,
                });
                const grp = new THREE.Group();
                grp.position.y = yOff;
                const shimGrp = new THREE.Group();
                shimGrp.position.y = yOff + 0.04;

                for (let i = 0; i < points.length - 1; i++) {
                    const a = points[i];
                    const b = points[i + 1];
                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const midX = (a.x + b.x) / 2;
                    const midY = (a.y + b.y) / 2;

                    // Create river segment flat on ground, rotated to align with flow
                    const segGeo = new THREE.PlaneGeometry(len + 0.3, riverWidth);
                    segGeo.rotateX(-Math.PI / 2);  // lay flat
                    segGeo.rotateY(-angle);         // align to river direction
                    const seg = new THREE.Mesh(segGeo, riverMat.clone());
                    seg.position.set(midX, 0, midY);
                    grp.add(seg);

                    const shGeo = new THREE.PlaneGeometry(len + 0.3, riverWidth * 0.7);
                    shGeo.rotateX(-Math.PI / 2);
                    shGeo.rotateY(-angle);
                    const shSeg = new THREE.Mesh(shGeo, shimMat.clone());
                    shSeg.position.set(midX, 0, midY);
                    shimGrp.add(shSeg);
                }
                this.scene.add(grp);
                this.scene.add(shimGrp);
                return { grp, shimGrp };
            };

            // Main River: NW(-50,-60) -> Castle2(-30,-35) -> Castle1 gate(0,8) -> SE(50,20)
            const mainRiverPts = [
                new THREE.Vector2(-50, -60),
                new THREE.Vector2(-42, -50),
                new THREE.Vector2(-35, -40),
                new THREE.Vector2(-30, -35),
                new THREE.Vector2(-22, -28),
                new THREE.Vector2(-14, -18),
                new THREE.Vector2( -8,  -8),
                new THREE.Vector2( -3,   0),
                new THREE.Vector2(  0,   8),
                new THREE.Vector2(  5,  12),
                new THREE.Vector2( 14,  15),
                new THREE.Vector2( 28,  18),
                new THREE.Vector2( 40,  20),
                new THREE.Vector2( 50,  20),
            ];
            const mainRiverResult = buildRiver(mainRiverPts);
            this.riverShimmer = mainRiverResult.shimGrp;

            // Branch River: split at (-10,-15) -> east past Castle3(35,-30) -> exit(60,-10)
            const branchRiverPts = [
                new THREE.Vector2(-10, -15),
                new THREE.Vector2(  0, -20),
                new THREE.Vector2( 12, -25),
                new THREE.Vector2( 25, -28),
                new THREE.Vector2( 35, -30),
                new THREE.Vector2( 45, -22),
                new THREE.Vector2( 55, -15),
                new THREE.Vector2( 60, -10),
            ];
            const branchRiverResult = buildRiver(branchRiverPts);
            this.riverShimmer2 = branchRiverResult.shimGrp;

            // Campfire factory
            const makeFire = (x, z, scale) => {
                if (scale === undefined) scale = 1;
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.18 * scale, 0.22 * scale, 0.12, 8),
                    new THREE.MeshStandardMaterial({ color: 0x5a3a1a, roughness: 0.9 })
                );
                base.position.set(x, 0.06, z);
                base.castShadow = true;
                this.scene.add(base);

                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.14 * scale, 0.42 * scale, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xff5500, emissive: 0xff3300, emissiveIntensity: 2.8,
                        transparent: true, opacity: 0.88,
                    })
                );
                flame.position.set(x, 0.30 * scale, z);
                this.scene.add(flame);

                const inner = new THREE.Mesh(
                    new THREE.ConeGeometry(0.07 * scale, 0.24 * scale, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xffee00, emissive: 0xffcc00, emissiveIntensity: 3.5,
                        transparent: true, opacity: 0.95,
                    })
                );
                inner.position.set(x, 0.44 * scale, z);
                this.scene.add(inner);

                const fLight = new THREE.PointLight(0xff7722, 4.5 * scale, 9 * scale, 2);
                fLight.position.set(x, 0.8 * scale, z);
                this.scene.add(fLight);
                if (this.torchLights) this.torchLights.push(fLight);

                return { flame, inner, light: fLight, scale };
            };

            // Castle 1 courtyard fire
            this.campFires = [makeFire(1.5, 1.5, 1)];
            // Castle 2 courtyard fire
            this.campFires.push(makeFire(-30, -35, 0.8));
            // Castle 3 courtyard fire
            this.campFires.push(makeFire(35, -30, 0.8));
            this.campflame = this.campFires[0].flame;
            this.campflameInner = this.campFires[0].inner;
            this.campFireLight = this.campFires[0].light;
        }

        animateCampfire(elapsed) {
            if (!this.campFires) return;
            this.campFires.forEach((cf, i) => {
                if (!cf || !cf.flame) return;
                const phase = elapsed + i * 1.7;
                const flicker = 0.85 + Math.sin(phase * 11.3) * 0.12 + Math.sin(phase * 17.7) * 0.08;
                cf.flame.scale.set(flicker, flicker + Math.sin(phase * 9) * 0.14, flicker);
                cf.inner.scale.set(flicker, flicker + Math.cos(phase * 13.2) * 0.16, flicker);
                cf.flame.rotation.y = elapsed * 1.8 + i;
                if (cf.light) {
                    cf.light.intensity = 4.5 * (cf.scale || 1) * (0.82 + Math.sin(phase * 12 + 1) * 0.18);
                }
            });
            // Shimmer moat water
            if (this.moatShimmer) {
                this.moatShimmer.material.opacity = 0.22 + Math.sin(elapsed * 0.7) * 0.08;
            }
            // Animate river shimmer â€” flowing pulse along segments
            if (this.riverShimmer) {
                this.riverShimmer.children.forEach((seg, i) => {
                    if (seg.material) {
                        const wave = Math.sin(elapsed * 1.2 + i * 0.45) * 0.10;
                        seg.material.opacity = 0.25 + wave;
                        seg.position.y = Math.sin(elapsed * 0.8 + i * 0.3) * 0.005;
                    }
                });
            }
        }

        onResize() {
            const container = document.getElementById('scene-container');
            const w = container.clientWidth;
            const h = container.clientHeight;
            const aspect = w / h;
            const frustum = 9;

            this.camera.left = -frustum * aspect;
            this.camera.right = frustum * aspect;
            this.camera.top = frustum;
            this.camera.bottom = -frustum;
            this.camera.updateProjectionMatrix();

            this.renderer.setSize(w, h);
        }

        // â”€â”€ Model Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async loadAllModels() {
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');
            const loadingScreen = document.getElementById('loading-screen');

            // Define all models to load
            const modelDefs = this.getModelDefinitions();
            this.totalModels = modelDefs.length;

            const updateProgress = (label) => {
                this.loadedModels++;
                const pct = Math.round((this.loadedModels / this.totalModels) * 100);
                loadingBar.style.width = pct + '%';
                loadingText.textContent = label;
            };

            // Load models in batches
            const batchSize = 6;
            for (let i = 0; i < modelDefs.length; i += batchSize) {
                const batch = modelDefs.slice(i, i + batchSize);
                await Promise.all(batch.map(async (def) => {
                    try {
                        const gltf = await this.loadModel(def.path);
                        this.placeModel(gltf, def);
                        updateProgress(def.label || def.path.split('/').pop());
                    } catch (e) {
                        console.warn(`Failed to load ${def.path}:`, e);
                        updateProgress('(skipped) ' + def.path.split('/').pop());
                    }
                }));
            }

            // Load characters
            await this.loadCharacters(updateProgress);

            // Hide loading screen
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                setTimeout(() => loadingScreen.remove(), 1000);
            }, 500);
        }

        loadModel(path) {
            // Cache loaded models to avoid re-downloading same file
            if (!this._modelCache) this._modelCache = new Map();
            if (this._modelCache.has(path)) {
                // Return a deep clone of the cached model
                const cached = this._modelCache.get(path);
                return Promise.resolve({
                    scene: cached.scene.clone(true),
                    animations: cached.animations,
                });
            }
            return new Promise((resolve, reject) => {
                this.loader.load(path, (gltf) => {
                    this._modelCache.set(path, gltf);
                    resolve({
                        scene: gltf.scene.clone(true),
                        animations: gltf.animations,
                    });
                }, undefined, reject);
            });
        }

        getModelDefinitions() {
            const defs = [];

            // ===================================================
            // CASTLE 1 â€” Main Chateau (center-south, x=0, z=0)
            // ===================================================

            // GRAND KEEP (center, 4 stories, scale 1.8)
            const ks = 1.8;
            defs.push({ path: 'assets/castle/tower-square-base-color.glb', x: 0, y: 0, z: 0, ry: 0, scale: ks, label: 'Keep L1' });
            defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: 0, y: 1*ks, z: 0, ry: 0, scale: ks, label: 'Keep L2' });
            defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: 0, y: 2*ks, z: 0, ry: Math.PI/4, scale: ks, label: 'Keep L3' });
            defs.push({ path: 'assets/castle/tower-square-top-roof-high-windows.glb', x: 0, y: 3*ks, z: 0, ry: 0, scale: ks, label: 'Keep Roof' });
            defs.push({ path: 'assets/castle/flag-banner-long.glb', x: 0, y: 4*ks, z: 0, ry: 0, scale: ks, label: 'Keep Banner' });

            // INNER TOWERS (+-4)
            [[-4,-4],[4,-4],[-4,4],[4,4]].forEach(([tx,tz], i) => {
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.1, label: 'Inner Tower' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tx, y: 1.1, z: tz, ry: 0, scale: 1.1, label: 'Inner Tower' });
                defs.push({ path: 'assets/castle/tower-square-top-roof.glb', x: tx, y: 2.2, z: tz, ry: 0, scale: 1.1, label: 'Inner Tower' });
                defs.push({ path: i%2===0?'assets/castle/flag.glb':'assets/castle/flag-pennant.glb', x: tx, y: 3.3, z: tz, ry: 0, scale: 1, label: 'Flag' });
            });

            // INNER WALLS (+-4)
            for (let x = -3; x <= 3; x++) defs.push({ path: 'assets/castle/wall.glb', x, y: 0, z: -4, ry: 0, scale: 1.1, label: 'Inner N' });
            for (let x = -3; x <= 3; x++) defs.push({ path: x===0?'assets/castle/wall-doorway.glb':'assets/castle/wall.glb', x, y: 0, z: 4, ry: 0, scale: 1.1, label: 'Inner S' });
            for (let z = -3; z <= 3; z++) defs.push({ path: 'assets/castle/wall.glb', x: 4, y: 0, z, ry: Math.PI/2, scale: 1.1, label: 'Inner E' });
            for (let z = -3; z <= 3; z++) defs.push({ path: 'assets/castle/wall.glb', x: -4, y: 0, z, ry: Math.PI/2, scale: 1.1, label: 'Inner W' });

            // OUTER TOWERS (+-6)
            [[-6,-6],[6,-6],[-6,6],[6,6]].forEach(([tx,tz], i) => {
                defs.push({ path: 'assets/castle/tower-square-base-border.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.2, label: 'Outer Tower' });
                defs.push({ path: 'assets/castle/tower-square-mid.glb', x: tx, y: 1.2, z: tz, ry: 0, scale: 1.2, label: 'Outer Tower' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tx, y: 2.4, z: tz, ry: 0, scale: 1.2, label: 'Outer Tower' });
                defs.push({ path: 'assets/castle/tower-square-top-roof-rounded.glb', x: tx, y: 3.6, z: tz, ry: 0, scale: 1.2, label: 'Outer Tower' });
                defs.push({ path: 'assets/castle/flag-wide.glb', x: tx, y: 4.8, z: tz, ry: i*Math.PI/2, scale: 1.2, label: 'Banner' });
            });

            // HEXAGON TOWER at north outer wall (x=0, z=-6)
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: 0, y: 0, z: -6, ry: 0, scale: 1.0, label: 'Hex Tower N' });
            defs.push({ path: 'assets/castle/tower-hexagon-mid.glb', x: 0, y: 1.0, z: -6, ry: 0, scale: 1.0, label: 'Hex Tower N' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: 0, y: 2.0, z: -6, ry: 0, scale: 1.0, label: 'Hex Tower N' });

            // OUTER WALLS (+-6)
            for (let x = -5; x <= 5; x++) { if (x===0) continue; defs.push({ path: 'assets/castle/wall.glb', x, y: 0, z: -6, ry: 0, scale: 1.2, label: 'Outer N' }); if(x%3===0) defs.push({ path: 'assets/castle/wall-stud.glb', x, y: 1.2, z: -6, ry: 0, scale: 1.2, label: 'Battlement' }); }
            for (let x = -5; x <= 5; x++) { if (x>=-1&&x<=1) continue; defs.push({ path: 'assets/castle/wall.glb', x, y: 0, z: 6, ry: 0, scale: 1.2, label: 'Outer S' }); if(x%3===0) defs.push({ path: 'assets/castle/wall-stud.glb', x, y: 1.2, z: 6, ry: 0, scale: 1.2, label: 'Battlement' }); }
            for (let z = -5; z <= 5; z++) { if (z===0) continue; defs.push({ path: 'assets/castle/wall.glb', x: 6, y: 0, z, ry: Math.PI/2, scale: 1.2, label: 'Outer E' }); }
            for (let z = -5; z <= 5; z++) { if (z===0) continue; defs.push({ path: 'assets/castle/wall.glb', x: -6, y: 0, z, ry: Math.PI/2, scale: 1.2, label: 'Outer W' }); }

            // GATEHOUSE south (z=6)
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: 0, y: 0, z: 6, ry: 0, scale: 1.3, label: 'Gate' });
            defs.push({ path: 'assets/castle/gate.glb', x: 0, y: 0, z: 7, ry: 0, scale: 1.2, label: 'Gate' });
            defs.push({ path: 'assets/castle/metal-gate.glb', x: 0, y: 0, z: 7.5, ry: 0, scale: 1.2, label: 'Portcullis' });
            [[-2,7],[2,7]].forEach(([tx,tz]) => {
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.0, label: 'Gate Tower' });
                defs.push({ path: 'assets/castle/tower-square-mid-door.glb', x: tx, y: 1, z: tz, ry: 0, scale: 1.0, label: 'Gate Tower' });
                defs.push({ path: 'assets/castle/tower-square-top.glb', x: tx, y: 2, z: tz, ry: 0, scale: 1.0, label: 'Gate Tower' });
            });
            defs.push({ path: 'assets/castle/flag-banner-long.glb', x: -2, y: 3, z: 7, ry: 0, scale: 1, label: 'Gate flag' });
            defs.push({ path: 'assets/castle/flag-banner-long.glb', x:  2, y: 3, z: 7, ry: 0, scale: 1, label: 'Gate flag' });
            defs.push({ path: 'assets/castle/bridge-draw.glb', x: 0, y: 0, z: 8, ry: 0, scale: 1.3, label: 'Drawbridge1' });
            defs.push({ path: 'assets/castle/bridge-draw.glb', x: 0, y: 0, z: 9, ry: 0, scale: 1.3, label: 'Drawbridge2' });

            // CASTLE 1 COURTYARD BUILDINGS
            // Barracks NW(-5,-5)
            defs.push({ path: 'assets/castle/wall.glb', x: -5, y: 0, z: -5, ry: 0, scale: 0.9, label: 'Barracks' });
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: -5, y: 0, z: -4, ry: 0, scale: 0.9, label: 'Barracks' });
            defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: -5, y: 0.9, z: -5, ry: 0, scale: 0.9, label: 'Barracks roof' });
            // Chapel NE(5,-5)
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: 5, y: 0, z: -5, ry: 0, scale: 0.9, label: 'Chapel' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof-secondary.glb', x: 5, y: 0.9, z: -5, ry: 0, scale: 0.9, label: 'Chapel' });
            defs.push({ path: 'assets/graveyard/cross.glb', x: 5, y: 1.8, z: -5, ry: 0, scale: 0.7, label: 'Cross' });
            // Armory SW(-5,5)
            defs.push({ path: 'assets/castle/wall.glb', x: -5, y: 0, z: 5, ry: Math.PI/2, scale: 0.9, label: 'Armory' });
            defs.push({ path: 'assets/castle/door.glb', x: -4, y: 0, z: 5, ry: 0, scale: 0.9, label: 'Armory door' });
            // Stables SE(5,5)
            for (let z = 4; z <= 6; z++) defs.push({ path: 'assets/castle/wall-narrow-wood.glb', x: 5, y: 0, z, ry: 0, scale: 1, label: 'Stables' });
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: 4.5, y: 0, z: 5.5, ry: 0.5, scale: 1, label: 'Hay' });

            // ===================================================
            // CASTLE 2 â€” Northern Fortress (x=-30, z=-35)
            // ===================================================
            const c2x = -30, c2z = -35;

            // DONJON (3 stories, scale 1.5)
            const k2s = 1.5;
            defs.push({ path: 'assets/castle/tower-square-base-color.glb', x: c2x, y: 0, z: c2z, ry: 0, scale: k2s, label: 'C2 Keep L1' });
            defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: c2x, y: 1*k2s, z: c2z, ry: 0, scale: k2s, label: 'C2 Keep L2' });
            defs.push({ path: 'assets/castle/tower-square-top-roof-high-windows.glb', x: c2x, y: 2*k2s, z: c2z, ry: 0, scale: k2s, label: 'C2 Keep Roof' });
            defs.push({ path: 'assets/castle/flag-banner-long.glb', x: c2x, y: 3*k2s, z: c2z, ry: 0, scale: k2s, label: 'C2 Banner' });

            // C2 INNER TOWERS (+-3 relative = absolute offsets)
            [[-3,-3],[3,-3],[-3,3],[3,3]].forEach(([dx,dz], i) => {
                const tx = c2x+dx, tz = c2z+dz;
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.0, label: 'C2 Inner' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tx, y: 1.0, z: tz, ry: 0, scale: 1.0, label: 'C2 Inner' });
                defs.push({ path: 'assets/castle/tower-square-top-roof.glb', x: tx, y: 2.0, z: tz, ry: 0, scale: 1.0, label: 'C2 Inner' });
                defs.push({ path: i%2===0?'assets/castle/flag.glb':'assets/castle/flag-pennant.glb', x: tx, y: 3.0, z: tz, ry: 0, scale: 0.9, label: 'C2 Flag' });
            });

            // C2 INNER WALLS
            for (let x = -2; x <= 2; x++) defs.push({ path: 'assets/castle/wall.glb', x: c2x+x, y: 0, z: c2z-3, ry: 0, scale: 1.0, label: 'C2 Wall' });
            for (let x = -2; x <= 2; x++) defs.push({ path: x===0?'assets/castle/wall-doorway.glb':'assets/castle/wall.glb', x: c2x+x, y: 0, z: c2z+3, ry: 0, scale: 1.0, label: 'C2 Wall' });
            for (let z = -2; z <= 2; z++) defs.push({ path: 'assets/castle/wall.glb', x: c2x+3, y: 0, z: c2z+z, ry: Math.PI/2, scale: 1.0, label: 'C2 Wall E' });
            for (let z = -2; z <= 2; z++) defs.push({ path: 'assets/castle/wall.glb', x: c2x-3, y: 0, z: c2z+z, ry: Math.PI/2, scale: 1.0, label: 'C2 Wall W' });

            // C2 OUTER TOWERS (+-4 relative)
            [[-4,-4],[4,-4],[-4,4],[4,4]].forEach(([dx,dz], i) => {
                const tx = c2x+dx, tz = c2z+dz;
                defs.push({ path: 'assets/castle/tower-square-base-border.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.1, label: 'C2 Outer' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tx, y: 1.1, z: tz, ry: 0, scale: 1.1, label: 'C2 Outer' });
                defs.push({ path: 'assets/castle/tower-square-top-roof-rounded.glb', x: tx, y: 2.2, z: tz, ry: 0, scale: 1.1, label: 'C2 Outer' });
                defs.push({ path: 'assets/castle/flag-wide.glb', x: tx, y: 3.3, z: tz, ry: i*Math.PI/2, scale: 1.0, label: 'C2 Banner' });
            });

            // C2 HEXAGON TOWER at north outer wall
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: c2x, y: 0, z: c2z-4, ry: 0, scale: 1.0, label: 'C2 Hex' });
            defs.push({ path: 'assets/castle/tower-hexagon-mid.glb', x: c2x, y: 1.0, z: c2z-4, ry: 0, scale: 1.0, label: 'C2 Hex' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: c2x, y: 2.0, z: c2z-4, ry: 0, scale: 1.0, label: 'C2 Hex' });

            // C2 OUTER WALLS
            for (let x = -3; x <= 3; x++) { if (Math.abs(x)===4) continue; defs.push({ path: 'assets/castle/wall.glb', x: c2x+x, y: 0, z: c2z-4, ry: 0, scale: 1.1, label: 'C2 Outer N' }); if(x%3===0) defs.push({ path: 'assets/castle/wall-stud.glb', x: c2x+x, y: 1.1, z: c2z-4, ry: 0, scale: 1.1 }); }
            for (let x = -3; x <= 3; x++) { if (x===0) continue; defs.push({ path: 'assets/castle/wall.glb', x: c2x+x, y: 0, z: c2z+4, ry: 0, scale: 1.1, label: 'C2 Outer S' }); if(x%3===0) defs.push({ path: 'assets/castle/wall-stud.glb', x: c2x+x, y: 1.1, z: c2z+4, ry: 0, scale: 1.1 }); }
            for (let z = -3; z <= 3; z++) defs.push({ path: 'assets/castle/wall.glb', x: c2x+4, y: 0, z: c2z+z, ry: Math.PI/2, scale: 1.1, label: 'C2 E' });
            for (let z = -3; z <= 3; z++) defs.push({ path: 'assets/castle/wall.glb', x: c2x-4, y: 0, z: c2z+z, ry: Math.PI/2, scale: 1.1, label: 'C2 W' });

            // C2 GATEHOUSE south
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: c2x, y: 0, z: c2z+4, ry: 0, scale: 1.1, label: 'C2 Gate' });
            defs.push({ path: 'assets/castle/gate.glb', x: c2x, y: 0, z: c2z+5, ry: 0, scale: 1.0, label: 'C2 Gate' });
            defs.push({ path: 'assets/castle/metal-gate.glb', x: c2x, y: 0, z: c2z+5.5, ry: 0, scale: 1.0, label: 'C2 Portcullis' });
            [[-2,5],[2,5]].forEach(([dx,dz]) => {
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: c2x+dx, y: 0, z: c2z+dz, ry: 0, scale: 0.9, label: 'C2 Gate Tower' });
                defs.push({ path: 'assets/castle/tower-square-mid-door.glb', x: c2x+dx, y: 0.9, z: c2z+dz, ry: 0, scale: 0.9, label: 'C2 Gate Tower' });
                defs.push({ path: 'assets/castle/tower-square-top.glb', x: c2x+dx, y: 1.8, z: c2z+dz, ry: 0, scale: 0.9, label: 'C2 Gate Tower' });
            });
            defs.push({ path: 'assets/castle/bridge-draw.glb', x: c2x, y: 0, z: c2z+6, ry: 0, scale: 1.1, label: 'C2 Drawbridge' });

            // C2 COURTYARD
            defs.push({ path: 'assets/castle/wall.glb', x: c2x-2, y: 0, z: c2z-2, ry: 0, scale: 0.85, label: 'C2 Barracks' });
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: c2x-2, y: 0, z: c2z-1, ry: 0, scale: 0.85, label: 'C2 Barracks' });
            defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: c2x-2, y: 0.85, z: c2z-1.5, ry: 0, scale: 0.85, label: 'C2 Barracks roof' });
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: c2x+2, y: 0, z: c2z-2, ry: 0, scale: 0.85, label: 'C2 Chapel' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: c2x+2, y: 0.85, z: c2z-2, ry: 0, scale: 0.85, label: 'C2 Chapel' });

            // ===================================================
            // CASTLE 3 â€” Eastern Keep (x=35, z=-30)
            // ===================================================
            const c3x = 35, c3z = -30;

            // DONJON (3 stories, scale 1.5)
            const k3s = 1.5;
            defs.push({ path: 'assets/castle/tower-square-base-color.glb', x: c3x, y: 0, z: c3z, ry: 0, scale: k3s, label: 'C3 Keep L1' });
            defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: c3x, y: 1*k3s, z: c3z, ry: 0, scale: k3s, label: 'C3 Keep L2' });
            defs.push({ path: 'assets/castle/tower-square-top-roof-high-windows.glb', x: c3x, y: 2*k3s, z: c3z, ry: 0, scale: k3s, label: 'C3 Keep Roof' });
            defs.push({ path: 'assets/castle/flag-banner-long.glb', x: c3x, y: 3*k3s, z: c3z, ry: 0, scale: k3s, label: 'C3 Banner' });

            // C3 INNER TOWERS (+-3 relative)
            [[-3,-3],[3,-3],[-3,3],[3,3]].forEach(([dx,dz], i) => {
                const tx = c3x+dx, tz = c3z+dz;
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.0, label: 'C3 Inner' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tx, y: 1.0, z: tz, ry: 0, scale: 1.0, label: 'C3 Inner' });
                defs.push({ path: 'assets/castle/tower-square-top-roof.glb', x: tx, y: 2.0, z: tz, ry: 0, scale: 1.0, label: 'C3 Inner' });
                defs.push({ path: i%2===0?'assets/castle/flag.glb':'assets/castle/flag-pennant.glb', x: tx, y: 3.0, z: tz, ry: 0, scale: 0.9, label: 'C3 Flag' });
            });

            // C3 INNER WALLS
            for (let x = -2; x <= 2; x++) defs.push({ path: 'assets/castle/wall.glb', x: c3x+x, y: 0, z: c3z-3, ry: 0, scale: 1.0, label: 'C3 Wall' });
            for (let x = -2; x <= 2; x++) defs.push({ path: x===0?'assets/castle/wall-doorway.glb':'assets/castle/wall.glb', x: c3x+x, y: 0, z: c3z+3, ry: 0, scale: 1.0, label: 'C3 Wall' });
            for (let z = -2; z <= 2; z++) defs.push({ path: 'assets/castle/wall.glb', x: c3x+3, y: 0, z: c3z+z, ry: Math.PI/2, scale: 1.0, label: 'C3 Wall E' });
            for (let z = -2; z <= 2; z++) defs.push({ path: 'assets/castle/wall.glb', x: c3x-3, y: 0, z: c3z+z, ry: Math.PI/2, scale: 1.0, label: 'C3 Wall W' });

            // C3 OUTER TOWERS (+-4 relative)
            [[-4,-4],[4,-4],[-4,4],[4,4]].forEach(([dx,dz], i) => {
                const tx = c3x+dx, tz = c3z+dz;
                defs.push({ path: 'assets/castle/tower-square-base-border.glb', x: tx, y: 0, z: tz, ry: 0, scale: 1.1, label: 'C3 Outer' });
                defs.push({ path: 'assets/castle/tower-square-mid-windows.glb', x: tx, y: 1.1, z: tz, ry: 0, scale: 1.1, label: 'C3 Outer' });
                defs.push({ path: 'assets/castle/tower-square-top-roof-rounded.glb', x: tx, y: 2.2, z: tz, ry: 0, scale: 1.1, label: 'C3 Outer' });
                defs.push({ path: 'assets/castle/flag-wide.glb', x: tx, y: 3.3, z: tz, ry: i*Math.PI/2, scale: 1.0, label: 'C3 Banner' });
            });

            // C3 HEXAGON TOWER at north outer wall
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: c3x, y: 0, z: c3z-4, ry: 0, scale: 1.0, label: 'C3 Hex' });
            defs.push({ path: 'assets/castle/tower-hexagon-mid.glb', x: c3x, y: 1.0, z: c3z-4, ry: 0, scale: 1.0, label: 'C3 Hex' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: c3x, y: 2.0, z: c3z-4, ry: 0, scale: 1.0, label: 'C3 Hex' });

            // C3 OUTER WALLS
            for (let x = -3; x <= 3; x++) { if (Math.abs(x)===4) continue; defs.push({ path: 'assets/castle/wall.glb', x: c3x+x, y: 0, z: c3z-4, ry: 0, scale: 1.1, label: 'C3 Outer N' }); if(x%3===0) defs.push({ path: 'assets/castle/wall-stud.glb', x: c3x+x, y: 1.1, z: c3z-4, ry: 0, scale: 1.1 }); }
            for (let x = -3; x <= 3; x++) { if (x===0) continue; defs.push({ path: 'assets/castle/wall.glb', x: c3x+x, y: 0, z: c3z+4, ry: 0, scale: 1.1, label: 'C3 Outer S' }); if(x%3===0) defs.push({ path: 'assets/castle/wall-stud.glb', x: c3x+x, y: 1.1, z: c3z+4, ry: 0, scale: 1.1 }); }
            for (let z = -3; z <= 3; z++) defs.push({ path: 'assets/castle/wall.glb', x: c3x+4, y: 0, z: c3z+z, ry: Math.PI/2, scale: 1.1, label: 'C3 E' });
            for (let z = -3; z <= 3; z++) defs.push({ path: 'assets/castle/wall.glb', x: c3x-4, y: 0, z: c3z+z, ry: Math.PI/2, scale: 1.1, label: 'C3 W' });

            // C3 GATEHOUSE south
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: c3x, y: 0, z: c3z+4, ry: 0, scale: 1.1, label: 'C3 Gate' });
            defs.push({ path: 'assets/castle/gate.glb', x: c3x, y: 0, z: c3z+5, ry: 0, scale: 1.0, label: 'C3 Gate' });
            defs.push({ path: 'assets/castle/metal-gate.glb', x: c3x, y: 0, z: c3z+5.5, ry: 0, scale: 1.0, label: 'C3 Portcullis' });
            [[-2,5],[2,5]].forEach(([dx,dz]) => {
                defs.push({ path: 'assets/castle/tower-square-base.glb', x: c3x+dx, y: 0, z: c3z+dz, ry: 0, scale: 0.9, label: 'C3 Gate Tower' });
                defs.push({ path: 'assets/castle/tower-square-mid-door.glb', x: c3x+dx, y: 0.9, z: c3z+dz, ry: 0, scale: 0.9, label: 'C3 Gate Tower' });
                defs.push({ path: 'assets/castle/tower-square-top.glb', x: c3x+dx, y: 1.8, z: c3z+dz, ry: 0, scale: 0.9, label: 'C3 Gate Tower' });
            });
            defs.push({ path: 'assets/castle/bridge-draw.glb', x: c3x, y: 0, z: c3z+6, ry: 0, scale: 1.1, label: 'C3 Drawbridge' });

            // C3 COURTYARD
            defs.push({ path: 'assets/castle/wall.glb', x: c3x-2, y: 0, z: c3z-2, ry: 0, scale: 0.85, label: 'C3 Barracks' });
            defs.push({ path: 'assets/castle/wall-doorway.glb', x: c3x-2, y: 0, z: c3z-1, ry: 0, scale: 0.85, label: 'C3 Barracks' });
            defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: c3x-2, y: 0.85, z: c3z-1.5, ry: 0, scale: 0.85, label: 'C3 Barracks roof' });
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: c3x+2, y: 0, z: c3z-2, ry: 0, scale: 0.85, label: 'C3 Chapel' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: c3x+2, y: 0.85, z: c3z-2, ry: 0, scale: 0.85, label: 'C3 Chapel' });

            // ===================================================
            // DENSE FOREST (150+ trees) â€” ring around perimeter
            // ===================================================
            for (let angle = 0; angle < Math.PI * 2; angle += 0.04) {
                const r = 60 + Math.random() * 20;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const path = Math.random() > 0.35 ? 'assets/castle/tree-large.glb' : 'assets/castle/tree-small.glb';
                defs.push({ path, x, y: 0, z, ry: Math.random()*Math.PI*2, scale: 1.0+Math.random()*1.0, label: 'Tree' });
            }
            // Extra clusters between castles
            const treeClusters = [
                {x:-15,z:-20},{x:-18,z:-22},{x:-12,z:-25},{x:-8,z:-18},{x:-20,z:-15},
                {x: 15,z:-20},{x: 18,z:-22},{x: 12,z:-25},{x: 22,z:-18},{x: 20,z:-12},
                {x:  0,z:-18},{x:  2,z:-22},{x: -3,z:-15},{x:  5,z:-28},{x: -5,z:-28},
                {x:-22,z:-10},{x:24,z:-8},{x:-25,z:-5},{x:22,z:5},{x:-20,z:8},
                {x: 10,z: 12},{x:-10,z:12},{x:15,z:18},{x:-15,z:18},{x:5,z:25},
            ];
            treeClusters.forEach(t => {
                defs.push({ path: 'assets/castle/tree-large.glb', x: t.x, y: 0, z: t.z, ry: Math.random()*Math.PI*2, scale: 1.2+Math.random()*0.8, label: 'Tree' });
            });
            // Pines near graveyard (NW, x=-50, z=-20)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const r = 10 + Math.random() * 5;
                const pines = ['assets/graveyard/pine.glb','assets/graveyard/pine-crooked.glb','assets/graveyard/pine-fall.glb'];
                defs.push({ path: pines[i%3], x: -50 + Math.cos(angle)*r, y: 0, z: -20 + Math.sin(angle)*r, ry: Math.random()*Math.PI*2, scale: 1.0+Math.random()*0.5, label: 'Pine' });
            }

            // ===================================================
            // VILLAGE 1 â€” south of Castle 1 (z=12 to z=24)
            // ===================================================
            const v1Houses = [[-3,14,0.8],[-4,16,0.7],[-3,18,0.85],[-5,20,0.75],[3,14,0.85],[4,16,0.7],[3,18,0.8],[5,20,0.75],[-2,22,0.7],[2,22,0.72]];
            v1Houses.forEach(([bx,bz,bs]) => {
                defs.push({ path: 'assets/castle/wall.glb', x: bx, y: 0, z: bz, ry: 0, scale: bs, label: 'V1 House' });
                defs.push({ path: 'assets/castle/wall-doorway.glb', x: bx, y: 0, z: bz+1, ry: 0, scale: bs, label: 'V1 Door' });
                defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: bx, y: bs*0.95, z: bz+0.5, ry: bx>0?Math.PI:0, scale: bs, label: 'V1 Roof' });
            });
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: -8, y: 0, z: 16, ry: 0, scale: 1.0, label: 'V1 Chapel' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: -8, y: 1.0, z: 16, ry: 0, scale: 1.0, label: 'V1 Chapel' });
            defs.push({ path: 'assets/graveyard/cross.glb', x: -8, y: 2.0, z: 16, ry: 0, scale: 0.7, label: 'V1 Cross' });
            defs.push({ path: 'assets/graveyard/altar-stone.glb', x: 0, y: 0, z: 17, ry: 0, scale: 1, label: 'V1 Altar' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: -1.5, y: 0, z: 17, ry: Math.PI/2, scale: 1, label: 'V1 Bench' });
            defs.push({ path: 'assets/graveyard/bench.glb', x:  1.5, y: 0, z: 17, ry: -Math.PI/2, scale: 1, label: 'V1 Bench' });
            defs.push({ path: 'assets/graveyard/lightpost-double.glb', x: 0, y: 0, z: 14, ry: 0, scale: 1, label: 'V1 Light' });
            defs.push({ path: 'assets/graveyard/lightpost-single.glb', x: -2, y: 0, z: 12, ry: 0, scale: 1, label: 'V1 Light' });
            defs.push({ path: 'assets/graveyard/lightpost-single.glb', x:  2, y: 0, z: 12, ry: 0, scale: 1, label: 'V1 Light' });
            for (let z = 13; z <= 22; z += 2) {
                defs.push({ path: 'assets/castle/wall-narrow-wood-fence.glb', x: -7, y: 0, z, ry: Math.PI/2, scale: 0.8, label: 'V1 Fence' });
                defs.push({ path: 'assets/castle/wall-narrow-wood-fence.glb', x:  7, y: 0, z, ry: Math.PI/2, scale: 0.8, label: 'V1 Fence' });
            }
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: -6, y: 0, z: 19, ry: 0.5, scale: 1, label: 'V1 Hay' });
            defs.push({ path: 'assets/graveyard/hay-bale-bundled.glb', x: 6, y: 0, z: 19, ry: 0.8, scale: 1, label: 'V1 Hay' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: -3, y: 0, z: 12.5, ry: 0, scale: 1, label: 'V1 Fire' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x:  3, y: 0, z: 12.5, ry: 0, scale: 1, label: 'V1 Fire' });

            // ===================================================
            // VILLAGE 2 â€” south of Castle 2 (x=-30, z=-25)
            // ===================================================
            const v2cx = -30, v2cz = -25;
            const v2Houses = [[-3,0,0.8],[3,0,0.75],[-4,2,0.7],[4,2,0.72],[-2,4,0.85],[2,4,0.8],[-3,6,0.75],[3,6,0.7],[-1,8,0.68],[1,8,0.7]];
            v2Houses.forEach(([dx,dz,bs]) => {
                const bx = v2cx+dx, bz = v2cz+dz;
                defs.push({ path: 'assets/castle/wall.glb', x: bx, y: 0, z: bz, ry: 0, scale: bs, label: 'V2 House' });
                defs.push({ path: 'assets/castle/wall-doorway.glb', x: bx, y: 0, z: bz+1, ry: 0, scale: bs, label: 'V2 Door' });
                defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: bx, y: bs*0.95, z: bz+0.5, ry: dx>0?Math.PI:0, scale: bs, label: 'V2 Roof' });
            });
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: v2cx-6, y: 0, z: v2cz+3, ry: 0, scale: 0.9, label: 'V2 Chapel' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: v2cx-6, y: 0.9, z: v2cz+3, ry: 0, scale: 0.9, label: 'V2 Chapel' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: v2cx-1, y: 0, z: v2cz+4, ry: Math.PI/2, scale: 1, label: 'V2 Bench' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: v2cx+1, y: 0, z: v2cz+4, ry: -Math.PI/2, scale: 1, label: 'V2 Bench' });
            defs.push({ path: 'assets/graveyard/lightpost-double.glb', x: v2cx, y: 0, z: v2cz+1, ry: 0, scale: 1, label: 'V2 Light' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: v2cx-2, y: 0, z: v2cz-0.5, ry: 0, scale: 1, label: 'V2 Fire' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: v2cx+2, y: 0, z: v2cz-0.5, ry: 0, scale: 1, label: 'V2 Fire' });
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: v2cx+5, y: 0, z: v2cz+5, ry: 0.5, scale: 1, label: 'V2 Hay' });

            // ===================================================
            // VILLAGE 3 â€” south of Castle 3 (x=35, z=-20)
            // ===================================================
            const v3cx = 35, v3cz = -20;
            const v3Houses = [[-3,0,0.8],[3,0,0.75],[-4,2,0.72],[4,2,0.7],[-2,4,0.85],[2,4,0.8],[-3,6,0.75],[3,6,0.7],[-1,8,0.7],[1,8,0.68]];
            v3Houses.forEach(([dx,dz,bs]) => {
                const bx = v3cx+dx, bz = v3cz+dz;
                defs.push({ path: 'assets/castle/wall.glb', x: bx, y: 0, z: bz, ry: 0, scale: bs, label: 'V3 House' });
                defs.push({ path: 'assets/castle/wall-doorway.glb', x: bx, y: 0, z: bz+1, ry: 0, scale: bs, label: 'V3 Door' });
                defs.push({ path: 'assets/castle/tower-slant-roof.glb', x: bx, y: bs*0.95, z: bz+0.5, ry: dx>0?Math.PI:0, scale: bs, label: 'V3 Roof' });
            });
            defs.push({ path: 'assets/castle/tower-hexagon-base.glb', x: v3cx+6, y: 0, z: v3cz+3, ry: 0, scale: 0.9, label: 'V3 Chapel' });
            defs.push({ path: 'assets/castle/tower-hexagon-roof.glb', x: v3cx+6, y: 0.9, z: v3cz+3, ry: 0, scale: 0.9, label: 'V3 Chapel' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: v3cx-1, y: 0, z: v3cz+4, ry: Math.PI/2, scale: 1, label: 'V3 Bench' });
            defs.push({ path: 'assets/graveyard/bench.glb', x: v3cx+1, y: 0, z: v3cz+4, ry: -Math.PI/2, scale: 1, label: 'V3 Bench' });
            defs.push({ path: 'assets/graveyard/lightpost-double.glb', x: v3cx, y: 0, z: v3cz+1, ry: 0, scale: 1, label: 'V3 Light' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: v3cx-2, y: 0, z: v3cz-0.5, ry: 0, scale: 1, label: 'V3 Fire' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: v3cx+2, y: 0, z: v3cz-0.5, ry: 0, scale: 1, label: 'V3 Fire' });
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: v3cx-5, y: 0, z: v3cz+5, ry: 0.8, scale: 1, label: 'V3 Hay' });

            // ===================================================
            // GRAVEYARD (NW, x=-50, z=-20)
            // ===================================================
            const gx = -50, gz = -20;
            // Iron fence perimeter
            for (let x = -7; x <= 7; x++) { defs.push({ path: 'assets/graveyard/iron-fence.glb', x: gx+x, y: 0, z: gz-8, ry: 0, scale: 1, label: 'GY Fence' }); defs.push({ path: 'assets/graveyard/iron-fence.glb', x: gx+x, y: 0, z: gz+8, ry: 0, scale: 1, label: 'GY Fence' }); }
            for (let z = -7; z <= 7; z++) { defs.push({ path: 'assets/graveyard/iron-fence.glb', x: gx-7, y: 0, z: gz+z, ry: Math.PI/2, scale: 1, label: 'GY Fence' }); defs.push({ path: 'assets/graveyard/iron-fence.glb', x: gx+7, y: 0, z: gz+z, ry: Math.PI/2, scale: 1, label: 'GY Fence' }); }
            defs.push({ path: 'assets/graveyard/iron-fence-border-gate.glb', x: gx, y: 0, z: gz+8, ry: 0, scale: 1, label: 'GY Gate' });
            defs.push({ path: 'assets/graveyard/column-large.glb', x: gx-1, y: 0, z: gz+8, ry: 0, scale: 1.2, label: 'GY Column' });
            defs.push({ path: 'assets/graveyard/column-large.glb', x: gx+1, y: 0, z: gz+8, ry: 0, scale: 1.2, label: 'GY Column' });
            // 15 gravestones
            ['gravestone-cross','gravestone-round','gravestone-wide','gravestone-decorative','gravestone-broken','gravestone-bevel','gravestone-cross-large','gravestone-roof','gravestone-debris','cross-wood','gravestone-round','gravestone-wide','gravestone-cross','cross-column','gravestone-decorative'].forEach((g,i) => {
                defs.push({ path: 'assets/graveyard/'+g+'.glb', x: gx-4+(i%5)*2, y: 0, z: gz-4+Math.floor(i/5)*2, ry: Math.random()*0.3, scale: 1, label: 'Grave' });
            });
            // 2 Crypts
            defs.push({ path: 'assets/graveyard/crypt-large.glb', x: gx-4, y: 0, z: gz-5, ry: 0, scale: 1.1, label: 'Crypt' });
            defs.push({ path: 'assets/graveyard/crypt-large-roof.glb', x: gx-4, y: 1.1, z: gz-5, ry: 0, scale: 1.1, label: 'Crypt Roof' });
            defs.push({ path: 'assets/graveyard/crypt-a.glb', x: gx+3, y: 0, z: gz-5, ry: Math.PI/2, scale: 1, label: 'Crypt A' });
            // 5 graveyard characters
            defs.push({ path: 'assets/graveyard/character-ghost.glb', x: gx-2, y: 0, z: gz-1, ry: 0.5, scale: 0.5, label: 'Ghost' });
            defs.push({ path: 'assets/graveyard/character-skeleton.glb', x: gx+2, y: 0, z: gz-2, ry: -0.3, scale: 0.5, label: 'Skeleton' });
            defs.push({ path: 'assets/graveyard/character-vampire.glb', x: gx-4, y: 0, z: gz+2, ry: 0.8, scale: 0.5, label: 'Vampire' });
            defs.push({ path: 'assets/graveyard/character-zombie.glb', x: gx+4, y: 0, z: gz-4, ry: -0.5, scale: 0.5, label: 'Zombie' });
            defs.push({ path: 'assets/graveyard/character-keeper.glb', x: gx, y: 0, z: gz+7, ry: Math.PI, scale: 0.5, label: 'Keeper' });
            // Coffins, candles, pumpkins, shovels, altar
            defs.push({ path: 'assets/graveyard/coffin.glb', x: gx-3, y: 0, z: gz-3, ry: 0.3, scale: 1, label: 'Coffin' });
            defs.push({ path: 'assets/graveyard/coffin.glb', x: gx+3, y: 0, z: gz-6, ry: -0.4, scale: 1, label: 'Coffin' });
            defs.push({ path: 'assets/graveyard/candle-multiple.glb', x: gx-4, y: 0.5, z: gz-6, ry: 0, scale: 1, label: 'Candles' });
            defs.push({ path: 'assets/graveyard/pumpkin-carved.glb', x: gx+5, y: 0, z: gz+5, ry: 0, scale: 1, label: 'Pumpkin' });
            defs.push({ path: 'assets/graveyard/pumpkin-carved.glb', x: gx-5, y: 0, z: gz+5, ry: 0.5, scale: 1, label: 'Pumpkin' });
            defs.push({ path: 'assets/graveyard/shovel-dirt.glb', x: gx+2, y: 0, z: gz-7, ry: 0.8, scale: 1, label: 'Shovel' });
            defs.push({ path: 'assets/graveyard/altar-wood.glb', x: gx, y: 0, z: gz-6, ry: 0, scale: 1, label: 'Altar' });
            defs.push({ path: 'assets/graveyard/candle-multiple.glb', x: gx, y: 0.5, z: gz-6, ry: 0, scale: 1, label: 'Candles' });
            // Pine trees near graveyard
            ['pine','pine-crooked','pine-fall','pine-fall-crooked'].forEach((p,i) => {
                defs.push({ path: 'assets/graveyard/'+p+'.glb', x: gx-6+i*2, y: 0, z: gz-7, ry: i*1.2, scale: 1.1+i*0.1, label: 'Pine' });
            });

            // ===================================================
            // TRAINING GROUNDS (NE, x=50, z=-40)
            // ===================================================
            const tgx = 50, tgz = -40;
            defs.push({ path: 'assets/castle/siege-catapult.glb', x: tgx-5, y: 0, z: tgz, ry: Math.PI, scale: 1.3, label: 'Catapult' });
            defs.push({ path: 'assets/castle/siege-trebuchet.glb', x: tgx-2, y: 0, z: tgz-4, ry: Math.PI+0.3, scale: 1.3, label: 'Trebuchet' });
            defs.push({ path: 'assets/castle/siege-ballista.glb', x: tgx-6, y: 0, z: tgz-6, ry: Math.PI, scale: 1.3, label: 'Ballista' });
            defs.push({ path: 'assets/castle/siege-tower.glb', x: tgx+2, y: 0, z: tgz-2, ry: Math.PI, scale: 1.2, label: 'Siege Tower' });
            defs.push({ path: 'assets/castle/siege-ram.glb', x: tgx-1, y: 0, z: tgz+4, ry: Math.PI/2, scale: 1.2, label: 'Ram' });
            defs.push({ path: 'assets/castle/siege-catapult-demolished.glb', x: tgx+4, y: 0, z: tgz-5, ry: 0.5, scale: 1.2, label: 'Wreck' });
            defs.push({ path: 'assets/castle/siege-tower-demolished.glb', x: tgx+5, y: 0, z: tgz-1, ry: 0.8, scale: 1.1, label: 'Wreck' });
            for (let z = -6; z <= 2; z += 2) defs.push({ path: 'assets/castle/wall-narrow.glb', x: tgx-8, y: 0, z: tgz+z, ry: Math.PI/2, scale: 1, label: 'Barrier' });
            defs.push({ path: 'assets/graveyard/hay-bale.glb', x: tgx-4, y: 0, z: tgz-8, ry: 0, scale: 1.2, label: 'Target' });
            defs.push({ path: 'assets/graveyard/hay-bale-bundled.glb', x: tgx-2, y: 0, z: tgz-8, ry: 0.4, scale: 1.2, label: 'Target' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: tgx-8, y: 0, z: tgz+4, ry: 0, scale: 1, label: 'Torch' });
            defs.push({ path: 'assets/graveyard/fire-basket.glb', x: tgx, y: 0, z: tgz+4, ry: 0, scale: 1, label: 'Torch' });

            // ===================================================
            // ROADS â€” connected network
            // ===================================================
            // Castle 1 gate south to Village 1 (z=8 to z=24)
            for (let z = 8; z <= 24; z++) defs.push({ path: 'assets/graveyard/road.glb', x: 0, y: 0.005, z, ry: 0, scale: 1, label: 'Road' });
            // Castle 1 to Castle 2 (NW diagonal, step by step)
            for (let step = 0; step <= 30; step++) {
                const t = step / 30;
                const rx = Math.round(-30 * t);
                const rz = Math.round(-35 * t);
                defs.push({ path: 'assets/graveyard/road.glb', x: rx, y: 0.005, z: rz, ry: Math.PI/4, scale: 1, label: 'Road NW' });
            }
            // Castle 1 to Castle 3 (NE diagonal)
            for (let step = 0; step <= 30; step++) {
                const t = step / 30;
                const rx = Math.round(35 * t);
                const rz = Math.round(-30 * t);
                defs.push({ path: 'assets/graveyard/road.glb', x: rx, y: 0.005, z: rz, ry: -Math.PI/4, scale: 1, label: 'Road NE' });
            }
            // Castle 2 to Castle 3 (northern road)
            for (let step = 0; step <= 20; step++) {
                const t = step / 20;
                const rx = Math.round(-30 + 65 * t);
                const rz = Math.round(-35 + 5 * t);
                defs.push({ path: 'assets/graveyard/road.glb', x: rx, y: 0.005, z: rz, ry: Math.PI/2, scale: 1, label: 'Road C2-C3' });
            }
            // Road to graveyard (from Castle 2 area west)
            for (let x = -38; x >= -50; x--) defs.push({ path: 'assets/graveyard/road.glb', x, y: 0.005, z: -28, ry: Math.PI/2, scale: 1, label: 'Road GY' });
            // Road to training grounds (from Castle 3 east)
            for (let x = 40; x <= 50; x++) defs.push({ path: 'assets/graveyard/road.glb', x, y: 0.005, z: -38, ry: Math.PI/2, scale: 1, label: 'Road TG' });

            // ===================================================
            // BRIDGES â€” where roads cross rivers
            // ===================================================
            // Bridge on road Castle1->Castle2 crossing main river (~x=-14, z=-18)
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: -14, y: 0.1, z: -18, ry: Math.PI/4, scale: 1.3, label: 'Bridge' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: -14, y: -0.1, z: -18, ry: Math.PI/4, scale: 1.3, label: 'Bridge Pillar' });
            // Bridge on road Castle1->Castle3 crossing branch river (~x=12, z=-25)
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: 12, y: 0.1, z: -25, ry: -Math.PI/4, scale: 1.3, label: 'Bridge' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: 12, y: -0.1, z: -25, ry: -Math.PI/4, scale: 1.3, label: 'Bridge Pillar' });
            // Bridge on road C2->C3 crossing main river (~x=-8, z=-34)
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: -8, y: 0.1, z: -34, ry: Math.PI/2, scale: 1.3, label: 'Bridge' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: -8, y: -0.1, z: -34, ry: Math.PI/2, scale: 1.3, label: 'Bridge Pillar' });
            // Bridge on south road crossing main river (~x=0, z=8)
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: 0, y: 0.1, z: 10, ry: 0, scale: 1.3, label: 'Bridge S' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: 0, y: -0.1, z: 10, ry: 0, scale: 1.3, label: 'Bridge Pillar S' });
            // Bridge near Castle2 south gate crossing river
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: -30, y: 0.1, z: -29, ry: 0, scale: 1.1, label: 'Bridge C2' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: -30, y: -0.1, z: -29, ry: 0, scale: 1.1, label: 'Bridge Pillar C2' });
            // Bridge near Castle3 south gate crossing branch river
            defs.push({ path: 'assets/castle/bridge-straight.glb', x: 35, y: 0.1, z: -24, ry: 0, scale: 1.1, label: 'Bridge C3' });
            defs.push({ path: 'assets/castle/bridge-straight-pillar.glb', x: 35, y: -0.1, z: -24, ry: 0, scale: 1.1, label: 'Bridge Pillar C3' });

            // ===================================================
            // SCATTERED ROCKS, LOGS, TRUNKS
            // ===================================================
            const rockSpots = [
                {x:-11,z:3},{x:11,z:-3},{x:7,z:13},{x:-10,z:10},{x:13,z:4},{x:10,z:12},
                {x:-15,z:5},{x:15,z:8},{x:0,z:-12},{x:-5,z:22},{x:5,z:22},
                {x:-20,z:-5},{x:20,z:-5},{x:-18,z:15},{x:18,z:15},
                {x:-40,z:-10},{x:40,z:-10},{x:-35,z:5},{x:35,z:5},
            ];
            rockSpots.forEach(r => {
                defs.push({ path: Math.random()>0.5?'assets/castle/rocks-large.glb':'assets/castle/rocks-small.glb', x: r.x, y: 0, z: r.z, ry: Math.random()*Math.PI*2, scale: 0.8+Math.random()*0.5, label: 'Rocks' });
            });
            defs.push({ path: 'assets/castle/tree-log.glb', x: -10, y: 0, z: 8, ry: 0.8, scale: 1, label: 'Log' });
            defs.push({ path: 'assets/castle/tree-log.glb', x: 10, y: 0, z: -8, ry: 1.5, scale: 1, label: 'Log' });
            defs.push({ path: 'assets/castle/tree-trunk.glb', x: 10, y: 0, z: -12, ry: 1.2, scale: 1, label: 'Trunk' });
            defs.push({ path: 'assets/castle/tree-trunk.glb', x: -12, y: 0, z: 5, ry: 0.4, scale: 1, label: 'Trunk' });

            return defs;
        }

        placeModel(gltf, def) {
            const model = gltf.scene;
            model.position.set(def.x, def.y, def.z);
            model.rotation.y = def.ry || 0;
            if (def.scale && def.scale !== 1) {
                model.scale.setScalar(def.scale);
            }

            // Enable shadows + apply fallback colors if textures didn't load
            const castleColors = {
                'wall': 0xa89a85, 'tower': 0x9a8c78, 'gate': 0x8b7d6a,
                'door': 0x7a5c3a, 'bridge': 0x8b6f4e, 'stairs': 0x9a8c78,
                'flag': 0xcc3333, 'tree': 0x4a8a2e, 'rock': 0x7a7570,
                'siege': 0x8b6f4e, 'log': 0x6b5030, 'trunk': 0x5a4020,
            };
            const pathKey = (def.path || '').split('/').pop().replace('.glb', '');
            const colorKey = Object.keys(castleColors).find(k => pathKey.includes(k));
            const fallbackColor = castleColors[colorKey] || 0xa89a85;

            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    // If material has no map (texture didn't load), apply fallback color
                    if (child.material && !child.material.map) {
                        child.material = new THREE.MeshStandardMaterial({
                            color: fallbackColor,
                            roughness: 0.85,
                            metalness: 0.05,
                        });
                    }
                }
            });

            this.scene.add(model);
            return model;
        }

        async loadCharacters(updateProgress) {
            const agentDefs = [
                { id: 'ApoMac',   char: 'a', speed: 0.4 },
                { id: 'Forge',    char: 'b', speed: 0.7 },
                { id: 'Atlas',    char: 'c', speed: 0.6 },
                { id: 'Hunter',   char: 'd', speed: 1.0 },
                { id: 'Echo',     char: 'e', speed: 0.5 },
                { id: 'Sentinel', char: 'f', speed: 0.8 },
                { id: 'Mystic',   char: 'g', speed: 0.55 },
                { id: 'Smith',    char: 'h', speed: 0.65 },
            ];

            // Define patrol waypoints for each character (inside castle courtyard + around gate)
            // Courtyard bounds: x: -4 to 4, z: -4 to 4 (walls at Â±5)
            const waypoints = [
                // ApoMac â€” King, inner keep (Castle 1)
                [{x:0,z:0},{x:2,z:2},{x:-2,z:2},{x:-2,z:-2},{x:2,z:-2}],
                // Forge â€” Builder, outer courtyard (Castle 1)
                [{x:-5,z:-5},{x:-5,z:5},{x:5,z:5},{x:5,z:-5}],
                // Atlas â€” Navigator, outer perimeter (Castle 1)
                [{x:-5,z:0},{x:0,z:-5},{x:5,z:0},{x:0,z:4}],
                // Hunter â€” Scout, exits gate, patrols village (Castle 1)
                [{x:0,z:5},{x:0,z:8},{x:0,z:14},{x:3,z:18},{x:-3,z:20},{x:0,z:14},{x:0,z:8}],
                // Echo â€” Bard, inner courtyard (Castle 1)
                [{x:-2,z:1},{x:1,z:3},{x:3,z:0},{x:1,z:-3},{x:-1,z:-1}],
                // Sentinel â€” Guard, gatehouse (Castle 1)
                [{x:-2,z:5},{x:2,z:5},{x:2,z:3},{x:-2,z:3}],
                // Mystic â€” Wizard, circles keep (Castle 1)
                [{x:-3,z:-3},{x:3,z:-3},{x:3,z:3},{x:-3,z:3}],
                // Smith â€” near stables (Castle 1)
                [{x:4,z:4},{x:4,z:5},{x:5,z:5},{x:5,z:4}],
            ];

            for (let i = 0; i < agentDefs.length; i++) {
                const def = agentDefs[i];
                try {
                    const gltf = await this.loadModel(`assets/characters/character-${def.char}.glb`);
                    const model = gltf.scene;
                    model.scale.setScalar(0.25);

                    const wp = waypoints[i];
                    model.position.set(wp[0].x, 0, wp[0].z);

                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.userData.agentId = def.id;
                        }
                    });

                    // Create a group for the character (so we can add glow, etc.)
                    const group = new THREE.Group();
                    group.add(model);
                    group.position.copy(model.position);
                    model.position.set(0, 0, 0);
                    group.userData.agentId = def.id;
                    this.scene.add(group);

                    // Setup animation mixer for walk animation
                    let mixer = null;
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(model);
                        this.animationMixers.push(mixer);
                        // Find walk animation, fallback to idle
                        const walkClip = gltf.animations.find(a => a.name === 'walk') 
                            || gltf.animations.find(a => a.name === 'idle');
                        if (walkClip) {
                            const action = mixer.clipAction(walkClip);
                            action.play();
                            action.timeScale = 0.6 + def.speed * 0.8;
                        }
                    }

                    this.characterModels.set(def.id, {
                        group,
                        model,
                        mixer,
                        animations: gltf.animations || [],
                        waypoints: wp,
                        waypointIndex: 0,
                        nextWaypointIndex: 1,
                        speed: def.speed,
                        progress: 0,
                        pauseTimer: 0,
                        bobPhase: Math.random() * Math.PI * 2,
                        glowMesh: null,
                    });

                    // Create HTML label
                    const label = document.createElement('div');
                    label.className = 'character-label';
                    label.textContent = def.id;
                    document.getElementById('labels-container').appendChild(label);
                    this.labelElements.set(def.id, label);

                    updateProgress(`Character ${def.id}`);
                } catch (e) {
                    console.warn(`Failed to load character ${def.char}:`, e);
                    updateProgress(`(skipped) character-${def.char}`);
                }
            }
        }

        // â”€â”€ Animation Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        animate() {
            requestAnimationFrame(() => this.animate());

            const delta = this.clock.getDelta();
            const elapsed = this.clock.getElapsedTime();

            // Update controls
            this.controls.update();

            // Update animation mixers
            this.animationMixers.forEach(mixer => mixer.update(delta));

            // Animate characters
            this.animateCharacters(delta, elapsed);

            // Animate torch flicker
            this.animateTorches(elapsed);

            // Animate campfire
            this.animateCampfire(elapsed);

            // Update label positions
            this.updateLabels();

            // Render
            this.renderer.render(this.scene, this.camera);
        }

        animateCharacters(delta, elapsed) {
            this.characterModels.forEach((charData, agentId) => {
                const { group, waypoints, speed } = charData;

                // Handle waypoint pause
                if (charData.pauseTimer > 0) {
                    charData.pauseTimer -= delta;
                    return; // Wait at waypoint
                }

                // Move along waypoints
                const from = waypoints[charData.waypointIndex];
                const to = waypoints[charData.nextWaypointIndex];

                charData.progress += delta * speed * 0.3;

                if (charData.progress >= 1) {
                    // Snap exactly to target waypoint before resetting (prevents teleport frame-skip)
                    group.position.set(to.x, 0, to.z);
                    charData.progress = 0;
                    charData.waypointIndex = charData.nextWaypointIndex;
                    charData.nextWaypointIndex = (charData.nextWaypointIndex + 1) % waypoints.length;
                    // Small pause at each waypoint (0.3â€“0.5s)
                    charData.pauseTimer = 0.3 + Math.random() * 0.2;
                    return;
                }

                // Lerp position
                const t = this.smoothstep(charData.progress);
                const x = from.x + (to.x - from.x) * t;
                const z = from.z + (to.z - from.z) * t;

                group.position.set(x, 0, z);

                // Face direction of movement
                const dx = to.x - from.x;
                const dz = to.z - from.z;
                if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
                    const targetAngle = Math.atan2(dx, dz);
                    // Smooth rotation
                    let currentAngle = group.rotation.y;
                    let diff = targetAngle - currentAngle;
                    // Normalize
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    group.rotation.y += diff * Math.min(delta * 5, 1);
                }

                // Selected glow effect
                if (agentId === this.selectedAgent) {
                    if (!charData.glowMesh) {
                        this.addGlowToCharacter(charData);
                    }
                    if (charData.glowMesh) {
                        charData.glowMesh.material.opacity = 0.3 + Math.sin(elapsed * 4) * 0.15;
                    }
                } else if (charData.glowMesh) {
                    group.remove(charData.glowMesh);
                    charData.glowMesh.geometry.dispose();
                    charData.glowMesh.material.dispose();
                    charData.glowMesh = null;
                }
            });
        }

        smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        addGlowToCharacter(charData) {
            const glowGeo = new THREE.CylinderGeometry(0.6, 0.6, 2, 16, 1, true);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xe94560,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false,
            });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            glowMesh.position.y = 1;
            charData.group.add(glowMesh);
            charData.glowMesh = glowMesh;
        }

        animateTorches(elapsed) {
            if (!this.torchLights) return;
            this.torchLights.forEach((light, i) => {
                const flicker = 1 + Math.sin(elapsed * 8 + i * 2.5) * 0.15 + Math.sin(elapsed * 13 + i) * 0.1;
                light.intensity = (i < 2 ? 2 : 1.5) * flicker;
            });
        }

        updateLabels() {
            const container = document.getElementById('scene-container');
            const rect = container.getBoundingClientRect();

            this.characterModels.forEach((charData, agentId) => {
                const label = this.labelElements.get(agentId);
                if (!label) return;

                // Project 3D position to screen
                const pos = new THREE.Vector3();
                charData.group.getWorldPosition(pos);
                pos.y += 0.8; // Above character head (0.25x scale)

                const projected = pos.clone().project(this.camera);
                const x = (projected.x * 0.5 + 0.5) * rect.width;
                const y = (-projected.y * 0.5 + 0.5) * rect.height;

                label.style.left = x + 'px';
                label.style.top = y + 'px';

                // Show label if hovered or selected
                if (agentId === this.hoveredAgent) {
                    label.classList.add('visible');
                    label.classList.toggle('selected', agentId === this.selectedAgent);
                } else if (agentId === this.selectedAgent) {
                    label.classList.add('visible');
                    label.classList.add('selected');
                } else {
                    label.classList.remove('visible');
                    label.classList.remove('selected');
                }
            });
        }

        // â”€â”€ Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupEventListeners() {
            const container = document.getElementById('scene-container');

            // Click to select
            container.addEventListener('click', (e) => this.onSceneClick(e));

            // Hover
            container.addEventListener('mousemove', (e) => this.onSceneHover(e));

            // UI buttons
            document.getElementById('btn-toggle-sound').addEventListener('click', () => {
                this.soundEnabled = !this.soundEnabled;
                document.getElementById('btn-toggle-sound').textContent = this.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            });
            document.getElementById('btn-fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });
            document.getElementById('btn-reset-camera').addEventListener('click', () => {
                this.resetCamera();
            });
        }

        getMouseNDC(event) {
            const container = document.getElementById('scene-container');
            const rect = container.getBoundingClientRect();
            return new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
        }

        onSceneClick(event) {
            this.mouse = this.getMouseNDC(event);
            this.raycaster.setFromCamera(this.mouse, this.camera);

            // Collect all character meshes
            const charMeshes = [];
            this.characterModels.forEach((charData) => {
                charData.group.traverse((child) => {
                    if (child.isMesh) charMeshes.push(child);
                });
            });

            const intersects = this.raycaster.intersectObjects(charMeshes, false);
            if (intersects.length > 0) {
                // Find the agent ID
                let obj = intersects[0].object;
                while (obj && !obj.userData.agentId) obj = obj.parent;
                if (obj && obj.userData.agentId) {
                    this.selectAgent(obj.userData.agentId);
                    return;
                }
            }
        }

        onSceneHover(event) {
            this.mouse = this.getMouseNDC(event);
            this.raycaster.setFromCamera(this.mouse, this.camera);

            const charMeshes = [];
            this.characterModels.forEach((charData) => {
                charData.group.traverse((child) => {
                    if (child.isMesh) charMeshes.push(child);
                });
            });

            const intersects = this.raycaster.intersectObjects(charMeshes, false);
            let newHovered = null;
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj && !obj.userData.agentId) obj = obj.parent;
                if (obj) newHovered = obj.userData.agentId;
            }

            if (newHovered !== this.hoveredAgent) {
                this.hoveredAgent = newHovered;
                document.getElementById('scene-container').style.cursor = newHovered ? 'pointer' : '';
            }
        }

        resetCamera() {
            // Smooth reset to default isometric view
            const dist = 40;
            const azimuth = Math.PI / 4;
            const elevation = Math.atan(Math.sin(Math.PI / 4.2));

            this.camera.position.set(
                dist * Math.cos(elevation) * Math.sin(azimuth),
                dist * Math.sin(elevation),
                dist * Math.cos(elevation) * Math.cos(azimuth)
            );
            this.camera.zoom = 1;
            this.camera.updateProjectionMatrix();
            this.controls.target.set(0, 2, 0);
            this.controls.update();
        }

        // â”€â”€ Agent Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupAgents() {
            const defs = [
                { id: 'ApoMac',   role: 'CEO / King',     char: 'a', color: '#c9a959' },
                { id: 'Forge',    role: 'Builder',         char: 'b', color: '#f97316' },
                { id: 'Atlas',    role: 'Navigator',       char: 'c', color: '#3b82f6' },
                { id: 'Hunter',   role: 'Scout',           char: 'd', color: '#10b981' },
                { id: 'Echo',     role: 'Bard',            char: 'e', color: '#8b5cf6' },
                { id: 'Sentinel', role: 'Guard',           char: 'f', color: '#ef4444' },
                { id: 'Mystic',   role: 'Wizard',          char: 'g', color: '#7c3aed' },
                { id: 'Smith',    role: 'Blacksmith',      char: 'h', color: '#ea580c' },
            ];

            defs.forEach(d => {
                const status = Math.random() > 0.6 ? 'active' : Math.random() > 0.4 ? 'busy' : 'idle';
                const metrics = {
                    tasks: 1 + Math.floor(Math.random() * 15),
                    completed: Math.floor(Math.random() * 10),
                    success: Math.floor(50 + Math.random() * 50) + '%',
                    uptime: (90 + Math.random() * 10).toFixed(1) + 'h'
                };
                this.agents.set(d.id, { ...d, status, metrics });
            });
        }

        selectAgent(agentId) {
            // Deselect previous
            if (this.selectedAgent) {
                document.querySelector(`.courtyard-avatar[data-agent-id="${this.selectedAgent}"]`)?.classList.remove('selected');
                document.querySelector(`[data-agent="${this.selectedAgent}"]`)?.classList.remove('selected');
            }
            this.selectedAgent = agentId;

            // Highlight sidebar card
            const card = document.querySelector(`[data-agent="${agentId}"]`);
            if (card) {
                card.classList.add('selected');
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            this.playSound('select');
            this.addActivityLog(`Selected ${agentId}`, 'system');
        }

        // â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupAudio() {
            // Defer AudioContext creation to first user gesture to avoid Chrome warning
            const self = this;
            const initOnGesture = () => {
                if (self.audioContext) return;
                try { self._initAudioContext(); } catch(e) { self.soundEnabled = false; }
                document.removeEventListener('click', initOnGesture);
                document.removeEventListener('keydown', initOnGesture);
            };
            document.addEventListener('click', initOnGesture);
            document.addEventListener('keydown', initOnGesture);
        }

        _initAudioContext() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const tone = (dur, freq, decay, vol) => {
                    const sr = this.audioContext.sampleRate;
                    const buf = this.audioContext.createBuffer(1, dur * sr, sr);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = Math.sin(2 * Math.PI * freq * (i / sr)) * Math.exp(-(i / sr) * decay) * vol;
                    return buf;
                };
                this.sounds.set('select', tone(0.15, 600, 10, 0.2));
                this.sounds.set('horn', (() => {
                    const sr = this.audioContext.sampleRate;
                    const buf = this.audioContext.createBuffer(1, 1.2 * sr, sr);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) { const t = i / sr; d[i] = Math.sin(2 * Math.PI * 220 * t) * Math.sin(Math.PI * t / 1.2) * 0.3; }
                    return buf;
                })());
            } catch (e) { this.soundEnabled = false; }
        }

        playSound(name) {
            if (!this.soundEnabled || !this.audioContext || !this.sounds.has(name)) return;
            try {
                const s = this.audioContext.createBufferSource();
                s.buffer = this.sounds.get(name);
                s.connect(this.audioContext.destination);
                s.start();
            } catch (e) {}
        }

        // â”€â”€ Data Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        setupDataBridge() {
            if (typeof SpawnKit === 'undefined') { setTimeout(() => this.setupDataBridge(), 100); return; }
            if (SpawnKit.mode === 'demo') document.getElementById('demo-badge').style.display = 'block';
            SpawnKit.on('update', data => this.updateDashboard(data));
            if (SpawnKit.data) this.updateDashboard(SpawnKit.data);
        }

        updateDashboard(data) {
            this.updateAgentRoster(data.agents || []);
            const m = data.metrics || {};
            document.getElementById('stat-missions').textContent = m.missions || '12';
            document.getElementById('stat-completed').textContent = m.completed || '8';
            document.getElementById('stat-resources').textContent = m.resources || '2.4k';
            document.getElementById('stat-uptime').textContent = m.uptime || '99.8%';
            if (data.events) data.events.slice(-10).forEach(ev => this.addActivityLog(ev.message, ev.agent || 'system', ev.timestamp));
        }

        updateAgentRoster(agents) {
            const c = document.getElementById('agents-list');
            if (!agents.length) agents = Array.from(this.agents.entries()).map(([id, a]) => ({ id, name: id, role: a.role, status: a.status, metrics: a.metrics }));
            c.innerHTML = agents.map(a => {
                const d = this.agents.get(a.id);
                const st = a.status || 'idle';
                const emoji = { active: 'âš”ï¸', busy: 'ğŸ”¥', idle: 'ğŸ’¤', error: 'âš ï¸' }[st] || 'ğŸ’¤';
                return `<div class="agent-card${a.id === this.selectedAgent ? ' selected' : ''}" data-agent="${a.id}" onclick="window.castleApp.selectAgent('${a.id}')">
                    <div class="agent-header">
                        <div class="agent-avatar" style="background:${d?.color || '#555'}">
                            ${d ? `<img src="assets/characters/character-${d.char}.png">` : a.name.slice(0, 2)}
                        </div>
                        <div><div class="agent-name">${a.name}</div><div class="agent-role">${a.role || 'Knight'}</div></div>
                        <div class="agent-status"><div class="status-dot ${st}"></div><span>${emoji}</span></div>
                    </div>
                    <div class="agent-metrics">
                        <div class="metric-item"><span class="metric-label">Tasks</span><span class="metric-value">${a.metrics?.tasks || '-'}</span></div>
                        <div class="metric-item"><span class="metric-label">Done</span><span class="metric-value">${a.metrics?.completed || '-'}</span></div>
                        <div class="metric-item"><span class="metric-label">Win</span><span class="metric-value">${a.metrics?.success || '-'}</span></div>
                        <div class="metric-item"><span class="metric-label">Up</span><span class="metric-value">${a.metrics?.uptime || '-'}</span></div>
                    </div>
                </div>`;
            }).join('');
        }

        addActivityLog(msg, agent = 'system', ts = null) {
            const c = document.getElementById('activity-log');
            const time = ts ? new Date(ts) : new Date();
            const item = document.createElement('div');
            item.className = 'activity-item';
            item.innerHTML = `<div class="activity-time">${time.toLocaleTimeString()}</div><div class="activity-message">${agent !== 'system' ? `<span class="activity-agent">${agent}</span>: ` : ''}${msg}</div>`;
            c.insertBefore(item, c.firstChild);
            while (c.children.length > 20) c.removeChild(c.lastChild);
        }

        setupUI() {
            const msgs = [
                'Castle defenses initialized',
                'ApoMac completed strategic session',
                'Forge built new siege weapons',
                'Hunter scouted northern territories',
                'Echo composed victory ballad',
                'Sentinel: all towers secure',
                'Mystic enchanted castle walls',
                'Smith forged royal armor'
            ];
            msgs.forEach((m, i) => setTimeout(() => this.addActivityLog(m), i * 400));
            this.updateAgentRoster([]);
        }
    }

    // Initialize
    window.addEventListener('load', () => {
        const app = new MedievalCastle3D();
        window._app = app;
        window.castleApp = app;
    });
    </script>
</body>
</html>
