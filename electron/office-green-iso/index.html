<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SpawnKit HQ — Green Iso Office</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#1a1a2e; overflow:hidden; font-family:'Press Start 2P',monospace; }
  canvas { display:block; image-rendering:pixelated; image-rendering:crisp-edges; cursor:grab; }
  canvas.dragging { cursor:grabbing; }

  /* ─── Top Bar ─── */
  #topbar {
    position:fixed; top:0; left:0; right:0; height:36px; z-index:100;
    background:rgba(20,20,40,0.92); border-bottom:2px solid #3a5; display:flex;
    align-items:center; padding:0 12px; gap:12px;
  }
  #topbar .title { color:#5f8; font-size:10px; letter-spacing:2px; }
  #topbar .mode { color:#fa5; font-size:7px; padding:2px 6px; border:1px solid #fa5; border-radius:3px; }
  #topbar .sep { flex:1; }
  #topbar .zoom-info { color:#8ab; font-size:7px; }

  /* ─── Bottom Bar ─── */
  #bottombar {
    position:fixed; bottom:0; left:0; right:0; height:32px; z-index:100;
    background:rgba(20,20,40,0.92); border-top:2px solid #3a5; display:flex;
    align-items:center; padding:0 12px; gap:16px; font-size:7px; color:#8ab;
  }
  .stat { display:flex; align-items:center; gap:4px; }
  .stat .dot { width:6px; height:6px; border-radius:50%; }
  .dot-green { background:#5f8; }
  .dot-yellow { background:#fd5; }
  .dot-red { background:#f55; }

  /* ─── Agent Detail Panel ─── */
  #agent-panel {
    position:fixed; top:36px; right:0; width:280px; bottom:32px; z-index:99;
    background:rgba(20,20,40,0.95); border-left:2px solid #3a5;
    transform:translateX(100%); transition:transform .3s ease;
    padding:16px; overflow-y:auto; color:#cde;
  }
  #agent-panel.open { transform:translateX(0); }
  #agent-panel h2 { font-size:10px; color:#5f8; margin-bottom:8px; }
  #agent-panel .role { font-size:7px; color:#fa5; margin-bottom:12px; }
  #agent-panel .field { font-size:7px; margin-bottom:6px; line-height:1.6; }
  #agent-panel .field label { color:#8ab; }
  #agent-panel .close-btn {
    position:absolute; top:8px; right:8px; background:none; border:1px solid #f55;
    color:#f55; font-size:8px; cursor:pointer; padding:2px 6px; font-family:inherit;
  }
  #agent-panel .task-list { margin-top:8px; }
  #agent-panel .task { font-size:6px; color:#acd; padding:4px; background:rgba(50,70,50,0.3); margin-bottom:3px; border-left:2px solid #3a5; }
</style>
</head>
<body>

<div id="topbar">
  <span class="title">⚔ SPAWNKIT HQ</span>
  <span class="mode" id="mode-badge">DEMO</span>
  <span class="sep"></span>
  <span class="zoom-info" id="zoom-info">100%</span>
</div>

<canvas id="game"></canvas>

<div id="bottombar">
  <div class="stat"><div class="dot dot-green"></div><span id="stat-agents">0 agents</span></div>
  <div class="stat"><div class="dot dot-yellow"></div><span id="stat-missions">0 missions</span></div>
  <div class="stat"><div class="dot dot-red"></div><span id="stat-subagents">0 sub-agents</span></div>
  <span style="flex:1"></span>
  <span id="stat-time" style="color:#5f8"></span>
</div>

<div id="agent-panel">
  <button class="close-btn" onclick="closePanel()">✕</button>
  <h2 id="panel-name">—</h2>
  <div class="role" id="panel-role">—</div>
  <div class="field"><label>Status: </label><span id="panel-status">—</span></div>
  <div class="field"><label>Session: </label><span id="panel-session">—</span></div>
  <div class="field"><label>Current Task: </label></div>
  <div class="task-list" id="panel-tasks"></div>
</div>

<!-- Data Bridge -->
<script src="../src/data-bridge.js"></script>

<script>
'use strict';

// ═══════════════════════════════════════════════════════════════════
// CONFIG
// ═══════════════════════════════════════════════════════════════════
const TILE = 16;           // base tile size in sprite pixels
const SCALE = 2;           // render scale (pixel-perfect 2x)
const T = TILE * SCALE;    // rendered tile size = 32px
const FPS_ANIM = 8;        // sprite animation FPS
const MOVE_SPEED = 1.2;    // tiles per second for agent movement

const ASSETS = 'assets/';

// ═══════════════════════════════════════════════════════════════════
// MAP DEFINITION  (tile coords — each unit = 1 tile = 16px source)
// The office is 30 tiles wide × 38 tiles tall + 4-tile outdoor border
// ═══════════════════════════════════════════════════════════════════

const MAP_W = 38;  // total map width in tiles
const MAP_H = 46;  // total map height in tiles

// Room definitions: {x, y, w, h} in tile coords (interior, walls excluded)
const ROOMS = {
  ceoOffice:    { x:5,  y:5,  w:12, h:8,  label:'CEO Office',    floor:'wood' },
  ctoLab:       { x:18, y:5,  w:12, h:8,  label:'CTO Lab',       floor:'stone' },
  cooOffice:    { x:5,  y:14, w:12, h:8,  label:'COO Office',    floor:'wood' },
  croOffice:    { x:18, y:14, w:12, h:8,  label:'CRO Office',    floor:'wood' },
  cmoStudio:    { x:5,  y:23, w:12, h:8,  label:'CMO Studio',    floor:'wood' },
  auditorPost:  { x:18, y:23, w:12, h:8,  label:'Auditor Post',  floor:'stone' },
  meetingRoom:  { x:5,  y:32, w:25, h:5,  label:'Meeting Room',  floor:'stone' },
  breakRoom:    { x:5,  y:38, w:12, h:5,  label:'Break Room',    floor:'wood' },
  openSpace:    { x:18, y:38, w:12, h:5,  label:'Open Space',    floor:'wood' },
};

// Door positions (tile x, y on wall edge)
const DOORS = [
  // Vertical doors (between left and right rooms)
  {x:17, y:8,  dir:'v'},  // CEO <-> CTO
  {x:17, y:17, dir:'v'},  // COO <-> CRO
  {x:17, y:26, dir:'v'},  // CMO <-> Auditor
  // Horizontal doors (between rows)
  {x:10, y:13, dir:'h'},  // CEO -> COO
  {x:24, y:13, dir:'h'},  // CTO -> CRO
  {x:10, y:22, dir:'h'},  // COO -> CMO
  {x:24, y:22, dir:'h'},  // CRO -> Auditor
  {x:10, y:31, dir:'h'},  // CMO -> Meeting
  {x:24, y:31, dir:'h'},  // Auditor -> Meeting
  {x:10, y:37, dir:'h'},  // Meeting -> Break
  {x:24, y:37, dir:'h'},  // Meeting -> Open
  {x:17, y:40, dir:'v'},  // Break <-> Open
];

// ═══════════════════════════════════════════════════════════════════
// IMAGE LOADER
// ═══════════════════════════════════════════════════════════════════
const imageCache = {};
let loadedCount = 0;
let totalImages = 0;

function loadImage(path) {
  if (imageCache[path]) return imageCache[path];
  totalImages++;
  const img = new Image();
  img.src = ASSETS + path;
  img.onload = () => { loadedCount++; };
  img.onerror = () => { console.warn('Failed to load:', path); loadedCount++; };
  imageCache[path] = img;
  return img;
}

// ═══════════════════════════════════════════════════════════════════
// SPRITE SHEET DEFINITIONS
// ═══════════════════════════════════════════════════════════════════

// NPC sprites: Knight, Wizzard, Rogue — Idle 128×32 (4×32), Run 384×64 (6×64)
// Body_A: Idle 256×64 (4×64), Walk/Run 384×64 (6×64)
// Mobs: same as NPC format (Idle 128×32, Run 384×64)
// Skeleton-Mage: same format

const SPRITE_DEFS = {
  knight: {
    idle:  { path:"Entities/Npc's/Knight/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Npc's/Knight/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Npc's/Knight/Death/Death-Sheet.png", fw:32, fh:32, frames:9 },
  },
  wizzard: {
    idle:  { path:"Entities/Npc's/Wizzard/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Npc's/Wizzard/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Npc's/Wizzard/Death/Death-Sheet.png", fw:32, fh:32, frames:12 },
  },
  rogue: {
    idle:  { path:"Entities/Npc's/Rogue/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Npc's/Rogue/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Npc's/Rogue/Death/Death-Sheet.png", fw:32, fh:32, frames:12 },
  },
  bodyA_down: {
    idle:  { path:"Entities/Characters/Body_A/Animations/Idle_Base/Idle_Down-Sheet.png",  fw:64, fh:64, frames:4 },
    walk:  { path:"Entities/Characters/Body_A/Animations/Walk_Base/Walk_Down-Sheet.png",  fw:64, fh:64, frames:6 },
    run:   { path:"Entities/Characters/Body_A/Animations/Run_Base/Run_Down-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Characters/Body_A/Animations/Death_Base/Death_Down-Sheet.png", fw:64, fh:64, frames:4 },
  },
  bodyA_side: {
    idle:  { path:"Entities/Characters/Body_A/Animations/Idle_Base/Idle_Side-Sheet.png",  fw:64, fh:64, frames:4 },
    walk:  { path:"Entities/Characters/Body_A/Animations/Walk_Base/Walk_Side-Sheet.png",  fw:64, fh:64, frames:6 },
    run:   { path:"Entities/Characters/Body_A/Animations/Run_Base/Run_Side-Sheet.png",    fw:64, fh:64, frames:6 },
  },
  skeletonMage: {
    idle:  { path:"Entities/Mobs/Skeleton Crew/Skeleton - Mage/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Mobs/Skeleton Crew/Skeleton - Mage/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Mobs/Skeleton Crew/Skeleton - Mage/Death/Death-Sheet.png", fw:64, fh:64, frames:6 },
  },
  orc: {
    idle:  { path:"Entities/Mobs/Orc Crew/Orc/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Mobs/Orc Crew/Orc/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Mobs/Orc Crew/Orc/Death/Death-Sheet.png", fw:64, fh:64, frames:6 },
  },
  orcWarrior: {
    idle:  { path:"Entities/Mobs/Orc Crew/Orc - Warrior/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Mobs/Orc Crew/Orc - Warrior/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Mobs/Orc Crew/Orc - Warrior/Death/Death-Sheet.png", fw:64, fh:64, frames:6 },
  },
  orcShaman: {
    idle:  { path:"Entities/Mobs/Orc Crew/Orc - Shaman/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Mobs/Orc Crew/Orc - Shaman/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Mobs/Orc Crew/Orc - Shaman/Death/Death-Sheet.png", fw:64, fh:64, frames:6 },
  },
  orcRogue: {
    idle:  { path:"Entities/Mobs/Orc Crew/Orc - Rogue/Idle/Idle-Sheet.png",  fw:32, fh:32, frames:4 },
    run:   { path:"Entities/Mobs/Orc Crew/Orc - Rogue/Run/Run-Sheet.png",    fw:64, fh:64, frames:6 },
    death: { path:"Entities/Mobs/Orc Crew/Orc - Rogue/Death/Death-Sheet.png", fw:64, fh:64, frames:6 },
  },
};

// Preload all sprite sheets
for (const char of Object.values(SPRITE_DEFS)) {
  for (const anim of Object.values(char)) {
    loadImage(anim.path);
  }
}

// Environment images
const IMG = {
  floorTiles:   loadImage('Environment/Tilesets/Floors_Tiles.png'),
  wallTiles:    loadImage('Environment/Tilesets/Wall_Tiles.png'),
  wallVariations: loadImage('Environment/Tilesets/Wall_Variations.png'),
  furniture:    loadImage('Environment/Props/Static/Furniture.png'),
  vegetation:   loadImage('Environment/Props/Static/Vegetation.png'),
  tree1:        loadImage('Environment/Props/Static/Trees/Model_01/Size_03.png'),
  tree2:        loadImage('Environment/Props/Static/Trees/Model_02/Size_03.png'),
  tree3:        loadImage('Environment/Props/Static/Trees/Model_03/Size_02.png'),
  buildWalls:   loadImage('Environment/Structures/Buildings/Walls.png'),
  buildFloors:  loadImage('Environment/Structures/Buildings/Floors.png'),
  buildProps:   loadImage('Environment/Structures/Buildings/Props.png'),
  workbench:    loadImage('Environment/Structures/Stations/Workbench/Workbench.png'),
  alchemy:      loadImage('Environment/Structures/Stations/Alchemy/Alchemy_Table_03-Sheet.png'),
  bonfire:      loadImage('Environment/Structures/Stations/Bonfire/Bonfire.png'),
  cookStation:  loadImage('Environment/Structures/Stations/Cooking Station/Cooking Station.png'),
  rocks:        loadImage('Environment/Props/Static/Rocks.png'),
  shadows:      loadImage('Environment/Props/Static/Shadows.png'),
};

// ═══════════════════════════════════════════════════════════════════
// CANVAS & CAMERA
// ═══════════════════════════════════════════════════════════════════
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let camX = 0, camY = 0;
let zoom = 2;
let isDragging = false;
let dragStartX, dragStartY, dragCamX, dragCamY;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Center camera on building
camX = -(MAP_W * T / 2) + canvas.width / (2 * zoom);
camY = -(MAP_H * T / 2) + canvas.height / (2 * zoom);

// Pan
canvas.addEventListener('mousedown', e => {
  if (e.button === 0) {
    isDragging = true;
    canvas.classList.add('dragging');
    dragStartX = e.clientX; dragStartY = e.clientY;
    dragCamX = camX; dragCamY = camY;
  }
});
window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  camX = dragCamX + (e.clientX - dragStartX) / zoom;
  camY = dragCamY + (e.clientY - dragStartY) / zoom;
});
window.addEventListener('mouseup', () => {
  isDragging = false;
  canvas.classList.remove('dragging');
});

// Zoom
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldZoom = zoom;
  zoom *= e.deltaY < 0 ? 1.15 : 0.87;
  zoom = Math.max(0.5, Math.min(6, zoom));
  // Zoom toward mouse
  const mx = e.clientX, my = e.clientY;
  camX += mx / zoom - mx / oldZoom;
  camY += my / zoom - my / oldZoom;
  document.getElementById('zoom-info').textContent = Math.round(zoom * 100) + '%';
}, { passive: false });

// ═══════════════════════════════════════════════════════════════════
// TILE MAP & COLLISION
// ═══════════════════════════════════════════════════════════════════

// Map layers: 0=empty/outdoor, 1=floor, 2=wall
const tileMap = [];
for (let y = 0; y < MAP_H; y++) {
  tileMap[y] = new Uint8Array(MAP_W); // all 0 = outdoor/grass
}

// Fill rooms with floor
for (const room of Object.values(ROOMS)) {
  for (let dy = 0; dy < room.h; dy++) {
    for (let dx = 0; dx < room.w; dx++) {
      tileMap[room.y + dy][room.x + dx] = 1;
    }
  }
}

// Mark walls (1-tile border around rooms)
function markWalls() {
  for (const room of Object.values(ROOMS)) {
    // Top and bottom walls
    for (let dx = -1; dx <= room.w; dx++) {
      const wx = room.x + dx;
      if (wx >= 0 && wx < MAP_W) {
        if (room.y - 1 >= 0 && tileMap[room.y - 1][wx] === 0) tileMap[room.y - 1][wx] = 2;
        if (room.y + room.h < MAP_H && tileMap[room.y + room.h][wx] === 0) tileMap[room.y + room.h][wx] = 2;
      }
    }
    // Left and right walls
    for (let dy = -1; dy <= room.h; dy++) {
      const wy = room.y + dy;
      if (wy >= 0 && wy < MAP_H) {
        if (room.x - 1 >= 0 && tileMap[wy][room.x - 1] === 0) tileMap[wy][room.x - 1] = 2;
        if (room.x + room.w < MAP_W && tileMap[wy][room.x + room.w] === 0) tileMap[wy][room.x + room.w] = 2;
      }
    }
  }
  // Clear door tiles
  for (const d of DOORS) {
    tileMap[d.y][d.x] = 1;
    if (d.dir === 'h') { if (d.x+1 < MAP_W) tileMap[d.y][d.x+1] = 1; }
    else { if (d.y+1 < MAP_H) tileMap[d.y+1][d.x] = 1; }
  }
}
markWalls();

function isWalkable(tx, ty) {
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return false;
  return tileMap[ty][tx] === 1;
}

// ═══════════════════════════════════════════════════════════════════
// A* PATHFINDER
// ═══════════════════════════════════════════════════════════════════
function findPath(sx, sy, ex, ey) {
  sx = Math.round(sx); sy = Math.round(sy);
  ex = Math.round(ex); ey = Math.round(ey);
  if (!isWalkable(ex, ey)) return null;
  if (sx === ex && sy === ey) return [];

  const open = [{ x:sx, y:sy, g:0, h:0, f:0, parent:null }];
  const closed = new Set();
  const key = (x,y) => y * MAP_W + x;

  const gScores = new Map();
  gScores.set(key(sx,sy), 0);

  while (open.length > 0) {
    open.sort((a,b) => a.f - b.f);
    const cur = open.shift();
    if (cur.x === ex && cur.y === ey) {
      const path = [];
      let n = cur;
      while (n.parent) { path.unshift({x:n.x, y:n.y}); n = n.parent; }
      return path;
    }
    closed.add(key(cur.x, cur.y));

    for (const [dx,dy] of [[0,-1],[0,1],[-1,0],[1,0],[-1,-1],[-1,1],[1,-1],[1,1]]) {
      const nx = cur.x + dx, ny = cur.y + dy;
      if (!isWalkable(nx, ny)) continue;
      const k = key(nx, ny);
      if (closed.has(k)) continue;
      // Diagonal check — don't cut corners
      if (dx !== 0 && dy !== 0) {
        if (!isWalkable(cur.x + dx, cur.y) || !isWalkable(cur.x, cur.y + dy)) continue;
      }
      const g = cur.g + (dx !== 0 && dy !== 0 ? 1.414 : 1);
      if (gScores.has(k) && g >= gScores.get(k)) continue;
      gScores.set(k, g);
      const h = Math.abs(nx - ex) + Math.abs(ny - ey);
      open.push({ x:nx, y:ny, g, h, f:g+h, parent:cur });
    }
  }
  return null; // no path
}

// ═══════════════════════════════════════════════════════════════════
// AGENT SYSTEM
// ═══════════════════════════════════════════════════════════════════

const ORC_SPRITES = ['orc', 'orcWarrior', 'orcShaman', 'orcRogue'];
let orcSpriteIdx = 0;

class Agent {
  constructor(id, name, role, spriteKey, room, color) {
    this.id = id;
    this.name = name;
    this.role = role;
    this.spriteKey = spriteKey;
    this.room = room;
    this.color = color;
    this.status = 'idle'; // idle, working, walking, brainstorm, dead
    this.currentTask = '';
    this.session = '';

    // Position (in tile coords, float)
    const r = ROOMS[room];
    this.x = r.x + Math.floor(r.w / 2);
    this.y = r.y + Math.floor(r.h / 2);
    this.targetX = this.x;
    this.targetY = this.y;
    this.path = [];
    this.pathIdx = 0;

    // Animation
    this.animState = 'idle'; // idle, run, death, walk
    this.animFrame = 0;
    this.animTimer = 0;
    this.facingLeft = false;
    this.deathDone = false;

    // Tint color (for distinguishing similar sprites)
    this.tintColor = null;

    // Speech bubble
    this.speechText = '';
    this.speechTimer = 0;
  }

  moveTo(tx, ty) {
    const path = findPath(Math.round(this.x), Math.round(this.y), tx, ty);
    if (path && path.length > 0) {
      this.path = path;
      this.pathIdx = 0;
      this.animState = this.spriteKey.startsWith('bodyA') ? 'walk' : 'run';
      this.status = 'walking';
    }
  }

  moveToRoom(roomId) {
    const r = ROOMS[roomId];
    if (!r) return;
    this.room = roomId;
    const tx = r.x + 1 + Math.floor(Math.random() * (r.w - 2));
    const ty = r.y + 1 + Math.floor(Math.random() * (r.h - 2));
    this.moveTo(tx, ty);
  }

  say(text, duration) {
    this.speechText = text;
    this.speechTimer = duration || 3;
  }

  update(dt) {
    // Animation frame
    this.animTimer += dt;
    if (this.animTimer >= 1 / FPS_ANIM) {
      this.animTimer -= 1 / FPS_ANIM;
      const spriteDef = SPRITE_DEFS[this.spriteKey];
      const anim = spriteDef[this.animState] || spriteDef.idle;
      this.animFrame = (this.animFrame + 1) % anim.frames;
      if (this.animState === 'death' && this.animFrame === anim.frames - 1) {
        this.deathDone = true;
      }
    }

    // Path following
    if (this.path.length > 0 && this.pathIdx < this.path.length) {
      const target = this.path[this.pathIdx];
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      if (dist < 0.15) {
        this.x = target.x;
        this.y = target.y;
        this.pathIdx++;
        if (this.pathIdx >= this.path.length) {
          this.path = [];
          this.animState = 'idle';
          this.animFrame = 0;
          this.status = this.status === 'walking' ? 'idle' : this.status;
        }
      } else {
        const speed = MOVE_SPEED * dt;
        this.x += (dx / dist) * Math.min(speed, dist);
        this.y += (dy / dist) * Math.min(speed, dist);
        this.facingLeft = dx < 0;
      }
    }

    // Speech timer
    if (this.speechTimer > 0) {
      this.speechTimer -= dt;
      if (this.speechTimer <= 0) this.speechText = '';
    }
  }

  draw(ctx) {
    const spriteDef = SPRITE_DEFS[this.spriteKey];
    if (!spriteDef) return;
    const anim = spriteDef[this.animState] || spriteDef.idle;
    const img = imageCache[anim.path];
    if (!img || !img.complete) return;

    const sx = this.animFrame * anim.fw;
    const sy = 0;
    const drawW = anim.fw * SCALE;
    const drawH = anim.fh * SCALE;
    // Center sprite on tile position
    const px = this.x * T - drawW / 2 + T / 2;
    const py = this.y * T - drawH + T;

    ctx.save();
    if (this.facingLeft) {
      ctx.translate(px + drawW, py);
      ctx.scale(-1, 1);
      ctx.drawImage(img, sx, sy, anim.fw, anim.fh, 0, 0, drawW, drawH);
      // Apply tint overlay
      if (this.tintColor) {
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = this.tintColor;
        ctx.fillRect(0, 0, drawW, drawH);
        ctx.globalCompositeOperation = 'source-over';
      }
    } else {
      ctx.drawImage(img, sx, sy, anim.fw, anim.fh, px, py, drawW, drawH);
      // Apply tint overlay
      if (this.tintColor) {
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = this.tintColor;
        ctx.fillRect(px, py, drawW, drawH);
        ctx.globalCompositeOperation = 'source-over';
      }
    }
    ctx.restore();

    // Status indicator (plumbob-style diamond)
    const indicatorX = this.x * T + T / 2;
    const indicatorY = py - 6;
    const colors = { idle:'#fd5', working:'#5f8', walking:'#5bf', brainstorm:'#d5f', dead:'#f55', error:'#f55' };
    const col = colors[this.status] || '#fff';

    ctx.save();
    ctx.translate(indicatorX, indicatorY);
    // Bobbing animation
    const bob = Math.sin(Date.now() / 300 + this.x) * 2;
    ctx.translate(0, bob);
    // Diamond shape
    ctx.beginPath();
    ctx.moveTo(0, -5);
    ctx.lineTo(4, 0);
    ctx.lineTo(0, 5);
    ctx.lineTo(-4, 0);
    ctx.closePath();
    ctx.fillStyle = col;
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // Name label with pill background
    ctx.save();
    ctx.font = '8px "Press Start 2P"';
    ctx.textAlign = 'center';
    const nameW = ctx.measureText(this.name).width;
    const pillX = indicatorX - nameW / 2 - 4;
    const pillY = indicatorY - 18;
    const pillW = nameW + 8;
    const pillH = 12;
    // Pill background
    ctx.fillStyle = 'rgba(10,10,25,0.75)';
    roundRect(ctx, pillX, pillY, pillW, pillH, 4);
    ctx.fill();
    // Pill border in agent color
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 1;
    roundRect(ctx, pillX, pillY, pillW, pillH, 4);
    ctx.stroke();
    // Name text
    ctx.fillStyle = '#fff';
    ctx.fillText(this.name, indicatorX, indicatorY - 9);
    ctx.restore();

    // Speech bubble
    if (this.speechText) {
      this.drawSpeechBubble(ctx, indicatorX, indicatorY - 24, this.speechText);
    }
  }

  drawSpeechBubble(ctx, bx, by, text) {
    ctx.save();
    ctx.font = '6px "Press Start 2P"';
    const lines = this.wrapText(ctx, text, 100);
    const lineH = 9;
    const padX = 6, padY = 4;
    const bw = Math.max(...lines.map(l => ctx.measureText(l).width)) + padX * 2;
    const bh = lines.length * lineH + padY * 2;
    const rx = bx - bw / 2;
    const ry = by - bh;

    // Bubble background
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    roundRect(ctx, rx, ry, bw, bh, 3);
    ctx.fill();
    ctx.stroke();

    // Tail
    ctx.beginPath();
    ctx.moveTo(bx - 3, by);
    ctx.lineTo(bx, by + 5);
    ctx.lineTo(bx + 3, by);
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.fill();

    // Text
    ctx.fillStyle = '#222';
    ctx.textAlign = 'left';
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], rx + padX, ry + padY + lineH * (i + 0.7));
    }
    ctx.restore();
  }

  wrapText(ctx, text, maxW) {
    const words = text.split(' ');
    const lines = [];
    let line = '';
    for (const w of words) {
      const test = line ? line + ' ' + w : w;
      if (ctx.measureText(test).width > maxW && line) {
        lines.push(line);
        line = w;
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);
    return lines.length ? lines : [''];
  }

  containsPoint(px, py) {
    const spriteDef = SPRITE_DEFS[this.spriteKey];
    const anim = spriteDef[this.animState] || spriteDef.idle;
    const drawW = anim.fw * SCALE;
    const drawH = anim.fh * SCALE;
    const sx = this.x * T - drawW / 2 + T / 2;
    const sy = this.y * T - drawH + T;
    return px >= sx && px < sx + drawW && py >= sy && py < sy + drawH;
  }
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ═══════════════════════════════════════════════════════════════════
// CORE AGENTS (C-Level)
// ═══════════════════════════════════════════════════════════════════
const agents = [];

const coreAgents = [
  { id:'apomac',   name:'ApoMac',   role:'CEO',     sprite:'knight',       room:'ceoOffice',   color:'#ffd700', tintColor:null },
  { id:'forge',    name:'Forge',    role:'CTO',     sprite:'wizzard',      room:'ctoLab',      color:'#7b68ee', tintColor:null },
  { id:'hunter',   name:'Hunter',   role:'CRO',     sprite:'rogue',        room:'croOffice',   color:'#ff6347', tintColor:null },
  { id:'atlas',    name:'Atlas',    role:'COO',     sprite:'bodyA_down',   room:'cooOffice',   color:'#20b2aa', tintColor:'rgba(0,180,180,0.25)' },
  { id:'echo',     name:'Echo',     role:'CMO',     sprite:'bodyA_side',   room:'cmoStudio',   color:'#dda0dd', tintColor:'rgba(200,100,220,0.25)' },
  { id:'sentinel', name:'Sentinel', role:'Auditor', sprite:'skeletonMage', room:'auditorPost', color:'#b0c4de', tintColor:null },
];

for (const def of coreAgents) {
  const a = new Agent(def.id, def.name, def.role, def.sprite, def.room, def.color);
  a.tintColor = def.tintColor;
  agents.push(a);
}

// Sub-agent pool
const subAgents = [];

// Map parent agent IDs to tint colors for sub-agents
const PARENT_TINT = {
  apomac:   'rgba(255,215,0,0.2)',
  forge:    'rgba(123,104,238,0.2)',
  hunter:   'rgba(255,99,71,0.2)',
  atlas:    'rgba(0,180,180,0.2)',
  echo:     'rgba(200,100,220,0.2)',
  sentinel: 'rgba(176,196,222,0.2)',
};

function spawnSubAgent(name, parentId) {
  const sprite = ORC_SPRITES[orcSpriteIdx % ORC_SPRITES.length];
  orcSpriteIdx++;
  const sa = new Agent('sub_' + Date.now(), name, 'Sub-Agent', sprite, 'openSpace', '#9acd32');
  sa.tintColor = PARENT_TINT[parentId] || null;
  sa.status = 'working';
  sa.say('Spawned!', 2);
  // Walk in from edge
  sa.x = ROOMS.openSpace.x;
  sa.y = ROOMS.openSpace.y + ROOMS.openSpace.h - 1;
  sa.moveToRoom('openSpace');
  subAgents.push(sa);
  agents.push(sa);
  return sa;
}

function despawnSubAgent(sa) {
  sa.status = 'dead';
  sa.animState = 'death';
  sa.animFrame = 0;
  // Remove after death animation
  setTimeout(() => {
    const idx = agents.indexOf(sa);
    if (idx > -1) agents.splice(idx, 1);
    const sidx = subAgents.indexOf(sa);
    if (sidx > -1) subAgents.splice(sidx, 1);
  }, 2000);
}

// ═══════════════════════════════════════════════════════════════════
// FURNITURE PLACEMENT
// Each furniture item: { img, sx, sy, sw, sh, tx, ty, tw, th }
// (source rect from sprite sheet → placed at tile position with tile size)
// Furniture.png = 800×864, 16px grid = 50×54 tiles
// Actual layout (verified with pixel analysis):
//   Rows 0-12: Large piece (left cols 0-5), small items (right cols 45-49)
//   Rows 17-19: Row of 2-tile-wide items (tables/desks) at cols 0-15 (8 items)
//   Rows 20-23: More 2-tile items + 4-tile wide at cols 8-11
//   Rows 24-29: Varied items (shelves, cabinets, chests)
//   Rows 30-45: More props (barrels, crates, small items)
// ═══════════════════════════════════════════════════════════════════
const furnitureItems = [];

function placeFurniture() {
  const F = IMG.furniture;

  // Helper: place a furniture sprite from the sheet
  // sx,sy in 16px tile units on the sheet; sw,sh in tiles; tx,ty map position
  function add(sheetTx, sheetTy, sw, sh, mapTx, mapTy) {
    furnitureItems.push({
      img: F,
      sx: sheetTx * 16, sy: sheetTy * 16,
      sw: sw * 16, sh: sh * 16,
      tx: mapTx, ty: mapTy,
      tw: sw, th: sh
    });
  }

  // ── CEO Office — Grand desk, bookshelf, plant, trophy ──
  // Large desk (rows 17-19, cols 0-1: 2x3 table variant A)
  add(0, 17, 2, 3, ROOMS.ceoOffice.x + 5, ROOMS.ceoOffice.y + 2);
  // Chair (rows 17-19, cols 6-7: chair variant)
  add(6, 17, 2, 3, ROOMS.ceoOffice.x + 5, ROOMS.ceoOffice.y + 5);
  // Large bookshelf (rows 0-12, cols 0-3: the big piece — use top 5x4 section)
  add(0, 0, 4, 5, ROOMS.ceoOffice.x + 9, ROOMS.ceoOffice.y + 1);
  // Plant (vegetation sheet — bush at row 2-3, cols 0-2)
  furnitureItems.push({
    img: IMG.vegetation,
    sx: 0, sy: 2*16, sw: 3*16, sh: 2*16,
    tx: ROOMS.ceoOffice.x + 1, ty: ROOMS.ceoOffice.y + 1,
    tw: 2, th: 2
  });

  // ── CTO Lab — Alchemy station, potions, books scattered ──
  furnitureItems.push({
    img: IMG.alchemy,
    sx: 0, sy: 0, sw: 400, sh: 400,
    tx: ROOMS.ctoLab.x + 4, ty: ROOMS.ctoLab.y + 2,
    tw: 3, th: 3,
    isStation: true
  });
  // Workbench (side station)
  furnitureItems.push({
    img: IMG.workbench,
    sx: 0, sy: 0, sw: 192, sh: 64,
    tx: ROOMS.ctoLab.x + 8, ty: ROOMS.ctoLab.y + 1,
    tw: 3, th: 2,
    isStation: true
  });
  // Small item (rows 26-27, cols 9-10: potions/vials)
  add(9, 26, 2, 2, ROOMS.ctoLab.x + 1, ROOMS.ctoLab.y + 5);
  // Books (rows 34-36, cols 1-3: scattered books/scrolls)
  add(1, 34, 3, 2, ROOMS.ctoLab.x + 1, ROOMS.ctoLab.y + 2);

  // ── COO Office — Organized desk, filing cabinet, neat shelf ──
  // Desk (rows 17-19, cols 2-3: table variant B)
  add(2, 17, 2, 3, ROOMS.cooOffice.x + 5, ROOMS.cooOffice.y + 2);
  // Chair (rows 17-19, cols 8-9)
  add(8, 17, 2, 3, ROOMS.cooOffice.x + 5, ROOMS.cooOffice.y + 5);
  // Filing cabinet (rows 20-23, cols 6-7: 2x4 tall piece)
  add(6, 20, 2, 4, ROOMS.cooOffice.x + 9, ROOMS.cooOffice.y + 1);
  // Neat shelf (rows 20-23, cols 0-1)
  add(0, 20, 2, 4, ROOMS.cooOffice.x + 1, ROOMS.cooOffice.y + 1);

  // ── CRO Office — Minimal sleek desk, chest/safe, small table ──
  // Sleek desk (rows 17-19, cols 4-5: table variant C)
  add(4, 17, 2, 3, ROOMS.croOffice.x + 5, ROOMS.croOffice.y + 2);
  // Chair (rows 17-19, cols 10-11)
  add(10, 17, 2, 3, ROOMS.croOffice.x + 5, ROOMS.croOffice.y + 5);
  // Chest/safe (rows 35-36, cols 5-6)
  add(5, 35, 2, 2, ROOMS.croOffice.x + 9, ROOMS.croOffice.y + 3);
  // Small table (rows 20-21, cols 2-3)
  add(2, 20, 2, 2, ROOMS.croOffice.x + 1, ROOMS.croOffice.y + 2);

  // ── CMO Studio — Decorative items, easel-like setup, colorful props ──
  // Easel-like table (rows 17-19, cols 12-13)
  add(12, 17, 2, 3, ROOMS.cmoStudio.x + 5, ROOMS.cmoStudio.y + 2);
  // Chair (rows 17-19, cols 14-15)
  add(14, 17, 2, 3, ROOMS.cmoStudio.x + 5, ROOMS.cmoStudio.y + 5);
  // Decorative shelf (rows 20-23, cols 4-5)
  add(4, 20, 2, 4, ROOMS.cmoStudio.x + 9, ROOMS.cmoStudio.y + 1);
  // Colorful vegetation/flowers (vegetation sheet row 0-1, cols 3-4: flowers)
  furnitureItems.push({
    img: IMG.vegetation,
    sx: 3*16, sy: 0, sw: 2*16, sh: 2*16,
    tx: ROOMS.cmoStudio.x + 1, ty: ROOMS.cmoStudio.y + 1,
    tw: 2, th: 2
  });
  // More flowers (vegetation row 0-1, cols 6-7)
  furnitureItems.push({
    img: IMG.vegetation,
    sx: 6*16, sy: 0, sw: 2*16, sh: 2*16,
    tx: ROOMS.cmoStudio.x + 1, ty: ROOMS.cmoStudio.y + 5,
    tw: 2, th: 2
  });

  // ── Auditor Post — Sparse, watchful: single desk, torch ──
  // Single desk (rows 20-21, cols 8-11: wider desk)
  add(8, 20, 4, 2, ROOMS.auditorPost.x + 4, ROOMS.auditorPost.y + 2);
  // Chair (rows 22-23, cols 8-9)
  add(8, 22, 2, 2, ROOMS.auditorPost.x + 5, ROOMS.auditorPost.y + 4);
  // Torch/light item (rows 39-41, cols 8: small standalone)
  add(8, 39, 1, 3, ROOMS.auditorPost.x + 1, ROOMS.auditorPost.y + 1);
  add(8, 39, 1, 3, ROOMS.auditorPost.x + 10, ROOMS.auditorPost.y + 1);

  // ── Meeting Room — Bonfire (central) + chairs/stools around ──
  furnitureItems.push({
    img: IMG.bonfire,
    sx: 0, sy: 0, sw: 64, sh: 64,
    tx: ROOMS.meetingRoom.x + 11, ty: ROOMS.meetingRoom.y + 1,
    tw: 2, th: 2,
    isStation: true, animated: true, animFrames: 6, animFw: 64, animFh: 64
  });
  // Stools around bonfire (rows 22-23, cols 0-1: small seating)
  for (let i = 0; i < 5; i++) {
    add(0, 22, 2, 2, ROOMS.meetingRoom.x + 4 + i * 4, ROOMS.meetingRoom.y + 3);
  }

  // ── Break Room — Cooking station + food table ──
  furnitureItems.push({
    img: IMG.cookStation,
    sx: 0, sy: 0, sw: 288, sh: 224,
    tx: ROOMS.breakRoom.x + 1, ty: ROOMS.breakRoom.y + 1,
    tw: 4, th: 3,
    isStation: true
  });
  // Food table (rows 24-25, cols 3-4)
  add(3, 24, 2, 2, ROOMS.breakRoom.x + 7, ROOMS.breakRoom.y + 1);
  // Small item — barrel/drink (rows 30-31, cols 3-4)
  add(3, 30, 2, 2, ROOMS.breakRoom.x + 9, ROOMS.breakRoom.y + 2);

  // ── Open Space — Workbenches + tools ──
  furnitureItems.push({
    img: IMG.workbench,
    sx: 0, sy: 0, sw: 192, sh: 64,
    tx: ROOMS.openSpace.x + 1, ty: ROOMS.openSpace.y + 1,
    tw: 3, th: 2,
    isStation: true
  });
  furnitureItems.push({
    img: IMG.workbench,
    sx: 0, sy: 0, sw: 192, sh: 64,
    tx: ROOMS.openSpace.x + 7, ty: ROOMS.openSpace.y + 1,
    tw: 3, th: 2,
    isStation: true
  });
  // Resources/tools (rows 26-28, cols 5-8)
  add(5, 26, 2, 2, ROOMS.openSpace.x + 5, ROOMS.openSpace.y + 1);
}
placeFurniture();

// ═══════════════════════════════════════════════════════════════════
// OUTDOOR DECORATION
// ═══════════════════════════════════════════════════════════════════
const trees = [];
const vegetationPatches = [];
const pathTiles = []; // walkway tiles

function placeOutdoor() {
  // Trees along top (varied models and slight offsets for organic feel)
  trees.push({ model: 0, x: 1, y: 0, size: 'Size_03' });
  trees.push({ model: 1, x: 7, y: -1, size: 'Size_03' });
  trees.push({ model: 2, x: 13, y: 0, size: 'Size_03' });
  trees.push({ model: 0, x: 20, y: -1, size: 'Size_03' });
  trees.push({ model: 1, x: 26, y: 0, size: 'Size_03' });
  trees.push({ model: 2, x: 32, y: -1, size: 'Size_03' });
  // Trees along bottom
  trees.push({ model: 2, x: 1, y: MAP_H - 3, size: 'Size_02' });
  trees.push({ model: 0, x: 8, y: MAP_H - 2, size: 'Size_02' });
  trees.push({ model: 1, x: 15, y: MAP_H - 3, size: 'Size_02' });
  trees.push({ model: 2, x: 22, y: MAP_H - 2, size: 'Size_02' });
  trees.push({ model: 0, x: 29, y: MAP_H - 3, size: 'Size_02' });
  trees.push({ model: 1, x: 35, y: MAP_H - 2, size: 'Size_02' });
  // Trees on left side
  trees.push({ model: 1, x: 0, y: 5, size: 'Size_02' });
  trees.push({ model: 2, x: -1, y: 14, size: 'Size_02' });
  trees.push({ model: 0, x: 0, y: 23, size: 'Size_02' });
  trees.push({ model: 1, x: -1, y: 32, size: 'Size_02' });
  trees.push({ model: 2, x: 0, y: 40, size: 'Size_02' });
  // Trees on right side
  trees.push({ model: 0, x: MAP_W - 3, y: 6, size: 'Size_02' });
  trees.push({ model: 1, x: MAP_W - 2, y: 15, size: 'Size_02' });
  trees.push({ model: 2, x: MAP_W - 3, y: 24, size: 'Size_02' });
  trees.push({ model: 0, x: MAP_W - 2, y: 33, size: 'Size_02' });
  trees.push({ model: 1, x: MAP_W - 3, y: 41, size: 'Size_02' });

  // Vegetation patches between trees (grass clumps, flowers)
  // Using Vegetation.png: rows 0-1 cols 0-1 = grass, cols 3-4 = flowers, cols 6-7 = more flowers
  // rows 9-11 = mushrooms/small plants at cols 0-3
  const vegPositions = [
    // Grass clumps (veg row 0, cols 0-1, 2 tiles)
    { sx: 0, sy: 0, sw: 2, sh: 2, x: 5, y: 1 },
    { sx: 0, sy: 0, sw: 2, sh: 2, x: 17, y: 1 },
    { sx: 0, sy: 0, sw: 2, sh: 2, x: 30, y: 1 },
    { sx: 0, sy: 0, sw: 2, sh: 2, x: 3, y: MAP_H - 2 },
    { sx: 0, sy: 0, sw: 2, sh: 2, x: 25, y: MAP_H - 1 },
    // Flowers
    { sx: 3, sy: 0, sw: 2, sh: 2, x: 10, y: 0 },
    { sx: 6, sy: 0, sw: 2, sh: 2, x: 24, y: 0 },
    { sx: 3, sy: 0, sw: 2, sh: 2, x: 2, y: 10 },
    { sx: 6, sy: 0, sw: 2, sh: 2, x: MAP_W - 2, y: 20 },
    { sx: 9, sy: 0, sw: 2, sh: 2, x: 2, y: 28 },
    { sx: 3, sy: 0, sw: 2, sh: 2, x: MAP_W - 2, y: 38 },
    // Mushrooms (row 9-10, cols 0-3)
    { sx: 0, sy: 9, sw: 1, sh: 2, x: 1, y: 18 },
    { sx: 1, sy: 9, sw: 1, sh: 2, x: MAP_W - 1, y: 28 },
    { sx: 2, sy: 9, sw: 1, sh: 2, x: 0, y: 38 },
  ];
  for (const v of vegPositions) {
    vegetationPatches.push(v);
  }

  // Path/walkway from building entrance to edges
  // Use floor tile row 2 (stone path) for a different look
  // Vertical path from bottom of building down
  for (let y = 43; y < MAP_H; y++) {
    pathTiles.push({ x: 16, y });
    pathTiles.push({ x: 17, y });
  }
  // Horizontal path from left side to building entrance
  for (let x = 0; x < 4; x++) {
    pathTiles.push({ x, y: 20 });
    pathTiles.push({ x, y: 21 });
  }
  // Horizontal path from right side
  for (let x = MAP_W - 4; x < MAP_W; x++) {
    pathTiles.push({ x, y: 20 });
    pathTiles.push({ x, y: 21 });
  }
}
placeOutdoor();

// ═══════════════════════════════════════════════════════════════════
// RENDERING
// ═══════════════════════════════════════════════════════════════════

function drawTile(srcImg, srcX, srcY, srcW, srcH, tileX, tileY, tileW, tileH) {
  if (!srcImg || !srcImg.complete) return;
  tileW = tileW || 1;
  tileH = tileH || 1;
  ctx.drawImage(srcImg,
    srcX, srcY, srcW, srcH,
    tileX * T, tileY * T, tileW * T, tileH * T
  );
}

// Pre-compute path tile set for fast lookup
const pathTileSet = new Set();

function renderGround() {
  // Build path set if needed
  if (pathTileSet.size === 0) {
    for (const pt of pathTiles) {
      pathTileSet.add(pt.y * MAP_W + pt.x);
    }
  }

  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      if (tileMap[y][x] === 0) {
        const isPath = pathTileSet.has(y * MAP_W + x);
        if (isPath) {
          // Stone path tile (row 2 of floor tiles)
          const variant = ((x + y) % 3);
          drawTile(IMG.floorTiles, variant * 16, 2 * 16, 16, 16, x, y);
        } else {
          // Grass tile — use floor tiles sheet, first row
          const variant = ((x + y * 3) % 4);
          const gx = variant * 16;
          drawTile(IMG.floorTiles, gx, 0, 16, 16, x, y);
        }
      }
    }
  }
}

function renderFloors() {
  for (const [roomId, room] of Object.entries(ROOMS)) {
    for (let dy = 0; dy < room.h; dy++) {
      for (let dx = 0; dx < room.w; dx++) {
        // Wood floor = row 1, stone = row 2 in floor tiles
        const floorRow = room.floor === 'stone' ? 2 : 1;
        const variant = ((dx + dy) % 3);
        drawTile(IMG.floorTiles, variant * 16, floorRow * 16, 16, 16, room.x + dx, room.y + dy);
      }
    }
  }
}

// Determine which room a wall tile belongs to (for wall variation)
function getRoomForWall(x, y) {
  // Check adjacent tiles for which room they're in
  for (const [roomId, room] of Object.entries(ROOMS)) {
    // Check if this wall is adjacent to this room
    if (x >= room.x - 1 && x <= room.x + room.w &&
        y >= room.y - 1 && y <= room.y + room.h) {
      return roomId;
    }
  }
  return null;
}

// Wall Variations.png: 256x480, 16x30 tiles
// 3 sets of 10 rows each (rows 0-9, 10-19, 20-29)
// Set 0 (rows 0-9): lighter/warmer walls → wood rooms
// Set 1 (rows 10-19): medium walls → transition
// Set 2 (rows 20-29): darker/cooler walls → stone rooms
function renderWalls() {
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      if (tileMap[y][x] !== 2) continue;

      // Determine wall type based on neighbors
      const hasFloorAbove = y > 0 && tileMap[y-1][x] === 1;
      const hasFloorBelow = y < MAP_H-1 && tileMap[y+1][x] === 1;
      const hasFloorLeft = x > 0 && tileMap[y][x-1] === 1;
      const hasFloorRight = x < MAP_W-1 && tileMap[y][x+1] === 1;

      // Pick wall tile variant from wall tiles sheet (400×400, 16px grid = 25×25)
      let wtx = 0, wty = 0;
      if (hasFloorBelow) { wty = 0; } // top wall
      else if (hasFloorAbove) { wty = 2; } // bottom wall
      else if (hasFloorRight) { wtx = 0; wty = 1; } // left wall
      else if (hasFloorLeft) { wtx = 2; wty = 1; } // right wall
      else { wty = 1; wtx = 1; } // corner/isolated

      // Determine room for wall variation
      const roomId = getRoomForWall(x, y);
      const stoneRooms = new Set(['ctoLab', 'auditorPost', 'meetingRoom']);
      const isStone = roomId && stoneRooms.has(roomId);

      // Use Wall_Variations.png for variation
      // Each set is 10 rows; pick row offset based on wall direction
      const varSetOffset = isStone ? 20 : 0; // stone = set 2, wood = set 0
      const variantCol = (x + y) % 8; // variation within set

      // Draw base wall tile
      drawTile(IMG.wallTiles, wtx * 16, wty * 16, 16, 16, x, y);

      // Overlay with wall variation for visual texture
      // Use row 5-9 of each set (the detailed wall sections)
      if (IMG.wallVariations && IMG.wallVariations.complete) {
        const varRow = varSetOffset + 5 + (wty % 5);
        const varCol = variantCol % 8;
        ctx.globalAlpha = 0.3; // subtle overlay
        drawTile(IMG.wallVariations, varCol * 16, varRow * 16, 16, 16, x, y);
        ctx.globalAlpha = 1.0;
      }
    }
  }
}

// Room banner colors per room type
const ROOM_BANNER_COLORS = {
  ceoOffice:   { bg: 'rgba(180,140,40,0.6)',  border: '#ffd700' },
  ctoLab:      { bg: 'rgba(80,60,160,0.6)',   border: '#7b68ee' },
  cooOffice:   { bg: 'rgba(30,130,130,0.6)',   border: '#20b2aa' },
  croOffice:   { bg: 'rgba(180,60,50,0.6)',    border: '#ff6347' },
  cmoStudio:   { bg: 'rgba(160,100,170,0.6)',  border: '#dda0dd' },
  auditorPost: { bg: 'rgba(100,120,150,0.6)',  border: '#b0c4de' },
  meetingRoom: { bg: 'rgba(50,80,50,0.6)',     border: '#5f8' },
  breakRoom:   { bg: 'rgba(120,90,50,0.6)',    border: '#d4a05a' },
  openSpace:   { bg: 'rgba(60,100,60,0.6)',    border: '#7cb07c' },
};

function renderRoomLabels() {
  ctx.save();
  ctx.font = '7px "Press Start 2P"';
  ctx.textAlign = 'center';
  for (const [roomId, room] of Object.entries(ROOMS)) {
    const cx = (room.x + room.w / 2) * T;
    const cy = (room.y + 0.8) * T;
    const textW = ctx.measureText(room.label).width;
    const bannerW = textW + 12;
    const bannerH = 14;
    const bannerX = cx - bannerW / 2;
    const bannerY = cy - bannerH + 3;

    // Banner background
    const colors = ROOM_BANNER_COLORS[roomId] || { bg: 'rgba(40,40,60,0.6)', border: '#5f8' };
    ctx.fillStyle = colors.bg;
    roundRect(ctx, bannerX, bannerY, bannerW, bannerH, 3);
    ctx.fill();
    // Banner border
    ctx.strokeStyle = colors.border;
    ctx.lineWidth = 1;
    roundRect(ctx, bannerX, bannerY, bannerW, bannerH, 3);
    ctx.stroke();
    // Label text
    ctx.fillStyle = '#fff';
    ctx.fillText(room.label, cx, cy);
  }
  ctx.restore();
}

function renderFurniture() {
  for (const f of furnitureItems) {
    if (!f.img || !f.img.complete) continue;
    let sx = f.sx, sy = f.sy;
    // Animated stations
    if (f.animated) {
      const frame = Math.floor(Date.now() / (1000 / FPS_ANIM)) % f.animFrames;
      sy = frame * f.animFh;
    }
    ctx.drawImage(f.img,
      sx, sy, f.sw, f.sh,
      f.tx * T, f.ty * T, f.tw * T, f.th * T
    );
  }
}

function renderTreeShadows() {
  // Draw shadows under trees using Shadows.png
  // Shadow sheet: rows 0-2 have large oval shadows (7x3 tiles)
  // rows 3-5 have medium shadows (5x3)
  // rows 6+ have small shadows
  const shadows = IMG.shadows;
  if (!shadows || !shadows.complete) return;

  for (const t of trees) {
    const isLarge = t.size === 'Size_03';
    // Use row 3-5 shadows (medium, 5x3 tiles) for Size_03, row 6-7 (small) for Size_02
    const shadowSx = 0;
    const shadowSy = isLarge ? 3 * 16 : 6 * 16;
    const shadowSw = isLarge ? 5 * 16 : 2 * 16;
    const shadowSh = isLarge ? 2 * 16 : 2 * 16;
    const shadowTw = isLarge ? 4 : 2;
    const shadowTh = isLarge ? 2 : 1;

    ctx.globalAlpha = 0.4;
    ctx.drawImage(shadows,
      shadowSx, shadowSy, shadowSw, shadowSh,
      (t.x + 0.5) * T, (t.y + 1) * T, shadowTw * T, shadowTh * T
    );
    ctx.globalAlpha = 1.0;
  }
}

function renderTrees() {
  const treeImgs = [IMG.tree1, IMG.tree2, IMG.tree3];
  for (const t of trees) {
    const img = treeImgs[t.model];
    if (!img || !img.complete) continue;
    const scale = t.size === 'Size_02' ? 0.7 : 1;
    const w = img.width * SCALE * scale;
    const h = img.height * SCALE * scale;
    ctx.drawImage(img, t.x * T, t.y * T - h + T * 2, w, h);
  }
}

function renderVegetation() {
  const veg = IMG.vegetation;
  if (!veg || !veg.complete) return;
  for (const v of vegetationPatches) {
    ctx.drawImage(veg,
      v.sx * 16, v.sy * 16, v.sw * 16, v.sh * 16,
      v.x * T, v.y * T, v.sw * T, v.sh * T
    );
  }
}

function renderDoors() {
  // Draw a slight floor patch over door positions to show openings
  for (const d of DOORS) {
    drawTile(IMG.floorTiles, 16, 16, 16, 16, d.x, d.y);
    if (d.dir === 'h' && d.x + 1 < MAP_W) {
      drawTile(IMG.floorTiles, 16, 16, 16, 16, d.x + 1, d.y);
    }
    if (d.dir === 'v' && d.y + 1 < MAP_H) {
      drawTile(IMG.floorTiles, 16, 16, 16, 16, d.x, d.y + 1);
    }
  }
}

// ═══════════════════════════════════════════════════════════════════
// CLICK DETECTION
// ═══════════════════════════════════════════════════════════════════

let selectedAgent = null;

canvas.addEventListener('click', e => {
  if (isDragging) return;
  // Convert screen coords to world coords
  const rect = canvas.getBoundingClientRect();
  const sx = (e.clientX - rect.left);
  const sy = (e.clientY - rect.top);
  const wx = sx / zoom - camX;
  const wy = sy / zoom - camY;

  // Check agents (reverse order = topmost first)
  for (let i = agents.length - 1; i >= 0; i--) {
    if (agents[i].containsPoint(wx, wy)) {
      selectAgent(agents[i]);
      return;
    }
  }
  closePanel();
});

function selectAgent(agent) {
  selectedAgent = agent;
  document.getElementById('panel-name').textContent = agent.name;
  document.getElementById('panel-role').textContent = agent.role;
  document.getElementById('panel-status').textContent = agent.status;
  document.getElementById('panel-session').textContent = agent.session || '—';
  const tasksEl = document.getElementById('panel-tasks');
  tasksEl.innerHTML = '';
  if (agent.currentTask) {
    const div = document.createElement('div');
    div.className = 'task';
    div.textContent = agent.currentTask;
    tasksEl.appendChild(div);
  }
  document.getElementById('agent-panel').classList.add('open');

  // Emit event for data bridge
  if (window.SpawnKit && SpawnKit.emit) {
    SpawnKit.emit('agent:select', agent.id);
  }
}

function closePanel() {
  selectedAgent = null;
  document.getElementById('agent-panel').classList.remove('open');
}
window.closePanel = closePanel;

// ═══════════════════════════════════════════════════════════════════
// DATA BRIDGE INTEGRATION
// ═══════════════════════════════════════════════════════════════════

const AGENT_ID_MAP = {
  main:     'apomac',
  forge:    'forge',
  hunter:   'hunter',
  atlas:    'atlas',
  echo:     'echo',
  sentinel: 'sentinel',
};

function syncFromDataBridge() {
  if (!window.SpawnKit || !SpawnKit.data) return;
  const data = SpawnKit.data;

  // Update mode badge
  document.getElementById('mode-badge').textContent = SpawnKit.mode === 'live' ? 'LIVE' : 'DEMO';

  // Sync agents
  if (data.agents) {
    for (const bridgeAgent of data.agents) {
      const localId = AGENT_ID_MAP[bridgeAgent.parent || bridgeAgent.id];
      if (!localId) continue;
      const agent = agents.find(a => a.id === localId);
      if (!agent) continue;

      // Map status
      const s = bridgeAgent.status || 'idle';
      if (s === 'working' || s === 'active' || s === 'busy') {
        agent.status = 'working';
        agent.animState = 'idle';
        if (agent.room !== getRoomForRole(agent.id)) {
          agent.moveToRoom(getRoomForRole(agent.id));
        }
      } else if (s === 'idle' || s === 'available') {
        agent.status = 'idle';
        agent.animState = 'idle';
      } else if (s === 'brainstorm' || s === 'meeting') {
        agent.status = 'brainstorm';
        agent.moveToRoom('meetingRoom');
      } else if (s === 'error' || s === 'crashed') {
        agent.status = 'error';
      }

      agent.session = bridgeAgent.session || '';
      agent.currentTask = bridgeAgent.currentTask || bridgeAgent.task || '';
      if (agent.currentTask && agent.status === 'working') {
        agent.say(agent.currentTask.substring(0, 40), 5);
      }
    }
  }

  // Sync sub-agents
  if (data.subagents) {
    const activeSubIds = new Set(data.subagents.filter(s => s.status !== 'completed' && s.status !== 'dead').map(s => s.id || s.sessionId));

    // Spawn new sub-agents
    for (const sa of data.subagents) {
      const saId = sa.id || sa.sessionId;
      if (sa.status === 'completed' || sa.status === 'dead') continue;
      if (!subAgents.find(a => a.id === saId)) {
        const newSa = spawnSubAgent(sa.label || sa.name || saId, sa.parent);
        newSa.id = saId;
        newSa.currentTask = sa.task || sa.label || '';
        newSa.say(newSa.currentTask.substring(0, 30), 3);
      }
    }

    // Despawn completed sub-agents
    for (const sa of [...subAgents]) {
      if (!activeSubIds.has(sa.id)) {
        despawnSubAgent(sa);
      }
    }
  }

  // Stats
  const agentCount = agents.filter(a => a.status !== 'dead').length;
  const missionCount = data.missions ? data.missions.filter(m => m.status === 'active').length : 0;
  const subCount = subAgents.length;
  document.getElementById('stat-agents').textContent = agentCount + ' agents';
  document.getElementById('stat-missions').textContent = missionCount + ' missions';
  document.getElementById('stat-subagents').textContent = subCount + ' sub-agents';
}

function getRoomForRole(agentId) {
  const map = {
    apomac: 'ceoOffice', forge: 'ctoLab', hunter: 'croOffice',
    atlas: 'cooOffice', echo: 'cmoStudio', sentinel: 'auditorPost'
  };
  return map[agentId] || 'openSpace';
}

// Listen for data bridge events
if (window.SpawnKit) {
  SpawnKit.on('data:refresh', syncFromDataBridge);
  SpawnKit.on('subagent:spawn', (data) => {
    spawnSubAgent(data.label || data.name, data.parent);
  });
  SpawnKit.on('subagent:complete', (data) => {
    const sa = subAgents.find(a => a.id === (data.id || data.sessionId));
    if (sa) despawnSubAgent(sa);
  });
}

// ═══════════════════════════════════════════════════════════════════
// AMBIENT BEHAVIORS (Demo mode — agents roam and do things)
// ═══════════════════════════════════════════════════════════════════

let behaviorTimer = 0;
const BEHAVIOR_INTERVAL = 5; // seconds between random behavior updates

const TASK_PHRASES = {
  apomac:   ['Reviewing roadmap', 'Board meeting prep', 'Vision planning', 'Approving PRs'],
  forge:    ['Building theme', 'Code review', 'Architecture', 'Debugging sprites'],
  hunter:   ['Pipeline review', 'Deal closing', 'Revenue analysis', 'Lead scoring'],
  atlas:    ['Ops check', 'Fleet coordination', 'Process optimization', 'Resource allocation'],
  echo:     ['Content draft', 'Brand strategy', 'Campaign launch', 'Social analytics'],
  sentinel: ['Audit run', 'Security scan', 'Compliance check', 'Code review'],
};

function updateAmbientBehavior(dt) {
  if (SpawnKit && SpawnKit.mode === 'live') return; // Only in demo mode

  behaviorTimer += dt;
  if (behaviorTimer < BEHAVIOR_INTERVAL) return;
  behaviorTimer = 0;

  for (const agent of agents) {
    if (agent.status === 'dead') continue;
    if (agent.path.length > 0) continue; // busy walking

    const roll = Math.random();
    if (roll < 0.15) {
      // Go to meeting room
      agent.moveToRoom('meetingRoom');
      agent.status = 'brainstorm';
      agent.say('Meeting time!', 3);
    } else if (roll < 0.25) {
      // Go to break room
      agent.moveToRoom('breakRoom');
      agent.status = 'idle';
      agent.say('Coffee break ☕', 3);
    } else if (roll < 0.5) {
      // Back to own office, working
      agent.moveToRoom(getRoomForRole(agent.id));
      agent.status = 'working';
      const tasks = TASK_PHRASES[agent.id];
      if (tasks) {
        const task = tasks[Math.floor(Math.random() * tasks.length)];
        agent.currentTask = task;
        agent.say(task, 4);
      }
    } else if (roll < 0.6) {
      // Wander within room
      const r = ROOMS[agent.room];
      if (r) {
        const tx = r.x + 1 + Math.floor(Math.random() * (r.w - 2));
        const ty = r.y + 1 + Math.floor(Math.random() * (r.h - 2));
        agent.moveTo(tx, ty);
      }
    }
    // else: stay put
  }

  // Random sub-agent spawn/despawn in demo mode
  if (Math.random() < 0.2 && subAgents.length < 4) {
    const names = ['TaskRunner-01', 'CodeBuilder-02', 'DataProc-03', 'Researcher-04', 'OpsRunner-05'];
    const name = names[Math.floor(Math.random() * names.length)];
    const sa = spawnSubAgent(name, 'forge');
    sa.currentTask = 'Processing task...';
    sa.say('On it!', 2);
  }
  if (Math.random() < 0.15 && subAgents.length > 0) {
    despawnSubAgent(subAgents[0]);
  }
}

// ═══════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════

let lastTime = performance.now();
let syncTimer = 0;

function gameLoop(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  // Periodic data sync
  syncTimer += dt;
  if (syncTimer >= 2) {
    syncTimer = 0;
    syncFromDataBridge();
  }

  // Update agents
  for (const agent of agents) {
    agent.update(dt);
  }

  // Ambient behavior
  updateAmbientBehavior(dt);

  // Update clock
  const d = new Date();
  document.getElementById('stat-time').textContent =
    d.toLocaleTimeString('en-GB', { hour:'2-digit', minute:'2-digit' });

  // ─── RENDER ───
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Fill background
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Apply camera
  ctx.scale(zoom, zoom);
  ctx.translate(camX, camY);

  // Disable smoothing for pixel art
  ctx.imageSmoothingEnabled = false;

  // Layer 1: Ground/grass + paths
  renderGround();

  // Layer 2: Room floors
  renderFloors();

  // Layer 3: Doors (floor patches)
  renderDoors();

  // Layer 4: Walls (with variations)
  renderWalls();

  // Layer 5: Room labels (with banners)
  renderRoomLabels();

  // Layer 6a: Tree shadows (below trees)
  renderTreeShadows();

  // Layer 6b: Vegetation patches
  renderVegetation();

  // Layer 6c: Trees
  renderTrees();

  // Layer 7: Furniture
  renderFurniture();

  // Layer 8: Agents (Z-sorted by Y position)
  const sortedAgents = [...agents].sort((a, b) => a.y - b.y);
  for (const agent of sortedAgents) {
    agent.draw(ctx);
  }

  // Selection highlight
  if (selectedAgent) {
    const sa = selectedAgent;
    ctx.save();
    ctx.strokeStyle = '#5f8';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    const spriteDef = SPRITE_DEFS[sa.spriteKey];
    const anim = spriteDef[sa.animState] || spriteDef.idle;
    const dw = anim.fw * SCALE;
    const dh = anim.fh * SCALE;
    ctx.strokeRect(
      sa.x * T - dw/2 + T/2 - 2,
      sa.y * T - dh + T - 2,
      dw + 4, dh + 4
    );
    ctx.restore();
  }

  ctx.restore();

  requestAnimationFrame(gameLoop);
}

// ═══════════════════════════════════════════════════════════════════
// LOADING SCREEN & INIT
// ═══════════════════════════════════════════════════════════════════

function drawLoadingScreen() {
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.font = '12px "Press Start 2P"';
  ctx.fillStyle = '#5f8';
  ctx.textAlign = 'center';
  ctx.fillText('⚔ SPAWNKIT HQ', canvas.width/2, canvas.height/2 - 20);
  ctx.font = '8px "Press Start 2P"';
  ctx.fillStyle = '#8ab';
  ctx.fillText(`Loading assets... ${loadedCount}/${totalImages}`, canvas.width/2, canvas.height/2 + 10);
}

function waitForLoad() {
  drawLoadingScreen();
  if (loadedCount >= totalImages) {
    // All loaded — start!
    console.log('[SpawnKit HQ] All assets loaded. Starting game loop.');
    syncFromDataBridge();

    // Kick off initial agent positions with slight random offset
    for (const agent of agents) {
      const r = ROOMS[agent.room];
      if (r) {
        agent.x = r.x + 2 + Math.floor(Math.random() * (r.w - 4));
        agent.y = r.y + 2 + Math.floor(Math.random() * (r.h - 4));
      }
    }

    requestAnimationFrame(gameLoop);
  } else {
    requestAnimationFrame(waitForLoad);
  }
}

// Start loading check
requestAnimationFrame(waitForLoad);

// Start live data if available
if (window.SpawnKit && SpawnKit.startLive) {
  try { SpawnKit.startLive(); } catch(e) {}
}

console.log('[SpawnKit HQ] Green Iso theme initialized. Mode:', window.SpawnKit ? SpawnKit.mode : 'standalone');
</script>

<!-- SpawnKit Shared Panels Integration -->
<script src="../src/spawnkit-panels.js"></script>
    <script src="../src/fleet-client.js"></script>
    <script src="../src/fleet-bootstrap.js"></script>
<script>
    // Initialize SpawnKit Panels for Green Iso theme
    SpawnKitPanels.init({ theme: 'green-iso' });

    // Wire Green Iso interactions to panels
    document.addEventListener('click', function(e) {
        // Agent character click → detail panel
        var character = e.target.closest('.character, [data-agent]');
        if (character && character.dataset.agent) {
            SpawnKitPanels.openAgentDetail(character.dataset.agent);
            return;
        }

        // Furniture/room interactions
        var furniture = e.target.closest('.furniture, .room-object');
        if (furniture) {
            var furnitureType = furniture.dataset.furniture || furniture.className;
            if (furnitureType.includes('desk') || furnitureType.includes('computer')) {
                SpawnKitPanels.openMissionsOverlay();
            } else if (furnitureType.includes('bookshelf') || furnitureType.includes('filing')) {
                SpawnKitPanels.openMemoryOverlay();
            } else if (furnitureType.includes('phone') || furnitureType.includes('conference')) {
                SpawnKitPanels.openChatOverlay();
            }
            return;
        }

        // Panel triggers
        var panelTrigger = e.target.closest('[data-panel]');
        if (panelTrigger) {
            var panelType = panelTrigger.dataset.panel;
            switch(panelType) {
                case 'logs':
                    SpawnKitPanels.openLogsOverlay();
                    break;
                case 'chat':
                    SpawnKitPanels.openChatOverlay();
                    break;
                case 'cron':
                    SpawnKitPanels.openCronOverlay();
                    break;
                case 'memory':
                    SpawnKitPanels.openMemoryOverlay();
                    break;
                case 'missions':
                    SpawnKitPanels.openMissionsOverlay();
                    break;
                case 'cockpit':
                    SpawnKitPanels.openCockpitOverlay();
                    break;
            }
        }
    });

    // Green Iso bonus interactions
    function addGreenIsoInteractions() {
        // Agent pathfinding to meeting room during brainstorms
        function moveAgentToMeetingRoom(agentId) {
            var agent = document.querySelector('[data-agent="' + agentId + '"]');
            var meetingRoom = document.querySelector('.meeting-room, .conference-room');
            if (agent && meetingRoom) {
                // Simple animation to meeting room
                var agentRect = agent.getBoundingClientRect();
                var meetingRect = meetingRoom.getBoundingClientRect();
                
                agent.style.transition = 'transform 2s ease-in-out';
                agent.style.transform = `translate(${meetingRect.left - agentRect.left + 20}px, ${meetingRect.top - agentRect.top + 20}px)`;
                
                setTimeout(() => {
                    agent.style.transition = '';
                    agent.style.transform = '';
                }, 3000);
            }
        }

        // Speech bubbles for current tasks
        function showTaskSpeechBubble(agentElement, task) {
            var existing = agentElement.querySelector('.task-bubble');
            if (existing) existing.remove();

            var bubble = document.createElement('div');
            bubble.className = 'task-bubble';
            bubble.style.cssText = `
                position: absolute;
                top: -40px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.9);
                color: #4CAF50;
                border: 1px solid #4CAF50;
                padding: 6px 10px;
                font-size: 10px;
                font-family: 'Fira Code', monospace;
                white-space: nowrap;
                z-index: 100;
                animation: greenIsoTaskBubble 3s ease-out forwards;
                border-radius: 4px;
                box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
            `;
            bubble.textContent = '> ' + task;
            agentElement.style.position = 'relative';
            agentElement.appendChild(bubble);
            setTimeout(() => bubble.remove(), 3000);
        }

        // Furniture interaction hints
        function addFurnitureHints() {
            // Add click hints to furniture
            var desks = document.querySelectorAll('.desk, .computer, .workstation');
            desks.forEach(function(desk) {
                if (!desk.dataset.furniture) desk.dataset.furniture = 'desk';
                addInteractionHint(desk, 'Click for TODO panel');
            });

            var bookshelves = document.querySelectorAll('.bookshelf, .filing, .archive');
            bookshelves.forEach(function(shelf) {
                if (!shelf.dataset.furniture) shelf.dataset.furniture = 'bookshelf';
                addInteractionHint(shelf, 'Click for Memory panel');
            });

            var phones = document.querySelectorAll('.phone, .conference, .meeting-room');
            phones.forEach(function(phone) {
                if (!phone.dataset.furniture) phone.dataset.furniture = 'phone';
                addInteractionHint(phone, 'Click for Chat panel');
            });
        }

        function addInteractionHint(element, hintText) {
            element.addEventListener('mouseenter', function() {
                var hint = document.createElement('div');
                hint.className = 'interaction-hint';
                hint.style.cssText = `
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0,0,0,0.8);
                    color: #8BC34A;
                    padding: 4px 8px;
                    font-size: 9px;
                    white-space: nowrap;
                    border-radius: 3px;
                    z-index: 150;
                    pointer-events: none;
                `;
                hint.textContent = hintText;
                element.style.position = 'relative';
                element.appendChild(hint);
            });

            element.addEventListener('mouseleave', function() {
                var hint = element.querySelector('.interaction-hint');
                if (hint) hint.remove();
            });
        }

        // Add CSS for Green Iso animations
        var style = document.createElement('style');
        style.textContent = `
            @keyframes greenIsoTaskBubble {
                0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
                10% { opacity: 1; transform: translateX(-50%) translateY(0); }
                90% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            }
            .green-iso-console {
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0,0,0,0.9);
                color: #4CAF50;
                padding: 10px;
                border: 1px solid #4CAF50;
                font-family: 'Fira Code', monospace;
                font-size: 12px;
                min-width: 250px;
                max-width: 400px;
                max-height: 200px;
                overflow-y: auto;
                z-index: 200;
                border-radius: 4px;
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.2);
            }
            .green-iso-console-line {
                margin: 2px 0;
                padding: 1px 0;
                border-bottom: 1px solid rgba(76, 175, 80, 0.1);
            }
            .green-iso-hud {
                position: fixed;
                bottom: 20px;
                left: 20px;
                display: flex;
                flex-direction: column;
                gap: 8px;
                z-index: 100;
            }
            .green-iso-hud-btn {
                padding: 8px 12px;
                background: rgba(0,0,0,0.8);
                color: #4CAF50;
                border: 1px solid #4CAF50;
                font-family: 'Fira Code', monospace;
                font-size: 10px;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            .green-iso-hud-btn:hover {
                background: rgba(76, 175, 80, 0.1);
                box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
            }
        `;
        document.head.appendChild(style);

        // System console for live updates
        function createSystemConsole() {
            var console = document.createElement('div');
            console.className = 'green-iso-console';
            console.innerHTML = `
                <div class="green-iso-console-line">SPAWNKIT_SYS_INIT_OK</div>
                <div class="green-iso-console-line">FLEET_AGENTS_ONLINE: 6</div>
                <div class="green-iso-console-line">PANEL_SYSTEM_READY</div>
            `;
            document.body.appendChild(console);

            // Add periodic system messages
            setInterval(function() {
                var agents = SpawnKitPanels.getAgents();
                var activeCount = Object.keys(agents).filter(function(id) {
                    return agents[id].status !== 'idle';
                }).length;
                
                var messages = [
                    'HEARTBEAT_CHECK_OK',
                    'FLEET_STATUS_NOMINAL',
                    'ACTIVE_AGENTS: ' + activeCount,
                    'MEMORY_SYNC_COMPLETE',
                    'MISSION_QUEUE_UPDATED',
                    'LOG_ROTATION_OK'
                ];
                
                var line = document.createElement('div');
                line.className = 'green-iso-console-line';
                line.textContent = '[' + new Date().toLocaleTimeString() + '] ' + 
                    messages[Math.floor(Math.random() * messages.length)];
                console.appendChild(line);
                
                // Keep only last 10 lines
                while (console.children.length > 10) {
                    console.removeChild(console.firstChild);
                }
            }, 10000);
        }

        // Update agent states and show task bubbles
        setInterval(function() {
            var agents = SpawnKitPanels.getAgents();
            Object.keys(agents).forEach(function(agentId) {
                var agent = agents[agentId];
                if (agent.status !== 'idle' && Math.random() < 0.1) {
                    var agentElements = document.querySelectorAll('[data-agent="' + agentId + '"]');
                    agentElements.forEach(function(el) {
                        showTaskSpeechBubble(el, agent.task || 'Processing...');
                    });
                }
            });
        }, 8000);

        // Initialize features
        createSystemConsole();
        addFurnitureHints();

        // Random brainstorm meetings
        setInterval(function() {
            if (Math.random() < 0.1) {
                var agents = Object.keys(SpawnKitPanels.getAgents());
                var randomAgent = agents[Math.floor(Math.random() * agents.length)];
                moveAgentToMeetingRoom(randomAgent);
            }
        }, 30000);
    }

    // Initialize Green Iso interactions
    addGreenIsoInteractions();

    // Add Green Iso HUD
    function addGreenIsoHUD() {
        var hud = document.createElement('div');
        hud.className = 'green-iso-hud';
        hud.innerHTML = `
            <button class="green-iso-hud-btn" data-panel="cockpit">█ ADMIN TERM</button>
            <button class="green-iso-hud-btn" data-panel="missions">█ TASK QUEUE</button>
            <button class="green-iso-hud-btn" data-panel="logs">█ SYS LOGS</button>
            <button class="green-iso-hud-btn" data-panel="chat">█ COMM LINK</button>
            <button class="green-iso-hud-btn" data-panel="memory">█ MEM BANK</button>
        `;
        document.body.appendChild(hud);
    }

    // Initialize after a delay for proper loading
    setTimeout(function() {
        addGreenIsoHUD();
    }, 1000);

    console.log('💚 Green Iso theme loaded with all 18 SpawnKit features!');
</script>
</body>
</html>
