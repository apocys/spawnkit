<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Village des Agents</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%; overflow: hidden; background: #000000;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }
  canvas { display: block; cursor: grab; }
  canvas.grabbing { cursor: grabbing; }

  /* â”€â”€ Top Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #topbar {
    position: fixed; top: 0; left: 0; right: 0; height: 48px;
    background: rgba(28, 28, 30, 0.72);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    display: flex; align-items: center; justify-content: center;
    color: #f5f5f7; font-size: 17px; font-weight: 600;
    z-index: 100; border-bottom: 1px solid rgba(255,255,255,0.08);
    letter-spacing: -0.01em;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
  }
  #topbar .sep { margin: 0 10px; opacity: 0.3; }

  /* â”€â”€ Agent Labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .agent-label {
    position: fixed; pointer-events: auto; z-index: 50;
    transform: translate(-50%, -100%);
    border-radius: 980px;
    cursor: pointer;
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);
    font-family: 'Inter', -apple-system, sans-serif;
    letter-spacing: -0.005em;
    /* Default: minimal dot-only mode */
    background: transparent; border: none;
    padding: 2px 6px;
    font-size: 0; color: transparent;
    white-space: nowrap;
    opacity: 0.6;
  }
  .agent-label:hover {
    background: rgba(28, 28, 30, 0.65); backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 4px 12px 5px;
    font-size: 11px; font-weight: 600; color: #f5f5f7;
    opacity: 1;
    transform: translate(-50%, -100%) translateY(-1px);
  }
  .agent-label.selected {
    background: rgba(28, 28, 30, 0.78); backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(52, 199, 89, 0.35);
    padding: 4px 12px 5px;
    font-size: 11px; font-weight: 600; color: #f5f5f7;
    opacity: 1;
  }
  .agent-label .dot {
    display: inline-block; width: 7px; height: 7px; border-radius: 50%;
    margin-right: 5px; vertical-align: middle;
    /* Dot always visible */
    font-size: 0; color: transparent;
  }
  .agent-label:hover .dot,
  .agent-label.selected .dot {
    margin-right: 5px;
  }

  /* â”€â”€ Info Panel (legacy, hidden) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #infopanel {
    position: fixed; bottom: 0; left: 0; right: 0;
    background: rgba(28, 28, 30, 0.92); backdrop-filter: blur(20px);
    color: #f5f5f7; padding: 14px 20px 16px;
    z-index: 100; border-top: 1px solid rgba(255,255,255,0.08);
    display: none;
  }
  #infopanel .name { font-size: 17px; font-weight: 700; letter-spacing: -0.01em; }
  #infopanel .role { font-size: 12px; opacity: 0.6; margin-top: 2px; }
  #infopanel .status { font-size: 14px; margin-top: 8px; }
  #infopanel .close {
    position: absolute; top: 10px; right: 14px; cursor: pointer;
    color: rgba(255,255,255,0.4); font-size: 20px; line-height: 1;
  }
  #infopanel .close:hover { color: #fff; }

  /* â”€â”€ Zoom Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #controls {
    position: fixed; bottom: 20px; right: 14px; z-index: 100;
    display: flex; flex-direction: column; gap: 4px;
  }
  #controls button {
    width: 36px; height: 36px; border: none; border-radius: 980px;
    background: rgba(28, 28, 30, 0.78); color: #f5f5f7; font-size: 17px;
    cursor: pointer; backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    display: flex; align-items: center; justify-content: center;
    transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
    font-family: 'Inter', -apple-system, sans-serif;
  }
  #controls button:hover {
    background: rgba(52, 199, 89, 0.18);
    border-color: rgba(52, 199, 89, 0.35);
    transform: translateY(-1px);
  }

  /* â”€â”€ Loading Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  #loading {
    position: fixed; inset: 0; z-index: 200;
    background: #000000; display: flex; align-items: center; justify-content: center;
    color: #34C759; font-size: 15px; flex-direction: column; gap: 12px;
    font-family: 'Inter', -apple-system, sans-serif;
    font-weight: 500; letter-spacing: -0.005em;
  }
  #loading .bar { width: 200px; height: 4px; background: rgba(255,255,255,0.08); border-radius: 2px; overflow: hidden; }
  #loading .fill { height: 100%; background: #34C759; border-radius: 2px; transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1); }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     iOS Brand Design System â€” Village Theme
     Forest green accent on Apple dark surfaces
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

  :root {
    /* â”€â”€ Typography â”€â”€ */
    --v-font: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, sans-serif;
    --v-font-display: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;

    /* â”€â”€ Dark Mode Colors (iOS) â”€â”€ */
    --v-bg-deep: #000000;
    --v-bg-panel: #1c1c1e;
    --v-bg-card: #2c2c2e;
    --v-bg-input: #1c1c1e;

    /* â”€â”€ Product Accent: Forest Green â”€â”€ */
    --v-accent: #34C759;
    --v-accent-hover: #3dd663;
    --v-accent-active: #2db84e;
    --v-accent-glow: rgba(52, 199, 89, 0.2);
    --v-accent-muted: rgba(52, 199, 89, 0.12);

    /* â”€â”€ Text Hierarchy â”€â”€ */
    --v-text: #f5f5f7;
    --v-text-secondary: #86868b;
    --v-text-muted: #636366;

    /* â”€â”€ Borders â”€â”€ */
    --v-border: #38383a;
    --v-border-med: #48484a;

    /* â”€â”€ Semantic â”€â”€ */
    --v-warm: #ffd60a;
    --v-success: #30D158;
    --v-error: #ff453a;

    /* â”€â”€ Spacing & Radius (Apple) â”€â”€ */
    --v-radius: 12px;
    --v-radius-lg: 16px;
    --v-radius-pill: 980px;

    /* â”€â”€ Animation â”€â”€ */
    --v-ease: cubic-bezier(0.4, 0, 0.2, 1);
    --v-ease-spring: cubic-bezier(0.25, 1, 0.5, 1);

    /* â”€â”€ Shadows (Dark Mode) â”€â”€ */
    --v-shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
    --v-shadow-md: 0 4px 16px rgba(0, 0, 0, 0.3);
    --v-shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.4);
  }

  /* â”€â”€ Status Bar (bottom) â€” Apple Frosted Glass â”€â”€â”€â”€â”€ */
  #village-statusbar {
    position: fixed; bottom: 0; left: 0; right: 0;
    height: 52px; z-index: 120;
    background: rgba(28, 28, 30, 0.72);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    border-top: 1px solid rgba(255, 255, 255, 0.08);
    display: flex; align-items: center; gap: 12px;
    padding: 0 16px;
    font-family: var(--v-font);
  }
  .vsb-info {
    display: flex; align-items: center; gap: 10px; flex-shrink: 0;
  }
  .vsb-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #34C759;
    box-shadow: 0 0 6px rgba(52, 199, 89, 0.5);
    animation: vsbPulse 2.5s ease-in-out infinite;
    flex-shrink: 0;
  }
  @keyframes vsbPulse {
    0%, 100% { opacity: 1; box-shadow: 0 0 6px rgba(52, 199, 89, 0.5); }
    50% { opacity: 0.5; box-shadow: 0 0 3px rgba(52, 199, 89, 0.25); }
  }
  .vsb-title {
    font-size: 13px; font-weight: 600; color: var(--v-text);
    white-space: nowrap; letter-spacing: -0.01em;
  }
  .vsb-meta {
    font-size: 11px; color: var(--v-text-muted);
    white-space: nowrap;
  }
  .vsb-sep {
    width: 1px; height: 20px;
    background: var(--v-border); flex-shrink: 0;
  }
  .vsb-actions {
    display: flex; align-items: center; gap: 6px; flex-shrink: 0;
  }
  .vsb-btn {
    height: 32px; padding: 0 14px;
    border: 1.5px solid var(--v-border);
    border-radius: var(--v-radius-pill);
    background: transparent;
    color: var(--v-text-secondary); font-size: 12px; font-weight: 500;
    cursor: pointer; display: flex; align-items: center; gap: 5px;
    transition: all 150ms var(--v-ease);
    font-family: var(--v-font); white-space: nowrap;
    letter-spacing: -0.005em;
  }
  .vsb-btn:hover {
    background: var(--v-accent-muted);
    border-color: var(--v-accent);
    color: var(--v-accent);
    transform: translateY(-1px);
  }
  .vsb-btn .icon { font-size: 14px; }
  .vsb-cmd {
    flex: 1; position: relative; min-width: 120px;
  }
  .vsb-cmd input {
    width: 100%; height: 36px;
    padding: 0 14px 0 32px;
    background: var(--v-bg-input);
    border: 1.5px solid var(--v-border);
    border-radius: 8px; color: var(--v-text);
    font-family: var(--v-font); font-size: 13px;
    outline: none;
    transition: border-color 200ms var(--v-ease), box-shadow 200ms var(--v-ease);
    letter-spacing: -0.005em;
  }
  .vsb-cmd input::placeholder { color: var(--v-text-muted); }
  .vsb-cmd input:focus {
    border-color: var(--v-accent);
    box-shadow: 0 0 0 3px var(--v-accent-glow);
  }
  .vsb-cmd .cmd-icon {
    position: absolute; left: 10px; top: 50%;
    transform: translateY(-50%); color: var(--v-text-muted);
    font-size: 13px; pointer-events: none;
  }

  /* â”€â”€ Zoom Controls (repositioned above status bar) â”€â”€ */
  #controls {
    bottom: 64px !important;
  }

  /* â”€â”€ Hide old infopanel (replaced by detail panel) â”€â”€ */
  #infopanel { display: none !important; }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     Agent Detail Panel â€” iOS Sheet
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .v-detail-overlay {
    position: fixed; inset: 0; z-index: 200;
    pointer-events: none; opacity: 0;
    transition: opacity 300ms var(--v-ease);
  }
  .v-detail-overlay.open {
    pointer-events: auto; opacity: 1;
  }
  .v-detail-overlay.open .v-detail-backdrop { opacity: 1; }
  .v-detail-overlay.open .v-detail-panel { transform: translateX(0); }
  .v-detail-backdrop {
    position: absolute; inset: 0;
    background: rgba(0, 0, 0, 0.5); opacity: 0;
    transition: opacity 350ms var(--v-ease);
  }
  .v-detail-panel {
    position: absolute; top: 0; right: 0;
    width: 380px; max-width: 90vw; height: 100%;
    background: var(--v-bg-panel);
    border-left: 1px solid var(--v-border);
    display: flex; flex-direction: column;
    transform: translateX(100%);
    transition: transform 400ms var(--v-ease-spring);
    box-shadow: var(--v-shadow-lg);
    border-top-left-radius: var(--v-radius-lg);
    border-bottom-left-radius: var(--v-radius-lg);
  }
  .v-detail-hero {
    display: flex; align-items: center; gap: 14px;
    padding: 20px 20px 16px;
    border-bottom: 1px solid var(--v-border);
  }
  .v-detail-avatar {
    width: 52px; height: 52px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 26px; flex-shrink: 0; position: relative;
  }
  .v-detail-status-dot {
    position: absolute; bottom: 1px; right: 1px;
    width: 12px; height: 12px; border-radius: 50%;
    border: 2.5px solid var(--v-bg-panel);
    background: #34C759;
  }
  .v-detail-info { flex: 1; min-width: 0; }
  .v-detail-name {
    font-size: 17px; font-weight: 700; color: var(--v-text);
    letter-spacing: -0.015em;
    font-family: var(--v-font-display);
  }
  .v-detail-role {
    font-size: 12px; color: var(--v-text-muted); font-weight: 500;
  }
  .v-detail-task {
    font-size: 11px; color: var(--v-accent); margin-top: 3px;
    font-weight: 500; white-space: nowrap; overflow: hidden;
    text-overflow: ellipsis;
  }
  .v-detail-close {
    width: 30px; height: 30px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: var(--v-bg-card); color: var(--v-text-secondary);
    border-radius: 50%; cursor: pointer; font-size: 15px;
    transition: all 150ms var(--v-ease); font-family: inherit; flex-shrink: 0;
  }
  .v-detail-close:hover { background: var(--v-accent-muted); color: var(--v-accent); }
  .v-detail-body {
    flex: 1; overflow-y: auto; padding: 0;
    scrollbar-width: thin;
    scrollbar-color: var(--v-text-muted) transparent;
  }
  .v-detail-body::-webkit-scrollbar { width: 4px; }
  .v-detail-body::-webkit-scrollbar-thumb { background: var(--v-text-muted); border-radius: 2px; }
  .v-detail-section {
    padding: 16px 20px;
    border-bottom: 1px solid var(--v-border);
  }
  .v-detail-section:last-child { border-bottom: none; }
  .v-section-title {
    font-size: 11px; font-weight: 600; color: var(--v-text-muted);
    text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 10px;
    font-family: var(--v-font);
  }
  .v-metrics {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
  }
  .v-metric {
    padding: 12px; background: var(--v-bg-card);
    border-radius: var(--v-radius); border: 1px solid var(--v-border);
  }
  .v-metric-val { font-size: 15px; font-weight: 700; color: var(--v-text); letter-spacing: -0.01em; }
  .v-metric-lbl { font-size: 10px; color: var(--v-text-muted); margin-top: 3px; }
  .v-skill-chips { display: flex; flex-wrap: wrap; gap: 6px; }
  .v-skill-chip {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 5px 12px; background: var(--v-accent-muted);
    border-radius: var(--v-radius-pill); font-size: 11px; font-weight: 500;
    color: var(--v-accent);
    transition: background 150ms var(--v-ease);
  }
  .v-skill-chip:hover { background: rgba(52, 199, 89, 0.2); }
  .v-soul-text {
    font-size: 13px; color: var(--v-text-secondary);
    line-height: 1.5; white-space: pre-wrap;
    max-height: 180px; overflow-y: auto;
    letter-spacing: -0.005em;
  }
  .v-todo-item {
    display: flex; align-items: center; gap: 8px;
    padding: 6px 0; font-size: 13px;
  }
  .v-todo-icon { width: 16px; text-align: center; flex-shrink: 0; }
  .v-todo-text { flex: 1; color: var(--v-text); line-height: 1.35; letter-spacing: -0.005em; }
  .v-todo-done .v-todo-text {
    color: var(--v-text-muted); text-decoration: line-through;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CEO Chat Panel â€” iOS Sheet
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .v-chat-overlay {
    position: fixed; inset: 0; z-index: 250;
    pointer-events: none; opacity: 0;
    transition: opacity 300ms var(--v-ease);
  }
  .v-chat-overlay.open { pointer-events: auto; opacity: 1; }
  .v-chat-overlay.open .v-chat-backdrop { opacity: 1; }
  .v-chat-overlay.open .v-chat-panel { transform: translateY(0); }
  .v-chat-backdrop {
    position: absolute; inset: 0;
    background: rgba(0,0,0,0.5); opacity: 0;
    transition: opacity 350ms var(--v-ease);
  }
  .v-chat-panel {
    position: absolute; bottom: 0; right: 0;
    width: 440px; max-width: 100vw; height: 65vh;
    background: var(--v-bg-panel);
    border-top-left-radius: var(--v-radius-lg);
    border-top-right-radius: var(--v-radius-lg);
    border-left: 1px solid var(--v-border);
    border-top: 1px solid var(--v-border);
    display: flex; flex-direction: column;
    transform: translateY(100%);
    transition: transform 400ms var(--v-ease-spring);
    box-shadow: var(--v-shadow-lg);
  }
  .v-chat-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 20px; border-bottom: 1px solid var(--v-border);
    flex-shrink: 0;
  }
  .v-chat-title {
    font-size: 15px; font-weight: 700; color: var(--v-text);
    display: flex; align-items: center; gap: 8px;
    letter-spacing: -0.015em;
    font-family: var(--v-font-display);
  }
  .v-chat-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #34C759;
    box-shadow: 0 0 6px rgba(52, 199, 89, 0.5);
    animation: vsbPulse 2.5s ease-in-out infinite;
  }
  .v-chat-close {
    width: 28px; height: 28px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: var(--v-bg-card); color: var(--v-text-secondary);
    border-radius: 50%; cursor: pointer; font-size: 13px;
    transition: all 150ms var(--v-ease); font-family: inherit;
  }
  .v-chat-close:hover { background: var(--v-accent-muted); color: var(--v-accent); }
  .v-chat-messages {
    flex: 1; overflow-y: auto; padding: 14px 18px;
    display: flex; flex-direction: column; gap: 10px;
    scrollbar-width: thin; scrollbar-color: var(--v-text-muted) transparent;
  }
  .v-chat-messages::-webkit-scrollbar { width: 4px; }
  .v-chat-messages::-webkit-scrollbar-thumb { background: var(--v-text-muted); border-radius: 2px; }
  .v-chat-msg {
    max-width: 80%; padding: 10px 14px;
    border-radius: 16px; font-size: 13px; line-height: 1.47;
    animation: vChatIn 250ms var(--v-ease-spring);
    letter-spacing: -0.005em;
  }
  @keyframes vChatIn {
    from { opacity: 0; transform: translateY(6px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .v-chat-msg--user {
    align-self: flex-end;
    background: var(--v-accent); color: #fff;
    border-bottom-right-radius: 6px;
  }
  .v-chat-msg--system {
    align-self: flex-start;
    background: var(--v-bg-card); color: var(--v-text);
    border-bottom-left-radius: 6px;
  }
  .v-chat-msg-time { font-size: 9px; opacity: 0.5; margin-top: 4px; }
  .v-chat-msg--user .v-chat-msg-time { text-align: right; }
  .v-chat-empty {
    flex: 1; display: flex; align-items: center; justify-content: center;
    color: var(--v-text-muted); font-size: 13px; text-align: center; padding: 30px;
    letter-spacing: -0.005em;
  }
  .v-chat-input-bar {
    display: flex; align-items: center; gap: 8px;
    padding: 12px 18px; border-top: 1px solid var(--v-border);
    flex-shrink: 0;
  }
  .v-chat-route {
    padding: 5px 8px; border-radius: 8px;
    border: 1.5px solid var(--v-border);
    background: var(--v-bg-input); color: var(--v-text-secondary);
    font-size: 11px; font-family: var(--v-font);
    cursor: pointer; flex-shrink: 0;
    transition: border-color 150ms var(--v-ease);
  }
  .v-chat-route:focus {
    border-color: var(--v-accent);
    outline: none;
  }
  .v-chat-input {
    flex: 1; height: 38px; padding: 0 14px;
    background: var(--v-bg-input); border: 1.5px solid var(--v-border);
    border-radius: var(--v-radius-pill); color: var(--v-text);
    font-family: var(--v-font); font-size: 13px; outline: none;
    transition: border-color 200ms var(--v-ease), box-shadow 200ms var(--v-ease);
    letter-spacing: -0.005em;
  }
  .v-chat-input:focus {
    border-color: var(--v-accent);
    box-shadow: 0 0 0 3px var(--v-accent-glow);
  }
  .v-chat-input::placeholder { color: var(--v-text-muted); }
  .v-chat-send {
    width: 38px; height: 38px;
    display: flex; align-items: center; justify-content: center;
    background: var(--v-accent); color: #fff;
    border: none; border-radius: 50%; cursor: pointer;
    font-size: 15px; transition: all 150ms var(--v-ease); flex-shrink: 0;
    font-weight: 600;
  }
  .v-chat-send:hover { background: var(--v-accent-hover); transform: scale(1.05); }
  .v-chat-send:active { background: var(--v-accent-active); transform: scale(0.95); }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     Generic Side Panel â€” iOS Sheet
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .v-side-overlay {
    position: fixed; inset: 0; z-index: 200;
    pointer-events: none; opacity: 0;
    transition: opacity 300ms var(--v-ease);
  }
  .v-side-overlay.open { pointer-events: auto; opacity: 1; }
  .v-side-overlay.open .v-side-backdrop { opacity: 1; }
  .v-side-overlay.open .v-side-panel { transform: translateX(0); }
  .v-side-backdrop {
    position: absolute; inset: 0;
    background: rgba(0,0,0,0.5); opacity: 0;
    transition: opacity 350ms var(--v-ease);
  }
  .v-side-panel {
    position: absolute; top: 0; right: 0;
    width: 400px; max-width: 90vw; height: 100%;
    background: var(--v-bg-panel);
    border-left: 1px solid var(--v-border);
    display: flex; flex-direction: column;
    transform: translateX(100%);
    transition: transform 400ms var(--v-ease-spring);
    box-shadow: var(--v-shadow-lg);
    border-top-left-radius: var(--v-radius-lg);
    border-bottom-left-radius: var(--v-radius-lg);
  }
  .v-side-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 18px 20px; border-bottom: 1px solid var(--v-border);
    flex-shrink: 0;
  }
  .v-side-title {
    font-size: 17px; font-weight: 700; color: var(--v-text);
    display: flex; align-items: center; gap: 8px;
    letter-spacing: -0.015em;
    font-family: var(--v-font-display);
  }
  .v-side-close {
    width: 30px; height: 30px;
    display: flex; align-items: center; justify-content: center;
    border: none; background: var(--v-bg-card); color: var(--v-text-secondary);
    border-radius: 50%; cursor: pointer; font-size: 15px;
    transition: all 150ms var(--v-ease); font-family: inherit;
  }
  .v-side-close:hover { background: var(--v-accent-muted); color: var(--v-accent); }
  .v-side-body {
    flex: 1; overflow-y: auto; padding: 0;
    scrollbar-width: thin; scrollbar-color: var(--v-text-muted) transparent;
  }
  .v-side-body::-webkit-scrollbar { width: 4px; }
  .v-side-body::-webkit-scrollbar-thumb { background: var(--v-text-muted); border-radius: 2px; }
  .v-side-group {
    padding: 16px 20px;
    border-bottom: 1px solid var(--v-border);
  }
  .v-side-group:last-child { border-bottom: none; }
  .v-side-group-title {
    font-size: 11px; font-weight: 600; color: var(--v-text-muted);
    text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 10px;
    font-family: var(--v-font);
  }
  .v-side-item {
    display: flex; align-items: center; gap: 10px;
    padding: 12px 14px; background: var(--v-bg-card);
    border-radius: var(--v-radius); margin-bottom: 6px;
    border: 1px solid var(--v-border);
    transition: all 150ms var(--v-ease);
  }
  .v-side-item:last-child { margin-bottom: 0; }
  .v-side-item:hover { background: rgba(44, 44, 46, 0.8); border-color: var(--v-border-med); }
  .v-side-item-icon { font-size: 18px; flex-shrink: 0; }
  .v-side-item-info { flex: 1; min-width: 0; }
  .v-side-item-name { font-size: 13px; font-weight: 600; color: var(--v-text); letter-spacing: -0.005em; }
  .v-side-item-sub { font-size: 11px; color: var(--v-text-muted); margin-top: 2px; }
  .v-side-item-accent { font-size: 11px; color: var(--v-accent); margin-top: 2px; }
  .v-side-badge {
    display: inline-flex; align-items: center; padding: 3px 8px;
    border-radius: var(--v-radius-pill); font-size: 10px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.04em; flex-shrink: 0;
  }
  .v-side-badge--active { background: rgba(48,209,88,0.15); color: #30D158; }
  .v-side-badge--paused { background: rgba(255,214,10,0.15); color: #B89B00; }
  .v-side-badge--error { background: rgba(255,69,58,0.15); color: #FF453A; }
  .v-side-badge--done { background: var(--v-accent-muted); color: var(--v-accent); }
  .v-side-empty {
    padding: 40px 20px; text-align: center;
    color: var(--v-text-muted); font-size: 13px;
    letter-spacing: -0.005em;
  }
  .v-side-toggle {
    width: 34px; height: 20px;
    background: #636366; border-radius: 10px;
    border: none; cursor: pointer; position: relative;
    transition: background 250ms var(--v-ease); flex-shrink: 0;
  }
  .v-side-toggle::after {
    content: ''; position: absolute; top: 2px; left: 2px;
    width: 16px; height: 16px; background: #fff;
    border-radius: 50%; transition: transform 250ms var(--v-ease-spring);
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  }
  .v-side-toggle.on { background: #34C759; }
  .v-side-toggle.on::after { transform: translateX(14px); }

  /* Memory-specific */
  .v-memory-md {
    font-size: 13px; color: var(--v-text-secondary); line-height: 1.6;
    letter-spacing: -0.005em;
  }
  .v-memory-md h1, .v-memory-md h2, .v-memory-md h3 {
    color: var(--v-text); margin: 8px 0 4px; font-size: 14px;
    font-weight: 600; letter-spacing: -0.01em;
  }
  .v-memory-md code {
    background: var(--v-bg-card); padding: 2px 6px; border-radius: 6px;
    font-size: 11px; font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  }
  .v-memory-md strong { color: var(--v-text); }
  .v-memory-golden {
    background: rgba(255, 214, 10, 0.08); border: 1px solid rgba(255, 214, 10, 0.15);
    border-radius: var(--v-radius); padding: 12px 14px; margin-bottom: 8px;
  }
  .v-memory-daily {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 0; font-size: 13px;
    border-bottom: 1px solid var(--v-border);
  }
  .v-memory-daily:last-child { border-bottom: none; }
  .v-memory-daily-date { color: var(--v-text); font-weight: 600; letter-spacing: -0.005em; }
  .v-memory-daily-size { color: var(--v-text-muted); font-size: 11px; }

  /* â”€â”€ Toast â€” Apple Style â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .v-toast {
    position: fixed; bottom: 70px; left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: var(--v-bg-card); color: var(--v-text);
    padding: 12px 24px; border-radius: var(--v-radius-pill);
    font-size: 14px; font-weight: 500;
    border: 1px solid var(--v-border);
    box-shadow: var(--v-shadow-lg);
    opacity: 0; pointer-events: none;
    transition: all 300ms var(--v-ease-spring);
    z-index: 300;
    letter-spacing: -0.005em;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }
  .v-toast.show {
    opacity: 1; transform: translateX(-50%) translateY(0);
  }

  /* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  @media (max-width: 600px) {
    #village-statusbar {
      flex-wrap: wrap; height: auto;
      padding: 8px 10px; gap: 6px;
    }
    .vsb-btn .label { display: none; }
    .vsb-btn { padding: 0 10px; }
    .vsb-cmd { min-width: 80px; }
    .v-detail-panel, .v-side-panel { width: 100vw; border-radius: 0; }
    .v-chat-panel { width: 100vw; }
  }
</style>
</head>
<body>
<div id="loading"><div>Loading village...</div><div class="bar"><div class="fill" id="loadfill"></div></div></div>
<div id="topbar">ğŸ˜ï¸<span class="sep">|</span>Village des Agents</div>
<div id="labels"></div>
<div id="infopanel">
  <div class="close" onclick="closePanel()">âœ•</div>
  <div class="name" id="pn"></div>
  <div class="role" id="pr"></div>
  <div class="status" id="ps"></div>
</div>
<div id="controls">
  <button onclick="doZoom(1.25)">+</button>
  <button onclick="doZoom(0.8)">âˆ’</button>
  <button onclick="resetView()">âŒ‚</button>
</div>
<canvas id="c"></canvas>

<!-- â•â•â• Village Status Bar â•â•â• -->
<div id="village-statusbar">
  <div class="vsb-info">
    <div class="vsb-dot"></div>
    <span class="vsb-title">Village des Agents</span>
    <span class="vsb-meta" id="vsbAgentCount">6 Agents</span>
    <span class="vsb-meta" id="vsbUptime">0h00m</span>
    <span class="vsb-meta" id="vsbClock">--:--</span>
  </div>
  <div class="vsb-sep"></div>
  <div class="vsb-actions">
    <button class="vsb-btn" id="vsbMissions"><span class="icon">ğŸ¯</span><span class="label">Missions</span></button>
    <button class="vsb-btn" id="vsbCrons"><span class="icon">ğŸ“…</span><span class="label">Crons</span></button>
    <button class="vsb-btn" id="vsbMemory"><span class="icon">ğŸ§ </span><span class="label">Memory</span></button>
    <button class="vsb-btn" id="vsbChat"><span class="icon">ğŸ’¬</span><span class="label">Chat</span></button>
    <button class="vsb-btn" id="vsbSettings"><span class="icon">âš™ï¸</span><span class="label">Settings</span></button>
  </div>
  <div class="vsb-sep"></div>
  <div class="vsb-cmd">
    <span class="cmd-icon">âŒ˜</span>
    <input type="text" id="vsbCmdInput" placeholder="Send a mission..." autocomplete="off" spellcheck="false" />
  </div>
</div>

<!-- â•â•â• Agent Detail Panel â•â•â• -->
<div class="v-detail-overlay" id="vDetailOverlay">
  <div class="v-detail-backdrop" id="vDetailBackdrop"></div>
  <div class="v-detail-panel">
    <div class="v-detail-hero">
      <div class="v-detail-avatar" id="vDetailAvatar">
        <div class="v-detail-status-dot" id="vDetailStatusDot"></div>
      </div>
      <div class="v-detail-info">
        <div class="v-detail-name" id="vDetailName">Agent</div>
        <div class="v-detail-role" id="vDetailRole">Role</div>
        <div class="v-detail-task" id="vDetailTask">â€”</div>
      </div>
      <button class="v-detail-close" id="vDetailClose">Ã—</button>
    </div>
    <div class="v-detail-body" id="vDetailBody"></div>
  </div>
</div>

<!-- â•â•â• CEO Chat Panel â•â•â• -->
<div class="v-chat-overlay" id="vChatOverlay">
  <div class="v-chat-backdrop" id="vChatBackdrop"></div>
  <div class="v-chat-panel">
    <div class="v-chat-header">
      <div class="v-chat-title">
        <span class="v-chat-dot"></span>
        Village Chat
      </div>
      <button class="v-chat-close" id="vChatClose">Ã—</button>
    </div>
    <div class="v-chat-messages" id="vChatMessages">
      <div class="v-chat-empty" id="vChatEmpty">No messages yet. Send a mission to the village chief.</div>
    </div>
    <div class="v-chat-input-bar">
      <select class="v-chat-route" id="vChatRoute" title="Route to...">
        <option value="ceo">ğŸ“¬ CEO</option>
        <option value="atlas">ğŸ“Š Atlas</option>
        <option value="forge">ğŸ”¨ Forge</option>
        <option value="hunter">ğŸ’° Hunter</option>
        <option value="echo">ğŸ“¢ Echo</option>
        <option value="sentinel">ğŸ›¡ï¸ Sentinel</option>
      </select>
      <input class="v-chat-input" id="vChatInput" type="text" placeholder="Send a mission..." autocomplete="off" spellcheck="false" />
      <button class="v-chat-send" id="vChatSend">â†‘</button>
    </div>
  </div>
</div>

<!-- â•â•â• Missions Panel â•â•â• -->
<div class="v-side-overlay" id="vMissionsOverlay">
  <div class="v-side-backdrop" id="vMissionsBackdrop"></div>
  <div class="v-side-panel">
    <div class="v-side-header">
      <div class="v-side-title"><span>ğŸ¯</span> Active Missions</div>
      <button class="v-side-close" id="vMissionsClose">Ã—</button>
    </div>
    <div class="v-side-body" id="vMissionsBody">
      <div class="v-side-empty">Loading missionsâ€¦</div>
    </div>
  </div>
</div>

<!-- â•â•â• Crons Panel â•â•â• -->
<div class="v-side-overlay" id="vCronOverlay">
  <div class="v-side-backdrop" id="vCronBackdrop"></div>
  <div class="v-side-panel">
    <div class="v-side-header">
      <div class="v-side-title"><span>ğŸ“…</span> Scheduled Jobs</div>
      <button class="v-side-close" id="vCronClose">Ã—</button>
    </div>
    <div class="v-side-body" id="vCronBody">
      <div class="v-side-empty">Loading cron jobsâ€¦</div>
    </div>
  </div>
</div>

<!-- â•â•â• Memory Panel â•â•â• -->
<div class="v-side-overlay" id="vMemoryOverlay">
  <div class="v-side-backdrop" id="vMemoryBackdrop"></div>
  <div class="v-side-panel" style="width:460px;">
    <div class="v-side-header">
      <div class="v-side-title"><span>ğŸ§ </span> Fleet Memory</div>
      <button class="v-side-close" id="vMemoryClose">Ã—</button>
    </div>
    <div class="v-side-body" id="vMemoryBody">
      <div class="v-side-empty">Loading memoryâ€¦</div>
    </div>
  </div>
</div>

<!-- â•â•â• Settings Panel â•â•â• -->
<div class="v-side-overlay" id="vSettingsOverlay">
  <div class="v-side-backdrop" id="vSettingsBackdrop"></div>
  <div class="v-side-panel" style="max-width:460px;">
    <div class="v-side-header">
      <div class="v-side-title"><span>âš™ï¸</span> Settings</div>
      <button class="v-side-close" id="vSettingsClose">Ã—</button>
    </div>
    <div class="v-side-body" id="vSettingsBody">
      <div class="v-side-empty">Loading settingsâ€¦</div>
    </div>
  </div>
</div>

<!-- â•â•â• Toast â•â•â• -->
<div class="v-toast" id="vToast"></div>

<script>
// ================================================================
// ISOMETRIC VILLAGE â€” Canvas 2D, Kenney Nature Kit + Mini Characters
// ================================================================
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');

// Tile geometry constants (source image pixels)
const SRC = 512;          // source image size (square)
const DW = 130;           // diamond width in source
const DH = 65;            // diamond height in source  
const DCX = 256;          // diamond center X in source
const DTY = 283;          // diamond top Y in source

let scale = 1.0;
const MIN_S = 0.3, MAX_S = 3.0;

// Viewport
let vpX = 0, vpY = 0;
let drag = false, dsx = 0, dsy = 0, dvx = 0, dvy = 0;

const MAP = 20;
window._debugFacing = new URLSearchParams(window.location.search).has('debug');
let selectedAgentName = null;

// ================================================================
// ISO MATH
// ================================================================
function iso(c, r) {
  const tw = DW * scale;
  const th = DH * scale;
  return {
    x: (c - r) * tw / 2,
    y: (c + r) * th / 2
  };
}

function toScreen(x, y) {
  return { x: x + vpX + cvs.width / 2, y: y + vpY + cvs.height / 3.5 };
}

function draw(img, c, r) {
  if (!img || !img.complete || !img.naturalWidth) return;
  const { x, y } = iso(c, r);
  const s = toScreen(x, y);
  const imgScale = scale;
  const iw = SRC * imgScale;
  const ih = SRC * imgScale;
  ctx.drawImage(img,
    s.x - DCX * imgScale,
    s.y - DTY * imgScale,
    iw, ih
  );
}

function screenToTile(sx, sy) {
  const rx = sx - vpX - cvs.width / 2;
  const ry = sy - vpY - cvs.height / 3.5;
  const tw = DW * scale;
  const th = DH * scale;
  const a = 2 * rx / tw;
  const b = 2 * ry / th;
  return { col: Math.floor((a + b) / 2), row: Math.floor((b - a) / 2) };
}

// ================================================================
// AGENTS
// ================================================================
const agents = [
  { name: 'ApoMac', role: 'CEO',      emoji: 'ğŸ', color: '#007AFF', row: 6,  col: 5  },
  { name: 'Forge',  role: 'CTO',      emoji: 'ğŸ”¨', color: '#FF9F0A', row: 6,  col: 13 },
  { name: 'Hunter', role: 'CRO',      emoji: 'ğŸ¯', color: '#FF453A', row: 11, col: 4  },
  { name: 'Echo',   role: 'CMO',      emoji: 'ğŸ“¢', color: '#0A84FF', row: 11, col: 14 },
  { name: 'Sentinel', role: 'Security', emoji: 'ğŸ›¡ï¸', color: '#30D158', row: 14, col: 7  },
  { name: 'Atlas',  role: 'COO',      emoji: 'ğŸ“Š', color: '#BF5AF2', row: 14, col: 11 },
];
agents.forEach(a => a.status = 'Active');

// Agent â†’ Kenney character mapping
const AGENT_CHAR = {
  'ApoMac':   'character-male-a',
  'Forge':    'character-male-c',
  'Hunter':   'character-male-d',
  'Atlas':    'character-female-a',
  'Echo':     'character-female-c',
  'Sentinel': 'character-male-e'
};

// ================================================================
// MAP DATA
// ================================================================
const ground = [];
const objects = [];

for (let r = 0; r < MAP; r++) {
  ground[r] = new Array(MAP).fill(0);
  objects[r] = new Array(MAP).fill(null);
}

let _seed = 42;
function rng() { _seed = (_seed * 16807) % 2147483647; return _seed / 2147483647; }

function P(r, c) { if (r >= 0 && r < MAP && c >= 0 && c < MAP) ground[r][c] = 1; }

for (let c = 2; c < 18; c++) { P(8, c); P(9, c); }
for (let r = 6; r <= 8; r++)  { P(r, 5); P(r, 6); }
for (let r = 6; r <= 8; r++)  { P(r, 13); P(r, 14); }
for (let r = 9; r <= 11; r++) { P(r, 4); P(r, 5); }
for (let r = 9; r <= 11; r++) { P(r, 14); P(r, 15); }
for (let r = 9; r <= 14; r++) { P(r, 7); P(r, 8); }
for (let r = 9; r <= 14; r++) { P(r, 11); P(r, 12); }

function O(r, c, name) { if (r >= 0 && r < MAP && c >= 0 && c < MAP && !objects[r][c]) objects[r][c] = name; }

const trees = [
  'tree_default_NE','tree_default_dark_NE','tree_oak_NE','tree_oak_dark_NE',
  'tree_detailed_NE','tree_detailed_dark_NE','tree_thin_NE','tree_thin_dark_NE',
  'tree_pineRoundA_NE','tree_pineRoundB_NE'
];
const fallTrees = [
  'tree_default_fall_NE','tree_oak_fall_NE','tree_detailed_fall_NE',
  'tree_thin_fall_NE','tree_small_fall_NE'
];
const flowers = [
  'flower_redA_NE','flower_redB_NE','flower_redC_NE',
  'flower_yellowA_NE','flower_yellowB_NE','flower_yellowC_NE',
  'flower_purpleA_NE','flower_purpleB_NE','flower_purpleC_NE'
];
const deco = [
  ...flowers, 'mushroom_red_NE','mushroom_tan_NE',
  'rock_smallA_NE','rock_smallB_NE','stone_smallA_NE','stone_smallB_NE',
  'plant_bushSmall_NE','plant_bush_NE'
];
const crops = ['crop_pumpkin_NE','crop_carrot_NE','crop_melon_NE','crop_turnip_NE'];

function rndTree() { return rng() < 0.35 ? fallTrees[Math.floor(rng()*fallTrees.length)] : trees[Math.floor(rng()*trees.length)]; }

for (let r = 0; r <= 2; r++)
  for (let c = 0; c < MAP; c++)
    if (rng() < 0.78) O(r, c, rndTree());

for (let r = 3; r <= 4; r++)
  for (let c = 0; c < MAP; c++) {
    if (rng() < 0.3) O(r, c, rndTree());
    else if (rng() < 0.08) O(r, c, rng()<0.5 ? 'mushroom_redGroup_NE' : 'mushroom_tanGroup_NE');
  }

for (let r = 18; r <= 19; r++)
  for (let c = 0; c < MAP; c++)
    if (rng() < 0.72) O(r, c, rndTree());

for (let r = 3; r < 18; r++) {
  if (rng() < 0.6) O(r, 0, rndTree());
  if (rng() < 0.55) O(r, 1, rndTree());
  if (rng() < 0.6) O(r, 19, rndTree());
  if (rng() < 0.55) O(r, 18, rndTree());
}

agents.forEach(a => O(a.row, a.col, 'tent_detailedOpen_NE'));

O(8, 10, 'campfire_stones_NE');
O(9, 9, 'campfire_logs_NE');

O(5, 5, 'log_stack_NE');
O(5, 13, 'log_stackLarge_NE');
O(12, 4, 'log_NE');
O(12, 14, 'log_large_NE');
O(7, 9, 'sign_NE');
O(7, 10, 'sign_NE');
O(4, 8, 'stump_round_NE');
O(4, 12, 'stump_old_NE');

for (let r = 5; r <= 17; r++)
  for (let c = 2; c < 18; c++)
    if (!objects[r][c] && ground[r][c] !== 1 && rng() < 0.1)
      O(r, c, deco[Math.floor(rng() * deco.length)]);

for (let r = 15; r <= 17; r++)
  for (let c = 3; c < 17; c++)
    if (!objects[r][c] && ground[r][c] !== 1 && rng() < 0.22)
      O(r, c, rng() < 0.5 ? flowers[Math.floor(rng()*flowers.length)] : crops[Math.floor(rng()*crops.length)]);

for (let c = 3; c < 17; c++)
  if (!objects[15][c] && ground[15][c] !== 1 && rng() < 0.25)
    O(15, c, 'fence_simple_NE');

// ================================================================
// IMAGE LOADING
// ================================================================
const SBASE = './lib/sprites/kenney-nature-kit/Isometric/';
const CHAR_BASE = './lib/sprites/kenney-mini-chars-upright/';

const imgs = {};
let totalImgs = 0, loadedImgs = 0;

function ld(key, path) {
  if (imgs[key]) return imgs[key];
  totalImgs++;
  const img = new Image();
  img.onload = () => loadedImgs++;
  img.onerror = () => { loadedImgs++; console.warn('Missing:', path); };
  img.src = path;
  imgs[key] = img;
  return img;
}

// Ground tiles
ld('ground', SBASE + 'ground_grass_NE.png');
ld('path', SBASE + 'ground_pathTile_NE.png');

// Collect all unique object names and load them
const objNames = new Set();
for (let r = 0; r < MAP; r++)
  for (let c = 0; c < MAP; c++)
    if (objects[r][c]) objNames.add(objects[r][c]);

objNames.forEach(n => ld('obj:' + n, SBASE + n + '.png'));

// ================================================================
// KENNEY MINI CHARACTER SPRITES
// 6 characters Ã— 2 anims Ã— 4 directions Ã— 8 frames = 384 sprites
// Path: {char}/{anim}_{char}/{dir}/frame_{NNN}.png
// ================================================================
const CHAR_NAMES = [
  'character-male-a', 'character-male-c', 'character-male-d',
  'character-female-a', 'character-female-c', 'character-male-e'
];
const ANIMS = ['idle', 'walk'];
const DIRS = ['NE', 'NW', 'SE', 'SW'];
const FRAME_COUNT = 8;

CHAR_NAMES.forEach(ch => {
  ANIMS.forEach(anim => {
    DIRS.forEach(dir => {
      for (let f = 0; f < FRAME_COUNT; f++) {
        const key = `char:${ch}:${anim}:${dir}:${f}`;
        const path = `${CHAR_BASE}${ch}/${anim}_${ch}/${dir}/frame_${String(f).padStart(3,'0')}.png`;
        ld(key, path);
      }
    });
  });
});

// ================================================================
// SPRITE TINT CACHE (warm sepia for Nature Kit cohesion)
// ================================================================
const _tintCache = {};
function getTinted(img, key) {
  if (_tintCache[key]) return _tintCache[key];
  if (!img || !img.complete || !img.naturalWidth) return null;
  const w = img.naturalWidth, h = img.naturalHeight;
  const tc = document.createElement('canvas');
  tc.width = w; tc.height = h;
  const tctx = tc.getContext('2d');
  tctx.drawImage(img, 0, 0);
  // Lift shadows: brighten dark areas without washing out lit areas
  // Uses 'lighter' composite to add light, then source-atop to tint
  const id = tctx.getImageData(0, 0, w, h);
  const px = id.data;
  for (let i = 0; i < px.length; i += 4) {
    if (px[i+3] === 0) continue; // skip transparent
    const brightness = (px[i] + px[i+1] + px[i+2]) / 3;
    if (brightness < 100) {
      // Lift dark pixels by ~60 to reduce harsh shadows
      const lift = Math.round(60 * (1 - brightness / 100));
      px[i]   = Math.min(255, px[i] + lift);
      px[i+1] = Math.min(255, px[i+1] + lift);
      px[i+2] = Math.min(255, px[i+2] + lift);
    }
  }
  tctx.putImageData(id, 0, 0);
  // Subtle warm tint
  tctx.globalCompositeOperation = 'source-atop';
  tctx.fillStyle = 'rgba(100, 90, 40, 0.05)';
  tctx.fillRect(0, 0, w, h);
  tctx.globalCompositeOperation = 'source-over';
  _tintCache[key] = tc;
  return tc;
}

// ================================================================
// SMART AGENT BEHAVIOR
// ================================================================

// Behavior states
const STATE = {
  WORKING: 'working',      // Idle at home tent, working
  WALKING_TO_POI: 'walk_poi',  // Walking to a point of interest
  AT_CAMPFIRE: 'at_campfire',  // Socializing at campfire
  WALKING_TO_AGENT: 'walk_agent', // Walking to visit another agent
  MEETING: 'meeting',      // Chatting with another agent
  RETURNING: 'returning',  // Walking back home
};

// Speech bubble pools
const WORK_BUBBLES = {
  'ApoMac': ['ğŸ’¡ Vision planning...','ğŸ“‹ Revenue target...','ğŸ Ship it!','ğŸ’­ Think different','ğŸ¯ Board meeting','ğŸ“Š Q3 review'],
  'Forge':  ['âŒ¨ï¸ Refactoring...','ğŸ” PR review','ğŸš€ Deploying...','ğŸ› Bug squashed!','ğŸ”§ CI pipeline','ğŸ’» Coding...'],
  'Hunter': ['ğŸ¯ New lead found','ğŸ“ Cold outreach','ğŸ“ˆ Pipeline +1','ğŸ¤ Closing deal...','ğŸ’° Revenue!','ğŸ“§ Follow-up'],
  'Atlas':  ['âš™ï¸ Systems nominal','âœ… Ops check','ğŸ“Š SLA: 99.9%','ğŸ”„ Scaling up','ğŸ“‹ Process audit','ğŸ—‚ï¸ Sprint plan'],
  'Echo':   ['ğŸ¨ Campaign live!','ğŸ“ˆ CTR +12%','âœï¸ Content draft','ğŸ­ Brand refresh','ğŸ“± Social push','ğŸ¬ Video edit'],
  'Sentinel':['ğŸ›¡ï¸ Audit clean','ğŸ” Scanning...','ğŸ”’ Vuln patched','âœ… All clear','ğŸ” Auth review','ğŸ“¡ Monitoring']
};

const SOCIAL_BUBBLES = [
  'â˜• Coffee break!', 'ğŸŒ¤ï¸ Great weather!', 'ğŸµ Humming...', 'ğŸ˜Š Good vibes',
  'ğŸ• Lunch soon?', 'ğŸ•ï¸ Love this spot', 'ğŸ”¥ Warm fire', 'ğŸ’¬ Team bonding',
  'ğŸŒ… Nice evening', 'âœ¨ Productive day!'
];

const COLLAB_BUBBLES = {
  'ApoMac': ["Let's align", 'Great progress!', 'Approved âœ…', 'Think bigger'],
  'Forge':  ["Let's sync", 'PR approved!', 'Ship tonight', 'Good code ğŸ‘'],
  'Hunter': ['Got a lead!', 'Pipeline update', 'Close this Q', 'Numbers up ğŸ“ˆ'],
  'Atlas':  ['Status update', 'On track âœ…', 'Let me check', 'Process done'],
  'Echo':   ['Campaign idea!', 'Collab post?', 'Brand check', 'Going viral!'],
  'Sentinel':['Security brief', 'All clear ğŸ›¡ï¸', 'Audit done', 'Patched it']
};

const EMOTION_EMOJIS = ['ğŸ’¡', 'ğŸ”¥', 'âœ…', 'ğŸ¯', 'ğŸ“Š', 'ğŸ›¡ï¸', 'âš¡', 'ğŸš€', 'ğŸ’ª', 'ğŸ†'];

// Campfire zone (tiles near the campfire objects)
const CAMPFIRE_ZONE = {c: 9.5, r: 8.8};

// BFS pathfinding on the ground grid (path tiles only)
function findPath(startC, startR, endC, endR) {
  const sc = Math.round(startC), sr = Math.round(startR);
  const ec = Math.round(endC), er = Math.round(endR);
  
  // Clamp to map bounds
  const clamp = (v) => Math.max(0, Math.min(MAP - 1, v));
  const s = {c: clamp(sc), r: clamp(sr)};
  const e = {c: clamp(ec), r: clamp(er)};
  
  // If start or end not on a path, find nearest path tile
  function nearestPath(c, r) {
    if (c >= 0 && c < MAP && r >= 0 && r < MAP && ground[r][c] === 1) return {c, r};
    let best = null, bestD = Infinity;
    for (let dr = -3; dr <= 3; dr++) {
      for (let dc = -3; dc <= 3; dc++) {
        const nc = c + dc, nr = r + dr;
        if (nc >= 0 && nc < MAP && nr >= 0 && nr < MAP && ground[nr][nc] === 1) {
          const d = dc*dc + dr*dr;
          if (d < bestD) { bestD = d; best = {c: nc, r: nr}; }
        }
      }
    }
    return best || {c, r};
  }
  
  const start = nearestPath(s.c, s.r);
  const end = nearestPath(e.c, e.r);
  
  if (start.c === end.c && start.r === end.r) return [{c: end.c + 0.5, r: end.r + 0.5}];
  
  // BFS
  const visited = {};
  const queue = [{c: start.c, r: start.r, path: []}];
  visited[`${start.c},${start.r}`] = true;
  
  const neighbors = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
  
  while (queue.length > 0) {
    const cur = queue.shift();
    
    for (const [dc, dr] of neighbors) {
      const nc = cur.c + dc, nr = cur.r + dr;
      const key = `${nc},${nr}`;
      
      if (nc < 0 || nc >= MAP || nr < 0 || nr >= MAP) continue;
      if (visited[key]) continue;
      if (ground[nr][nc] !== 1) continue;
      
      visited[key] = true;
      const newPath = [...cur.path, {c: nc + 0.5, r: nr + 0.5}];
      
      if (nc === end.c && nr === end.r) {
        return newPath;
      }
      
      queue.push({c: nc, r: nr, path: newPath});
    }
  }
  
  // No path found â€” just return direct endpoint (fallback)
  return [{c: end.c + 0.5, r: end.r + 0.5}];
}

// ================================================================
// CHARACTERS
// ================================================================
const ROLE_BUBBLES = WORK_BUBBLES; // alias for compatibility

// Find the best "in front of tent" position (adjacent path tile without object)
function findHomeTile(a) {
  // Prefer the tile just to the right (+col) or in front (+row) of the tent
  const candidates = [
    {r: a.row, c: a.col + 1},    // right
    {r: a.row + 1, c: a.col},    // below
    {r: a.row + 1, c: a.col + 1},// below-right
    {r: a.row - 1, c: a.col},    // above
    {r: a.row, c: a.col - 1},    // left
  ];
  for (const p of candidates) {
    if (p.r >= 0 && p.r < MAP && p.c >= 0 && p.c < MAP &&
        ground[p.r][p.c] === 1 && !objects[p.r][p.c]) {
      return {c: p.c + 0.5, r: p.r + 0.5};
    }
  }
  return {c: a.col + 0.5, r: a.row + 0.5};
}

const chars = agents.map((a, i) => {
  const home = findHomeTile(a);
  return {
  agent: a,
  charName: AGENT_CHAR[a.name],
  c: home.c, r: home.r,
  homeC: home.c, homeR: home.r,
  // Movement
  path: [],           // BFS path waypoints
  pathIdx: 0,         // current waypoint index
  moving: false,
  facing: 'SE',       // front-facing by default
  frame: 0,
  ft: 0,              // frame timer
  // Behavior
  state: STATE.WORKING,
  stateTimer: 3000 + Math.random() * 6000,  // time until next state change (staggered)
  meetTarget: null,    // which agent we're visiting
  meetTimer: 0,        // time spent at meeting point
  // Speech
  bubble: null,        // {text, life, maxLife}
  bubbleCd: 1000 + Math.random() * 3000,    // cooldown before next bubble
  // Emotion
  emotionEmoji: null,
  emotionTimer: 0,
};});

// Decide next action for an agent
function decideNextAction(ch) {
  const roll = Math.random();
  
  if (ch.state === STATE.WORKING) {
    // From working, decide what to do
    if (roll < 0.35) {
      // Go to campfire
      ch.state = STATE.WALKING_TO_POI;
      // Pick a spot around the campfire with some variety
      const angle = Math.random() * Math.PI * 2;
      const dist = 0.5 + Math.random() * 0.8;
      const destC = CAMPFIRE_ZONE.c + Math.cos(angle) * dist;
      const destR = CAMPFIRE_ZONE.r + Math.sin(angle) * dist;
      ch.path = findPath(ch.c, ch.r, destC, destR);
      ch.pathIdx = 0;
      ch.moving = true;
      ch.stateTimer = 0;
    } else if (roll < 0.65) {
      // Visit another agent
      const others = chars.filter(o => o !== ch);
      ch.meetTarget = others[Math.floor(Math.random() * others.length)];
      ch.state = STATE.WALKING_TO_AGENT;
      // Walk to the path near the other agent's tent (not on top of it)
      const target = ch.meetTarget.agent;
      ch.path = findPath(ch.c, ch.r, target.col + 0.5, target.row + 0.5);
      ch.pathIdx = 0;
      ch.moving = true;
      ch.stateTimer = 0;
    } else {
      // Stay working longer
      ch.stateTimer = 5000 + Math.random() * 10000;
    }
  } else if (ch.state === STATE.AT_CAMPFIRE) {
    // Leave campfire, return home
    ch.state = STATE.RETURNING;
    ch.path = findPath(ch.c, ch.r, ch.homeC, ch.homeR);
    ch.pathIdx = 0;
    ch.moving = true;
    ch.stateTimer = 0;
  } else if (ch.state === STATE.MEETING) {
    // Done meeting, return home
    ch.state = STATE.RETURNING;
    ch.path = findPath(ch.c, ch.r, ch.homeC, ch.homeR);
    ch.pathIdx = 0;
    ch.moving = true;
    ch.stateTimer = 0;
  }
}

// Determine facing direction from movement delta
// In isometric: screen_x = (col-row), screen_y = (col+row)
// So +col = SE on screen (right+down), +row = SW on screen (left+down)
// The dominant axis determines the facing direction.
function getFacing(dx, dy) {
  // dx = delta col, dy = delta row
  if (Math.abs(dx) >= Math.abs(dy)) {
    // Dominant movement along col axis
    return dx >= 0 ? 'SE' : 'NW';  // +col = SE (right+down), -col = NW (left+up)
  } else {
    // Dominant movement along row axis
    return dy >= 0 ? 'SW' : 'NE';  // +row = SW, -row = NE
  }
}

function updateChars(dt) {
  chars.forEach(ch => {
    // Bubble timers
    if (ch.bubbleCd > 0) ch.bubbleCd -= dt;
    if (ch.bubble) {
      ch.bubble.life -= dt;
      if (ch.bubble.life <= 0) ch.bubble = null;
    }
    if (ch.emotionTimer > 0) {
      ch.emotionTimer -= dt;
      if (ch.emotionTimer <= 0) ch.emotionEmoji = null;
    }
    
    // Movement along path
    if (ch.moving && ch.path.length > 0) {
      const target = ch.path[ch.pathIdx];
      if (!target) {
        ch.moving = false;
        ch.path = [];
        return;
      }
      
      const dx = target.c - ch.c;
      const dy = target.r - ch.r;
      const d = Math.sqrt(dx * dx + dy * dy);
      
      if (d < 0.1) {
        ch.c = target.c;
        ch.r = target.r;
        ch.pathIdx++;
        
        if (ch.pathIdx >= ch.path.length) {
          // Reached destination
          ch.moving = false;
          ch.path = [];
          ch.frame = 0;
          
          // Transition to arrived state
          if (ch.state === STATE.WALKING_TO_POI) {
            ch.state = STATE.AT_CAMPFIRE;
            ch.stateTimer = 5000 + Math.random() * 8000;
            // Show social bubble
            showBubble(ch, 'social');
          } else if (ch.state === STATE.WALKING_TO_AGENT) {
            ch.state = STATE.MEETING;
            ch.stateTimer = 3000 + Math.random() * 5000;
            // Show collab bubble
            showBubble(ch, 'collab');
          } else if (ch.state === STATE.RETURNING) {
            ch.state = STATE.WORKING;
            ch.stateTimer = 5000 + Math.random() * 10000;
            // Show work bubble
            showBubble(ch, 'work');
          }
        }
      } else {
        const spd = 0.0022 * dt;
        const mx = (dx / d) * spd;
        const my = (dy / d) * spd;
        ch.c += mx;
        ch.r += my;
        ch.facing = getFacing(mx, my);
        
        // Animate walk
        ch.ft += dt;
        if (ch.ft > 100) {
          ch.frame = (ch.frame + 1) % FRAME_COUNT;
          ch.ft -= 100;
        }
      }
    } else {
      // Not moving â€” animate idle (slower)
      ch.ft += dt;
      if (ch.ft > 200) {
        ch.frame = (ch.frame + 1) % FRAME_COUNT;
        ch.ft -= 200;
      }
      
      // State timer
      ch.stateTimer -= dt;
      if (ch.stateTimer <= 0) {
        decideNextAction(ch);
      }
      
      // Random work bubble when idle at home
      if (ch.state === STATE.WORKING && ch.bubbleCd <= 0 && !ch.bubble && Math.random() < 0.01) {
        showBubble(ch, 'work');
      }
      // Random emotion emoji
      if (!ch.emotionEmoji && Math.random() < 0.002) {
        ch.emotionEmoji = EMOTION_EMOJIS[Math.floor(Math.random() * EMOTION_EMOJIS.length)];
        ch.emotionTimer = 2000 + Math.random() * 2000;
      }
    }
  });
}

function showBubble(ch, type) {
  if (ch.bubbleCd > 0) return;
  let text;
  if (type === 'social') {
    text = SOCIAL_BUBBLES[Math.floor(Math.random() * SOCIAL_BUBBLES.length)];
  } else if (type === 'collab') {
    const pool = COLLAB_BUBBLES[ch.agent.name] || ['Hey!'];
    text = pool[Math.floor(Math.random() * pool.length)];
  } else {
    const pool = WORK_BUBBLES[ch.agent.name] || ['Working...'];
    text = pool[Math.floor(Math.random() * pool.length)];
  }
  ch.bubble = { text, life: 3500, maxLife: 3500 };
  ch.bubbleCd = 6000 + Math.random() * 4000;
}

// ================================================================
// CHARACTER RENDERING
// Sprite data: 256Ã—256 PNG, content centered ~X=128, feet ~Y=172-188
// ================================================================

// Character content metrics (approximate from bbox analysis)
// Metrics updated for v5 sprites (25Â° camera elevation)
const CHAR_METRICS = {
  'character-male-a':   { feetY: 197, headY: 90, centerX: 127, contentH: 107 },
  'character-male-c':   { feetY: 197, headY: 74, centerX: 128, contentH: 123 },
  'character-male-d':   { feetY: 197, headY: 85, centerX: 128, contentH: 112 },
  'character-female-a': { feetY: 209, headY: 78, centerX: 128, contentH: 131 },
  'character-female-c': { feetY: 197, headY: 78, centerX: 128, contentH: 119 },
  'character-male-e':   { feetY: 197, headY: 90, centerX: 128, contentH: 107 },
};

// Sprite direction remap â€” confirmed by Kira via sprite-test.html:
// Folders are mirrored leftâ†”right. SEâ†”SW and NEâ†”NW need swapping.
const SPRITE_DIR_REMAP = { 'SE': 'SW', 'SW': 'SE', 'NW': 'NE', 'NE': 'NW' };

function drawChar(ch) {
  const anim = ch.moving ? 'walk' : 'idle';
  const dir = SPRITE_DIR_REMAP[ch.facing] || ch.facing;
  const key = `char:${ch.charName}:${anim}:${dir}:${ch.frame}`;
  const rawImg = imgs[key];
  if (!rawImg || !rawImg.complete || !rawImg.naturalWidth) return;
  
  const sprite = getTinted(rawImg, key) || rawImg;
  const metrics = CHAR_METRICS[ch.charName];

  const { x, y } = iso(ch.c, ch.r);
  const s = toScreen(x, y);

  // Scale character to fit nicely in ~1 tile (v5 sprites have contentH ~107-131px)
  const targetH = DH * scale * 1.2;
  const imgScale = targetH / metrics.contentH;
  const dw = 256 * imgScale;
  const dh = 256 * imgScale;

  // Position: feet grounded at tile center
  const feetScreenY = s.y + DH * scale * 0.65;
  const drawX = s.x - metrics.centerX * imgScale;
  const drawY = feetScreenY - metrics.feetY * imgScale;

  // Elliptical shadow snug under feet â€” per-character offset for best alignment
  const shadowOffsets = {
    'character-female-a': 6,   // Atlas â€” taller sprite, needs more lift
    'character-female-c': 4,
    'character-male-a': 4,
    'character-male-c': 4,
    'character-male-d': 4,
    'character-male-e': 4,
  };
  const shadowY = feetScreenY - (shadowOffsets[ch.charName] || 4) * scale;
  ctx.save();
  const shW = 14 * scale;
  const shH = 5 * scale;
  const sg = ctx.createRadialGradient(s.x, shadowY, 0, s.x, shadowY, shW);
  sg.addColorStop(0, 'rgba(10, 25, 10, 0.22)');
  sg.addColorStop(0.6, 'rgba(10, 25, 10, 0.06)');
  sg.addColorStop(1, 'rgba(10, 25, 10, 0)');
  ctx.beginPath();
  ctx.ellipse(s.x, shadowY, shW, shH, 0, 0, Math.PI * 2);
  ctx.fillStyle = sg;
  ctx.fill();
  ctx.restore();

  // Selection highlight â€” pulsing glow ring under selected agent
  if (selectedAgentName && ch.agent.name === selectedAgentName) {
    ctx.save();
    const pulse = 0.6 + 0.4 * Math.sin(Date.now() * 0.004);
    const glowW = shW * 1.8;
    const glowH = shH * 1.8;
    ctx.beginPath();
    ctx.ellipse(s.x, shadowY, glowW, glowH, 0, 0, Math.PI * 2);
    const agentCol = ch.agent.color || '#34C759';
    const gg = ctx.createRadialGradient(s.x, shadowY, 0, s.x, shadowY, glowW);
    gg.addColorStop(0, agentCol + Math.round(90 * pulse).toString(16).padStart(2,'0'));
    gg.addColorStop(0.6, agentCol + Math.round(40 * pulse).toString(16).padStart(2,'0'));
    gg.addColorStop(1, agentCol + '00');
    ctx.fillStyle = gg;
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(s.x, shadowY, shW * 1.3, shH * 1.3, 0, 0, Math.PI * 2);
    ctx.strokeStyle = agentCol;
    ctx.lineWidth = 2 * scale * pulse;
    ctx.globalAlpha = 0.8 * pulse;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // Draw character sprite
  ctx.drawImage(sprite, drawX, drawY, dw, dh);
  
  // DEBUG: facing direction â€” enable with ?debug=1 in URL
  if (window._debugFacing) {
    ctx.save();
    ctx.font = `bold ${Math.max(8, 10 * scale)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = ch.moving ? '#ff0' : '#0ff';
    ctx.fillText(ch.facing + (ch.moving ? 'â†’' : 'â€¢'), s.x, feetScreenY + 12 * scale);
    ctx.restore();
  }

  // Emotion emoji (floating above head)
  if (ch.emotionEmoji && ch.emotionTimer > 0) {
    const headScreenY = drawY + metrics.headY * imgScale;
    const eAlpha = ch.emotionTimer < 500 ? ch.emotionTimer / 500 : 1;
    const eFloat = Math.sin(Date.now() * 0.004) * 3 * scale;
    ctx.save();
    ctx.globalAlpha = eAlpha * 0.9;
    ctx.font = `${Math.max(10, 14 * scale)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(ch.emotionEmoji, s.x, headScreenY - 8 * scale + eFloat);
    ctx.restore();
  }
  
  // Speech bubble
  if (ch.bubble) {
    const headScreenY = drawY + metrics.headY * imgScale;
    const fadeIn = ch.bubble.life > ch.bubble.maxLife - 500 ? (ch.bubble.maxLife - ch.bubble.life) / 500 : 1;
    const fadeOut = ch.bubble.life < 500 ? ch.bubble.life / 500 : 1;
    const alpha = fadeIn * fadeOut;
    
    ctx.save();
    ctx.globalAlpha = alpha * 0.92;
    const bx = s.x;
    const by = headScreenY - 10 * scale;
    const fontSize = Math.max(8, 9 * scale);
    ctx.font = `${fontSize}px -apple-system, sans-serif`;
    const tw = ctx.measureText(ch.bubble.text).width;
    const pw = tw + 12 * scale, ph = 16 * scale;
    const bRad = 5 * scale;
    
    // Bubble background with slight gradient
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.beginPath();
    ctx.moveTo(bx - pw/2 + bRad, by - ph);
    ctx.lineTo(bx + pw/2 - bRad, by - ph);
    ctx.quadraticCurveTo(bx + pw/2, by - ph, bx + pw/2, by - ph + bRad);
    ctx.lineTo(bx + pw/2, by - bRad);
    ctx.quadraticCurveTo(bx + pw/2, by, bx + pw/2 - bRad, by);
    ctx.lineTo(bx + 3 * scale, by);
    ctx.lineTo(bx, by + 4 * scale);
    ctx.lineTo(bx - 3 * scale, by);
    ctx.lineTo(bx - pw/2 + bRad, by);
    ctx.quadraticCurveTo(bx - pw/2, by, bx - pw/2, by - bRad);
    ctx.lineTo(bx - pw/2, by - ph + bRad);
    ctx.quadraticCurveTo(bx - pw/2, by - ph, bx - pw/2 + bRad, by - ph);
    ctx.fill();
    
    // Subtle border
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 0.5;
    ctx.stroke();
    
    // Text
    ctx.fillStyle = '#eef0ee';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ch.bubble.text, bx, by - ph/2);
    ctx.restore();
  }
}

// ================================================================
// PARTICLES â€” Campfire embers + floating ambient (fireflies/pollen)
// ================================================================
const particles = [];

function spawnCampfireParticle() {
  [[10, 8], [9, 9]].forEach(([pc, pr]) => {
    if (Math.random() < 0.3) {
      const { x, y } = iso(pc + 0.5, pr + 0.5);
      const s = toScreen(x, y);
      particles.push({
        x: s.x + (Math.random() - 0.5) * 10 * scale,
        y: s.y,
        vx: (Math.random() - 0.5) * 0.3,
        vy: -0.5 - Math.random() * 0.8,
        life: 1, decay: 0.005 + Math.random() * 0.008,
        size: 1.5 + Math.random() * 2.5,
        type: 'fire',
        color: Math.random() < 0.6 ? '#ff8a3a' : (Math.random() < 0.5 ? '#ffcc44' : '#ff5533')
      });
    }
  });
}

function spawnAmbientParticle() {
  const rc = 2 + Math.random() * (MAP - 4);
  const rr = 2 + Math.random() * (MAP - 4);
  const { x, y } = iso(rc, rr);
  const s = toScreen(x, y);
  particles.push({
    x: s.x, y: s.y,
    vx: (Math.random() - 0.5) * 0.15,
    vy: -0.1 + (Math.random() - 0.5) * 0.1,
    life: 1, decay: 0.002 + Math.random() * 0.003,
    size: 1 + Math.random() * 1.5,
    type: 'ambient',
    phase: Math.random() * Math.PI * 2,
    color: Math.random() < 0.5 ? '#e8d888' : '#aad488'
  });
}

function updateAndDrawParticles(tick) {
  if (tick % 3 === 0) spawnCampfireParticle();
  if (tick % 12 === 0) spawnAmbientParticle();
  
  ctx.save();
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life -= p.decay;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    
    if (p.type === 'fire') {
      ctx.globalAlpha = p.life * 0.8;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * scale * p.life, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = p.life * 0.15;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * scale * 3, 0, Math.PI * 2);
      ctx.fill();
    } else {
      const drift = Math.sin(tick * 0.02 + p.phase) * 0.3;
      p.x += drift;
      ctx.globalAlpha = p.life * 0.35;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * scale, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.restore();
  
  // Campfire glow
  [[10, 8], [9, 9]].forEach(([pc, pr]) => {
    const { x, y } = iso(pc + 0.5, pr + 0.5);
    const s = toScreen(x, y);
    ctx.save();
    const pulse = 0.06 + 0.02 * Math.sin(tick * 0.08);
    ctx.globalAlpha = pulse;
    const glow = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, DW * scale * 1.5);
    glow.addColorStop(0, 'rgba(255, 140, 50, 0.3)');
    glow.addColorStop(0.5, 'rgba(255, 100, 30, 0.1)');
    glow.addColorStop(1, 'rgba(255, 80, 20, 0)');
    ctx.fillStyle = glow;
    ctx.fillRect(s.x - DW * scale * 2, s.y - DH * scale * 2, DW * scale * 4, DH * scale * 4);
    ctx.restore();
  });
}

// ================================================================
// RENDERING
// ================================================================
let _tick = 0;
function render() {
  _tick++;
  ctx.clearRect(0, 0, cvs.width, cvs.height);

  const bg = ctx.createRadialGradient(
    cvs.width / 2, cvs.height / 2, 0,
    cvs.width / 2, cvs.height / 2, cvs.width * 0.7
  );
  bg.addColorStop(0, '#1e3a1e');
  bg.addColorStop(1, '#0a150a');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, cvs.width, cvs.height);

  // Pass 1: Draw ground tiles and flat paths (never occlude anything)
  for (let r = 0; r < MAP; r++) {
    for (let c = 0; c < MAP; c++) {
      draw(imgs['ground'], c, r);
      if (ground[r][c] === 1) {
        draw(imgs['path'], c, r);
      }
    }
  }

  // Pass 2: Depth-sorted draw of objects + characters together
  // Build a list of all drawable entities with their iso depth (c + r)
  const drawables = [];
  for (let r = 0; r < MAP; r++) {
    for (let c = 0; c < MAP; c++) {
      const obj = objects[r][c];
      if (obj) {
        drawables.push({ type: 'obj', c, r, depth: c + r, obj });
      }
    }
  }
  chars.forEach(ch => {
    drawables.push({ type: 'char', c: ch.c, r: ch.r, depth: ch.c + ch.r, ch });
  });
  // Sort by depth (back to front); for same depth, objects before characters
  drawables.sort((a, b) => a.depth - b.depth || (a.type === 'obj' ? -1 : 1));
  drawables.forEach(d => {
    if (d.type === 'obj') {
      draw(imgs['obj:' + d.obj], d.c, d.r);
    } else {
      drawChar(d.ch);
    }
  });

  // Particles on top
  updateAndDrawParticles(_tick);

  updateLabels();
}

// ================================================================
// LABELS (CSS overlays)
// ================================================================
const labelsCont = document.getElementById('labels');
const labelEls = {};
agents.forEach(a => {
  const el = document.createElement('div');
  el.className = 'agent-label';
  el.innerHTML = `<span class="dot" style="background:${a.color}"></span>${a.emoji} ${a.name}`;
  el.addEventListener('click', function(e) {
    e.stopPropagation();
    selectedAgentName = a.name;
    if (typeof openVillageDetail === 'function') openVillageDetail(a);
  });
  labelsCont.appendChild(el);
  labelEls[a.name] = el;
});

function updateLabels() {
  chars.forEach(ch => {
    const a = ch.agent;
    const { x, y } = iso(ch.c, ch.r);
    const s = toScreen(x, y);
    const el = labelEls[a.name];
    const metrics = CHAR_METRICS[ch.charName];
    
    // Position label above character head
    const targetH = DH * scale * 1.15;
    const imgScale = targetH / metrics.contentH;
    const headY = s.y + DH * scale * 0.15 - metrics.feetY * imgScale + metrics.headY * imgScale;
    const ly = headY - 14 * scale;
    
    el.style.left = s.x + 'px';
    el.style.top = ly + 'px';
    el.style.display = (s.x > -200 && s.x < cvs.width + 200 && ly > -80 && ly < cvs.height + 80) ? '' : 'none';
    // Show full label only for selected agent
    el.classList.toggle('selected', selectedAgentName === a.name);
  });
}

// ================================================================
// INFO PANEL
// ================================================================
function showPanel(a) {
  document.getElementById('pn').textContent = `${a.emoji} ${a.name}`;
  document.getElementById('pr').textContent = a.role;
  const ch = chars.find(c => c.agent === a);
  const stateLabel = {
    'working': 'ğŸ’» Working at tent',
    'walk_poi': 'ğŸš¶ Heading to campfire',
    'at_campfire': 'â˜• At the campfire',
    'walk_agent': 'ğŸš¶ Visiting a colleague',
    'meeting': 'ğŸ¤ In a meeting',
    'returning': 'ğŸ  Returning home',
  };
  const stText = stateLabel[ch?.state] || 'Active';
  document.getElementById('ps').innerHTML = `<span style="color:${a.color}">â—</span> ${stText}`;
  document.getElementById('infopanel').style.display = 'block';
}
function closePanel() { document.getElementById('infopanel').style.display = 'none'; }

// ================================================================
// INPUT
// ================================================================
cvs.addEventListener('mousedown', e => {
  drag = true; dsx = e.clientX; dsy = e.clientY; dvx = vpX; dvy = vpY;
  cvs.classList.add('grabbing');
});
window.addEventListener('mousemove', e => {
  if (!drag) return;
  vpX = dvx + (e.clientX - dsx);
  vpY = dvy + (e.clientY - dsy);
});
window.addEventListener('mouseup', () => { drag = false; cvs.classList.remove('grabbing'); });

cvs.addEventListener('click', e => {
  if (Math.abs(e.clientX - dsx) > 4 || Math.abs(e.clientY - dsy) > 4) return;
  const t = screenToTile(e.clientX, e.clientY);
  // Also check proximity to character's current position (not just tent)
  let hit = null;
  let bestDist = Infinity;
  chars.forEach(ch => {
    const dc = Math.abs(ch.c - (t.col + 0.5));
    const dr = Math.abs(ch.r - (t.row + 0.5));
    const d = dc + dr;
    if (d < 2.5 && d < bestDist) {
      bestDist = d;
      hit = ch.agent;
    }
  });
  // Fallback: also check tent locations
  if (!hit) {
    hit = agents.find(a => Math.abs(a.col - t.col) <= 1 && Math.abs(a.row - t.row) <= 1);
  }
  if (hit) {
    selectedAgentName = hit.name;
    openVillageDetail(hit);
  } else {
    selectedAgentName = null;
    closeVillageDetail();
  }
});

cvs.addEventListener('wheel', e => {
  e.preventDefault();
  const f = e.deltaY > 0 ? 0.9 : 1.11;
  const ns = Math.max(MIN_S, Math.min(MAX_S, scale * f));
  const rx = e.clientX - vpX - cvs.width / 2;
  const ry = e.clientY - vpY - cvs.height / 3.5;
  const ratio = ns / scale;
  vpX -= rx * (ratio - 1);
  vpY -= ry * (ratio - 1);
  scale = ns;
}, { passive: false });

let td = 0;
cvs.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length === 1) {
    drag = true; dsx = e.touches[0].clientX; dsy = e.touches[0].clientY; dvx = vpX; dvy = vpY;
  } else if (e.touches.length === 2) {
    td = Math.hypot(e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY);
  }
}, { passive: false });
cvs.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 1 && drag) {
    vpX = dvx + (e.touches[0].clientX - dsx);
    vpY = dvy + (e.touches[0].clientY - dsy);
  } else if (e.touches.length === 2) {
    const d = Math.hypot(e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY);
    scale = Math.max(MIN_S, Math.min(MAX_S, scale * (d / td)));
    td = d;
  }
}, { passive: false });
cvs.addEventListener('touchend', () => { drag = false; });

function doZoom(f) { scale = Math.max(MIN_S, Math.min(MAX_S, scale * f)); }
function resetView() {
  scale = Math.max(MIN_S, Math.min(MAX_S, cvs.width / (12 * DW)));
  const ctr = iso(MAP / 2, MAP / 2);
  vpX = -ctr.x;
  vpY = -ctr.y;
}

// ================================================================
// RESIZE
// ================================================================
function resize() { cvs.width = innerWidth; cvs.height = innerHeight; }
addEventListener('resize', resize);
resize();

// ================================================================
// MAIN LOOP
// ================================================================
let lt = 0;
function loop(t) {
  const dt = lt ? Math.min(t - lt, 50) : 16;
  lt = t;
  updateChars(dt);
  render();
  requestAnimationFrame(loop);
}

// ================================================================
// THEME BRIDGE + DATA BRIDGE
// ================================================================
try { parent.postMessage({ type: 'theme:ready' }, '*'); } catch(e) {}

// postMessage bridge â€” listen for SpawnKit data updates
addEventListener('message', e => {
  if (!e.data || typeof e.data !== 'object') return;
  const isSameOrigin = (e.origin === window.location.origin || e.origin === 'null');
  if (!isSameOrigin) return;

  switch (e.data.type) {
    case 'theme:data':
    case 'spawnkit:data':
      if (e.data.agents || (e.data.payload && e.data.payload.agents)) {
        const agentList = e.data.agents || e.data.payload.agents;
        agentList.forEach(d => {
          const a = agents.find(x => x.name === d.name);
          if (a) {
            if (d.status) a.status = d.status;
            if (d.currentTask) a.task = d.currentTask;
          }
        });
        // Update agent count in status bar
        const countEl = document.getElementById('vsbAgentCount');
        if (countEl && agentList.length) {
          countEl.textContent = agentList.length + ' Agent' + (agentList.length !== 1 ? 's' : '');
        }
      }
      break;
    case 'spawnkit:agents':
      if (e.data.agents) {
        e.data.agents.forEach(d => {
          const a = agents.find(x => x.name === d.name);
          if (a && d.status) a.status = d.status;
        });
      }
      break;
    case 'spawnkit:ping':
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'village:pong', theme: 'simcity', timestamp: Date.now() }, '*');
      }
      break;
  }
});

// ================================================================
// INIT â€” wait for images, then start
// ================================================================
function checkReady() {
  const pct = totalImgs ? (loadedImgs / totalImgs * 100) : 0;
  document.getElementById('loadfill').style.width = pct + '%';
  if (loadedImgs >= totalImgs) {
    document.getElementById('loading').style.display = 'none';
    resetView();
    requestAnimationFrame(loop);
    initVillagePanels(); // Initialize panel system after village loads
  } else {
    requestAnimationFrame(checkReady);
  }
}
requestAnimationFrame(checkReady);
</script>

<!-- â•â•â• Data Bridge â•â•â• -->
<script>
  window.OC_RELAY_URL = 'https://fleet.spawnkit.ai';
  window.OC_RELAY_TOKEN = 'sk-oc-proxy-spawnkit-2026';
</script>
<script src="./src/data-bridge.js"></script>

<!-- â•â•â• Village Panel System â•â•â• -->
<script>
(function() {
  'use strict';

  // â”€â”€ SpawnKit API Reference â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  var API = (typeof window.spawnkitAPI !== 'undefined') ? window.spawnkitAPI : null;

  // â”€â”€ Agent Data Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  var AGENTS_MAP = {};
  var agentsList = [
    { id: 'ceo',      name: 'ApoMac',   role: 'CEO',         emoji: 'ğŸ', color: '#007AFF' },
    { id: 'forge',    name: 'Forge',     role: 'CTO',         emoji: 'ğŸ”¨', color: '#FF9F0A' },
    { id: 'hunter',   name: 'Hunter',    role: 'CRO',         emoji: 'ğŸ¯', color: '#FF453A' },
    { id: 'echo',     name: 'Echo',      role: 'CMO',         emoji: 'ğŸ“¢', color: '#0A84FF' },
    { id: 'sentinel', name: 'Sentinel',  role: 'Security',    emoji: 'ğŸ›¡ï¸', color: '#30D158' },
    { id: 'atlas',    name: 'Atlas',     role: 'COO',         emoji: 'ğŸ“Š', color: '#BF5AF2' },
  ];
  agentsList.forEach(function(a) { AGENTS_MAP[a.name] = a; AGENTS_MAP[a.id] = a; });

  var DEFAULT_SKILLS = {
    ceo:      ['ğŸ¯ Orchestration', 'ğŸ“Š Strategy', 'ğŸ”® Vision', 'ğŸ‘¥ Leadership'],
    atlas:    ['âš™ï¸ Operations', 'ğŸ“‹ Process', 'ğŸ“ Docs', 'ğŸ”„ Workflows'],
    forge:    ['ğŸ› ï¸ Engineering', 'ğŸ”’ Security', 'ğŸ—ï¸ Architecture', 'âš¡ Perf'],
    hunter:   ['ğŸ’° Revenue', 'ğŸ“ˆ Growth', 'ğŸ¯ Sales', 'ğŸ” Research'],
    echo:     ['ğŸ¨ Brand', 'ğŸ“± Content', 'ğŸ¬ Video', 'âœï¸ Copy'],
    sentinel: ['ğŸ›¡ï¸ Audit', 'âœ… QA', 'âš ï¸ Risk', 'ğŸ” Review']
  };

  // â”€â”€ Live Data Caches â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  var liveAgentData = {};
  var liveCronData = null;
  var liveMemoryData = null;
  var chatHistory = [];

  // â”€â”€ Pre-fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function prefetchData() {
    if (!API) return;
    try { liveCronData = API.getCrons(); } catch(e) {}
    try { liveMemoryData = API.getMemory(); } catch(e) {}
  }

  async function loadLiveAgentData() {
    var ids = ['ceo', 'atlas', 'forge', 'hunter', 'echo', 'sentinel'];
    if (!window.spawnkitAPI) {
      ids.forEach(function(id) {
        liveAgentData[id] = { currentTask: 'Connect to OpenClaw for live data', todos: [], skills: [] };
      });
      return;
    }
    try {
      var isAvail = await window.spawnkitAPI.isAvailable();
      if (!isAvail) return;
      var todoP = ids.map(function(id) { return window.spawnkitAPI.getAgentTodos(id); });
      var skillP = ids.map(function(id) { return window.spawnkitAPI.getAgentSkills(id); });
      var allTodos = await Promise.all(todoP);
      var allSkills = await Promise.all(skillP);
      ids.forEach(function(id, i) {
        var td = allTodos[i] || { todos: [], currentTask: 'Standby' };
        var sk = allSkills[i] || [];
        liveAgentData[id] = {
          currentTask: td.currentTask || 'Standby',
          todos: td.todos || [],
          skills: sk.map(function(s, idx) {
            return { name: s.name || s.dirName || 'Skill', description: s.description || '' };
          })
        };
      });
    } catch(e) {
      console.warn('ğŸ˜ï¸ [Village] Failed to load agent data:', e);
    }
  }

  // â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showToast(msg) {
    var t = document.getElementById('vToast');
    if (!t) return;
    t.textContent = msg;
    t.classList.add('show');
    clearTimeout(t._timer);
    t._timer = setTimeout(function() { t.classList.remove('show'); }, 2500);
  }

  // â”€â”€ Close All Panels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function closeAllPanels() {
    closeVillageDetail();
    closeVillageChat();
    closeMissionsPanel();
    closeCronPanel();
    closeMemoryPanel();
    closeSettingsPanel();
  }
  // Expose globally
  window.closeAllVillagePanels = closeAllPanels;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  AGENT DETAIL PANEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var detailOverlay = document.getElementById('vDetailOverlay');
  var detailBackdrop = document.getElementById('vDetailBackdrop');
  var detailCloseBtn = document.getElementById('vDetailClose');

  window.openVillageDetail = async function(agentObj) {
    closeAllPanels();
    var info = AGENTS_MAP[agentObj.name] || { id: 'ceo', name: agentObj.name, role: agentObj.role, emoji: agentObj.emoji, color: agentObj.color };
    var agentId = info.id;

    // Avatar
    var avatarEl = document.getElementById('vDetailAvatar');
    avatarEl.style.background = info.color;
    avatarEl.innerHTML = '<span style="font-size:26px">' + info.emoji + '</span><div class="v-detail-status-dot" id="vDetailStatusDot"></div>';
    var statusColor = (agentObj.status === 'Active' || agentObj.status === 'active' || agentObj.status === 'working') ? '#30D158' :
                      (agentObj.status === 'busy' || agentObj.status === 'building') ? '#FFD60A' : '#8E8E93';
    document.getElementById('vDetailStatusDot').style.background = statusColor;

    document.getElementById('vDetailName').textContent = info.emoji + ' ' + info.name;
    document.getElementById('vDetailRole').textContent = info.role;

    // Find character state
    var ch = null;
    if (typeof chars !== 'undefined') {
      ch = chars.find(function(c) { return c.agent === agentObj; });
    }
    var stateLabels = {
      'working': 'ğŸ’» Working at tent', 'walk_poi': 'ğŸš¶ Heading to campfire',
      'at_campfire': 'â˜• At the campfire', 'walk_agent': 'ğŸš¶ Visiting a colleague',
      'meeting': 'ğŸ¤ In a meeting', 'returning': 'ğŸ  Returning home'
    };
    var taskText = (ch && stateLabels[ch.state]) ? stateLabels[ch.state] : 'Active';
    document.getElementById('vDetailTask').textContent = taskText;

    // Build body
    var body = '';

    // Metrics
    body += '<div class="v-detail-section"><div class="v-section-title">Metrics</div>';
    body += '<div class="v-metrics">';
    body += '<div class="v-metric"><div class="v-metric-val">' + (statusColor === '#30D158' ? 'ğŸŸ¢' : 'ğŸ’¤') + '</div><div class="v-metric-lbl">Status</div></div>';
    body += '<div class="v-metric"><div class="v-metric-val">â€”</div><div class="v-metric-lbl">Tokens</div></div>';
    body += '<div class="v-metric"><div class="v-metric-val">â€”</div><div class="v-metric-lbl">API Calls</div></div>';
    body += '<div class="v-metric"><div class="v-metric-val">â€”</div><div class="v-metric-lbl">Last Active</div></div>';
    body += '</div></div>';

    // Live metrics
    if (API) {
      (async function() {
        try {
          var m = await API.getMetrics();
          if (m && m.agentBreakdown && m.agentBreakdown[agentId]) {
            var ab = m.agentBreakdown[agentId];
            var vals = document.querySelectorAll('#vDetailBody .v-metric-val');
            if (vals.length >= 4) {
              if (ab.tokens) vals[1].textContent = ab.tokens.toLocaleString();
              if (ab.apiCalls) vals[2].textContent = ab.apiCalls.toString();
              if (ab.lastActive) vals[3].textContent = ab.lastActive;
            }
          }
        } catch(e) {}
      })();
    }

    // TODO / Current Task
    var td = liveAgentData[agentId];
    if (td) {
      body += '<div class="v-detail-section"><div class="v-section-title">Current Task</div>';
      body += '<div style="font-size:13px;font-weight:500;color:var(--v-text)">' + (td.currentTask || taskText) + '</div>';
      body += '</div>';
      if (td.todos && td.todos.length) {
        body += '<div class="v-detail-section"><div class="v-section-title">TODO List</div>';
        td.todos.forEach(function(todo) {
          body += '<div class="v-todo-item' + (todo.status === 'done' ? ' v-todo-done' : '') + '">';
          body += '<span class="v-todo-icon">' + (todo.icon || 'â€¢') + '</span>';
          body += '<span class="v-todo-text">' + (todo.text || '') + '</span></div>';
        });
        body += '</div>';
      }
    }

    // Skills
    var skills = (td && td.skills && td.skills.length) ? td.skills : null;
    var fallbackSkills = DEFAULT_SKILLS[agentId] || [];
    body += '<div class="v-detail-section"><div class="v-section-title">Skills</div>';
    body += '<div class="v-skill-chips">';
    if (skills && skills.length) {
      skills.forEach(function(s) { body += '<span class="v-skill-chip">' + (s.name || s) + '</span>'; });
    } else if (fallbackSkills.length) {
      fallbackSkills.forEach(function(s) { body += '<span class="v-skill-chip">' + s + '</span>'; });
    } else {
      body += '<span style="color:var(--v-text-muted);font-size:11px">No skills defined</span>';
    }
    body += '</div></div>';

    // SOUL excerpt
    if (API) {
      try {
        var agentInfo = await API.getAgentInfo(agentId);
        if (agentInfo && agentInfo.soul) {
          var excerpt = agentInfo.soul.substring(0, 400);
          body += '<div class="v-detail-section"><div class="v-section-title">Soul (Personality)</div>';
          body += '<div class="v-soul-text">' + excerpt.replace(/</g,'&lt;').replace(/>/g,'&gt;') + (agentInfo.soul.length > 400 ? 'â€¦' : '') + '</div></div>';
        }
      } catch(e) {}
    }

    document.getElementById('vDetailBody').innerHTML = body;
    detailOverlay.classList.add('open');
    document.body.style.overflow = 'hidden';
  };

  window.closeVillageDetail = function() {
    detailOverlay.classList.remove('open');
    document.body.style.overflow = '';
  };

  detailBackdrop.addEventListener('click', closeVillageDetail);
  detailCloseBtn.addEventListener('click', closeVillageDetail);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  CEO CHAT PANEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var chatOverlay = document.getElementById('vChatOverlay');
  var chatBackdrop = document.getElementById('vChatBackdrop');
  var chatCloseBtn = document.getElementById('vChatClose');
  var chatMsgsEl = document.getElementById('vChatMessages');
  var chatInput = document.getElementById('vChatInput');
  var chatSendBtn = document.getElementById('vChatSend');
  var chatEmptyEl = document.getElementById('vChatEmpty');

  function openVillageChat() {
    closeAllPanels();
    chatOverlay.classList.add('open');
    chatInput.focus();
    document.body.style.overflow = 'hidden';
    loadChatTranscript();
  }
  window.closeVillageChat = function() {
    chatOverlay.classList.remove('open');
    document.body.style.overflow = '';
  };

  function loadChatTranscript() {
    if (!API) return;
    try {
      var transcript = API.getTranscript('agent:main:main');
      if (transcript && transcript.length > 0) {
        chatHistory = transcript.slice(-50).map(function(m) {
          return {
            role: m.role === 'user' ? 'user' : 'system',
            text: m.text || m.content || '',
            time: m.timestamp ? new Date(m.timestamp).toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'}) : ''
          };
        });
        renderChat();
      }
    } catch(e) {}
  }

  function renderChat() {
    if (chatHistory.length === 0) { chatEmptyEl.style.display = ''; return; }
    chatEmptyEl.style.display = 'none';
    chatMsgsEl.innerHTML = '';
    chatHistory.forEach(function(m) {
      var div = document.createElement('div');
      div.className = 'v-chat-msg v-chat-msg--' + m.role;
      var preview = m.text.length > 300 ? m.text.substring(0, 300) + 'â€¦' : m.text;
      div.innerHTML = '<div>' + preview.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</div>' +
        (m.time ? '<div class="v-chat-msg-time">' + m.time + '</div>' : '');
      chatMsgsEl.appendChild(div);
    });
    chatMsgsEl.scrollTop = chatMsgsEl.scrollHeight;
  }

  async function sendChat() {
    var text = chatInput.value.trim();
    if (!text) return;
    chatInput.value = '';
    var now = new Date();
    var timeStr = now.getHours().toString().padStart(2,'0') + ':' + now.getMinutes().toString().padStart(2,'0');
    chatHistory.push({ role: 'user', text: text, time: timeStr });
    renderChat();

    var route = document.getElementById('vChatRoute').value || 'ceo';
    if (API && typeof API.sendMission === 'function') {
      try {
        var result = await API.sendMission(text, route);
        if (result && result.success) {
          chatHistory.push({ role: 'system', text: 'âœ… Dispatched to ' + route, time: timeStr });
        } else {
          chatHistory.push({ role: 'system', text: 'âš ï¸ ' + (result.error || 'Failed'), time: timeStr });
        }
      } catch(e) {
        chatHistory.push({ role: 'system', text: 'âš ï¸ ' + e.message, time: timeStr });
      }
    } else {
      chatHistory.push({ role: 'system', text: 'ğŸ“¡ API not connected â€” queued', time: timeStr });
    }
    renderChat();
  }

  chatBackdrop.addEventListener('click', closeVillageChat);
  chatCloseBtn.addEventListener('click', closeVillageChat);
  chatSendBtn.addEventListener('click', sendChat);
  chatInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') { e.preventDefault(); sendChat(); }
  });

  // Auto-refresh chat
  setInterval(function() {
    if (chatOverlay.classList.contains('open')) loadChatTranscript();
  }, 10000);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  MISSIONS PANEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var missionsOverlay = document.getElementById('vMissionsOverlay');
  var missionsBody = document.getElementById('vMissionsBody');

  function openMissionsPanel() {
    closeAllPanels();
    missionsOverlay.classList.add('open');
    document.body.style.overflow = 'hidden';
    renderMissions();
  }
  window.closeMissionsPanel = function() {
    missionsOverlay.classList.remove('open');
    document.body.style.overflow = '';
  };

  async function renderMissions() {
    if (!API) {
      missionsBody.innerHTML = '<div class="v-side-empty">Connect to OpenClaw for live missions.</div>';
      return;
    }
    try {
      var sessions = await API.getSessions();
      var subs = sessions.subagents || [];
      var running = subs.filter(function(s) { return s.status === 'running'; });
      var completed = subs.filter(function(s) { return s.status === 'completed'; }).slice(0, 5);

      if (running.length === 0 && completed.length === 0) {
        missionsBody.innerHTML = '<div class="v-side-empty">No active missions. The village is at peace. ğŸŒ¿</div>';
        return;
      }

      var html = '';
      if (running.length > 0) {
        html += '<div class="v-side-group"><div class="v-side-group-title">ğŸ”´ Active (' + running.length + ')</div>';
        running.forEach(function(sa) {
          var dur = sa.durationMs ? Math.floor(sa.durationMs / 60000) : 0;
          var prog = sa.progress || 0.5;
          html += '<div class="v-side-item">';
          html += '<span class="v-side-item-icon">ğŸš€</span>';
          html += '<div class="v-side-item-info">';
          html += '<div class="v-side-item-name">' + (sa.name || sa.label || sa.id) + '</div>';
          html += '<div class="v-side-item-sub">Parent: ' + (sa.parentAgent || 'main') + ' â€¢ ' + dur + 'm</div>';
          html += '<div style="margin-top:3px;height:3px;background:var(--v-bg-deep);border-radius:2px;overflow:hidden"><div style="width:' + Math.round(prog*100) + '%;height:100%;background:var(--v-accent);border-radius:2px"></div></div>';
          html += '</div>';
          html += '<span class="v-side-badge v-side-badge--active">' + Math.round(prog*100) + '%</span>';
          html += '</div>';
        });
        html += '</div>';
      }
      if (completed.length > 0) {
        html += '<div class="v-side-group"><div class="v-side-group-title">âœ… Completed</div>';
        completed.forEach(function(sa) {
          html += '<div class="v-side-item" style="opacity:0.7">';
          html += '<span class="v-side-item-icon">âœ…</span>';
          html += '<div class="v-side-item-info"><div class="v-side-item-name">' + (sa.name || sa.label || sa.id) + '</div></div>';
          html += '<span class="v-side-badge v-side-badge--done">Done</span>';
          html += '</div>';
        });
        html += '</div>';
      }
      missionsBody.innerHTML = html;
    } catch(e) {
      missionsBody.innerHTML = '<div class="v-side-empty">Error: ' + e.message + '</div>';
    }
  }

  document.getElementById('vMissionsBackdrop').addEventListener('click', closeMissionsPanel);
  document.getElementById('vMissionsClose').addEventListener('click', closeMissionsPanel);

  setInterval(function() { if (missionsOverlay.classList.contains('open')) renderMissions(); }, 15000);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  CRON PANEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var cronOverlay = document.getElementById('vCronOverlay');
  var cronBody = document.getElementById('vCronBody');

  function openCronPanel() {
    closeAllPanels();
    cronOverlay.classList.add('open');
    document.body.style.overflow = 'hidden';
    renderCrons();
  }
  window.closeCronPanel = function() {
    cronOverlay.classList.remove('open');
    document.body.style.overflow = '';
  };

  function humanCron(s) {
    if (!s) return 'â€”';
    var m = { '*/30 * * * *': 'Every 30 min', '0 * * * *': 'Hourly',
              '0 9 * * *': 'Daily 9:00', '0 9 * * 1': 'Mon 9:00',
              '*/5 * * * *': 'Every 5 min', '0 */2 * * *': 'Every 2h',
              '0 8 * * 1-5': 'Weekdays 8:00' };
    return m[s] || s;
  }

  function renderCrons() {
    var crons = liveCronData;
    if (API && !crons) { try { crons = API.getCrons(); } catch(e) {} }

    if (!crons || !Array.isArray(crons) || crons.length === 0) {
      cronBody.innerHTML = '<div class="v-side-empty">No cron jobs found.' +
        (API ? '' : '<br><br><em>Connect to OpenClaw for live crons.</em>') + '</div>';
      return;
    }

    var groups = {};
    crons.forEach(function(c) {
      var o = c.owner || 'System';
      if (!groups[o]) groups[o] = [];
      groups[o].push(c);
    });

    var html = '';
    Object.keys(groups).forEach(function(owner) {
      html += '<div class="v-side-group"><div class="v-side-group-title">' + owner + '</div>';
      groups[owner].forEach(function(c) {
        var icon = c.status === 'active' ? 'â°' : c.status === 'error' ? 'âŒ' : 'â¸ï¸';
        var badgeCls = c.status === 'active' ? 'active' : c.status === 'error' ? 'error' : 'paused';
        var next = c.nextRun ? new Date(c.nextRun).toLocaleString('fr-FR', {month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'}) : 'â€”';
        html += '<div class="v-side-item">';
        html += '<span class="v-side-item-icon">' + icon + '</span>';
        html += '<div class="v-side-item-info">';
        html += '<div class="v-side-item-name">' + (c.name || c.id || 'Unnamed') + '</div>';
        html += '<div class="v-side-item-sub">' + humanCron(c.schedule) + '</div>';
        html += '<div class="v-side-item-accent">Next: ' + next + '</div>';
        html += '</div>';
        html += '<span class="v-side-badge v-side-badge--' + badgeCls + '">' + (c.status || '?') + '</span>';
        html += '<button class="v-side-toggle ' + (c.status === 'active' ? 'on' : '') + '"></button>';
        html += '</div>';
      });
      html += '</div>';
    });
    cronBody.innerHTML = html;

    cronBody.querySelectorAll('.v-side-toggle').forEach(function(btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        btn.classList.toggle('on');
        showToast('Connect to OpenClaw CLI to modify cron jobs');
      });
    });
  }

  document.getElementById('vCronBackdrop').addEventListener('click', closeCronPanel);
  document.getElementById('vCronClose').addEventListener('click', closeCronPanel);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  MEMORY PANEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var memoryOverlay = document.getElementById('vMemoryOverlay');
  var memoryBody = document.getElementById('vMemoryBody');

  function openMemoryPanel() {
    closeAllPanels();
    memoryOverlay.classList.add('open');
    document.body.style.overflow = 'hidden';
    renderMemory();
  }
  window.closeMemoryPanel = function() {
    memoryOverlay.classList.remove('open');
    document.body.style.overflow = '';
  };

  function renderMarkdown(md) {
    if (!md) return '<em>Empty</em>';
    return md
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/^### (.+)$/gm,'<h3>$1</h3>')
      .replace(/^## (.+)$/gm,'<h2>$1</h2>')
      .replace(/^# (.+)$/gm,'<h1>$1</h1>')
      .replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>')
      .replace(/`(.+?)`/g,'<code>$1</code>')
      .replace(/^- (.+)$/gm,'<li>$1</li>')
      .replace(/\n{2,}/g,'<br><br>')
      .replace(/\n/g,'<br>');
  }

  function renderMemory() {
    var mem = liveMemoryData;
    if (API && !mem) { try { mem = API.getMemory(); } catch(e) {} }

    if (!mem) {
      memoryBody.innerHTML = '<div class="v-side-empty">No memory available.' +
        (API ? '' : '<br><br><em>Connect to OpenClaw for fleet memory.</em>') + '</div>';
      return;
    }

    var html = '';

    // Golden rules
    if (mem.longTerm && mem.longTerm.content) {
      var content = mem.longTerm.content;
      var goldenMatch = content.match(/## ğŸ”´[^\n]*\n[\s\S]*?(?=\n## |$)/g);
      if (goldenMatch && goldenMatch.length > 0) {
        html += '<div class="v-side-group"><div class="v-side-group-title">Golden Rules</div>';
        goldenMatch.forEach(function(rule) {
          html += '<div class="v-memory-golden"><div class="v-memory-md">' + renderMarkdown(rule.trim()) + '</div></div>';
        });
        html += '</div>';
      }

      html += '<div class="v-side-group"><div class="v-side-group-title">MEMORY.md <span style="font-weight:400;color:var(--v-text-muted);text-transform:none;letter-spacing:0">(' + (mem.longTerm.size ? (mem.longTerm.size / 1024).toFixed(1) + ' KB' : 'â€”') + ')</span></div>';
      html += '<div class="v-memory-md">' + renderMarkdown(content.substring(0, 3000)) + '</div>';
      if (content.length > 3000) {
        html += '<div style="color:var(--v-text-muted);font-size:10px;margin-top:6px">â€¦truncated (' + content.length + ' chars)</div>';
      }
      html += '</div>';
    }

    if (mem.daily && mem.daily.length > 0) {
      html += '<div class="v-side-group"><div class="v-side-group-title">Daily Notes</div>';
      mem.daily.slice(0, 14).forEach(function(d) {
        html += '<div class="v-memory-daily">';
        html += '<span class="v-memory-daily-date">' + (d.date || d.name || 'â€”') + '</span>';
        html += '<span style="flex:1;color:var(--v-text-secondary);font-size:11px;padding:0 8px">' + (d.preview || 'Daily log') + '</span>';
        html += '<span class="v-memory-daily-size">' + (d.size ? (d.size / 1024).toFixed(1) + ' KB' : '') + '</span>';
        html += '</div>';
      });
      html += '</div>';
    }

    if (mem.heartbeat) {
      html += '<div class="v-side-group"><div class="v-side-group-title">Heartbeat State</div>';
      html += '<div class="v-memory-md"><pre style="font-size:10px;background:var(--v-bg-card);padding:8px;border-radius:8px;overflow-x:auto;color:var(--v-text-secondary)">' + JSON.stringify(mem.heartbeat, null, 2).replace(/</g,'&lt;') + '</pre></div>';
      html += '</div>';
    }

    html += '<div class="v-side-group"><div style="text-align:center;color:var(--v-text-muted);font-size:11px">ğŸ”’ Only the village chief can edit memory</div></div>';

    memoryBody.innerHTML = html;
  }

  document.getElementById('vMemoryBackdrop').addEventListener('click', closeMemoryPanel);
  document.getElementById('vMemoryClose').addEventListener('click', closeMemoryPanel);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  SETTINGS PANEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var settingsOverlay = document.getElementById('vSettingsOverlay');
  var settingsBody = document.getElementById('vSettingsBody');

  function openSettingsPanel() {
    closeAllPanels();
    settingsOverlay.classList.add('open');
    document.body.style.overflow = 'hidden';
    renderSettings();
  }
  window.closeSettingsPanel = function() {
    settingsOverlay.classList.remove('open');
    document.body.style.overflow = '';
  };

  async function renderSettings() {
    var html = '';

    // API Keys
    html += '<div class="v-side-group"><div class="v-side-group-title">ğŸ”‘ API Keys</div>';
    var providers = ['anthropic', 'openai', 'elevenlabs', 'google'];
    var labels = { anthropic: 'Anthropic', openai: 'OpenAI', elevenlabs: 'ElevenLabs', google: 'Google' };
    var prefixes = { anthropic: 'sk-ant-', openai: 'sk-', elevenlabs: '', google: '' };

    var currentKeys = {};
    if (API) { try { currentKeys = await API.getApiKeys(); } catch(e) {} }

    providers.forEach(function(prov) {
      var info = currentKeys[prov] || {};
      var masked = info.hasKey ? info.masked : 'Not set';
      html += '<div class="v-side-item" style="flex-wrap:wrap;gap:8px">';
      html += '<div class="v-side-item-info" style="flex:1;min-width:140px">';
      html += '<div class="v-side-item-name">' + labels[prov] + '</div>';
      html += '<div class="v-side-item-sub" style="font-family:monospace;font-size:10px">' + masked + '</div>';
      html += '</div>';
      html += '<div style="display:flex;gap:4px;align-items:center">';
      html += '<input type="password" id="vkey-' + prov + '" placeholder="' + (prefixes[prov] || '') + '..." style="width:140px;padding:3px 7px;border-radius:5px;border:1px solid var(--v-border-med);font-size:10px;font-family:monospace;background:var(--v-bg-input);color:var(--v-text)" />';
      html += '<button class="vkey-save" data-prov="' + prov + '" style="padding:3px 8px;border-radius:5px;border:none;background:var(--v-accent);color:#fff;font-size:10px;cursor:pointer;font-weight:500">Save</button>';
      if (info.hasKey) {
        html += '<button class="vkey-del" data-prov="' + prov + '" style="padding:3px 6px;border-radius:5px;border:1px solid #FF453A;background:transparent;color:#FF453A;font-size:10px;cursor:pointer">ğŸ—‘ï¸</button>';
      }
      html += '</div></div>';
    });
    html += '</div>';

    // Mapping
    html += '<div class="v-side-group"><div class="v-side-group-title">ğŸ—ºï¸ OpenClaw â†” SpawnKit Mapping</div>';
    var mappings = [
      { oc: 'Skills', sk: 'Skills Panel', icon: 'âš¡' },
      { oc: 'Cron Jobs', sk: 'Calendar / Crons', icon: 'ğŸ“…' },
      { oc: 'Sessions', sk: 'Agents / Rooms', icon: 'ğŸ‘¥' },
      { oc: 'Memory', sk: 'Memory Panel', icon: 'ğŸ§ ' },
      { oc: 'Sub-agents', sk: 'Missions', icon: 'ğŸ¯' },
    ];
    html += '<div style="display:grid;grid-template-columns:auto 20px auto;gap:4px 10px;align-items:center;padding:6px 0">';
    html += '<div style="font-size:9px;font-weight:600;color:var(--v-text-muted);text-transform:uppercase;letter-spacing:0.5px">OpenClaw</div><div></div>';
    html += '<div style="font-size:9px;font-weight:600;color:var(--v-text-muted);text-transform:uppercase;letter-spacing:0.5px">SpawnKit</div>';
    mappings.forEach(function(m) {
      html += '<div style="font-size:12px;padding:3px 0">' + m.icon + ' ' + m.oc + '</div>';
      html += '<div style="font-size:11px;color:var(--v-accent);text-align:center">â†’</div>';
      html += '<div style="font-size:12px;padding:3px 0;color:var(--v-text-secondary)">' + m.sk + '</div>';
    });
    html += '</div></div>';

    settingsBody.innerHTML = html;

    // Wire up save/delete
    document.querySelectorAll('.vkey-save').forEach(function(btn) {
      btn.addEventListener('click', async function() {
        var prov = btn.dataset.prov;
        var input = document.getElementById('vkey-' + prov);
        var key = input ? input.value.trim() : '';
        if (!key) { showToast('Enter an API key'); return; }
        if (API) {
          var r = await API.saveApiKey(prov, key);
          if (r && r.success) { showToast('âœ… ' + labels[prov] + ' saved'); input.value = ''; renderSettings(); }
          else { showToast('âš ï¸ ' + (r.error || 'Failed')); }
        }
      });
    });
    document.querySelectorAll('.vkey-del').forEach(function(btn) {
      btn.addEventListener('click', async function() {
        var prov = btn.dataset.prov;
        if (API) {
          var r = await API.deleteApiKey(prov);
          if (r && r.success) { showToast('ğŸ—‘ï¸ ' + labels[prov] + ' deleted'); renderSettings(); }
        }
      });
    });
  }

  document.getElementById('vSettingsBackdrop').addEventListener('click', closeSettingsPanel);
  document.getElementById('vSettingsClose').addEventListener('click', closeSettingsPanel);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  STATUS BAR BUTTONS + CLOCK + UPTIME
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  document.getElementById('vsbMissions').addEventListener('click', openMissionsPanel);
  document.getElementById('vsbCrons').addEventListener('click', openCronPanel);
  document.getElementById('vsbMemory').addEventListener('click', openMemoryPanel);
  document.getElementById('vsbChat').addEventListener('click', openVillageChat);
  document.getElementById('vsbSettings').addEventListener('click', openSettingsPanel);

  // Command input â†’ open chat + send
  var cmdInput = document.getElementById('vsbCmdInput');
  cmdInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && cmdInput.value.trim()) {
      var cmd = cmdInput.value.trim();
      cmdInput.value = '';
      openVillageChat();
      chatInput.value = cmd;
      sendChat();
    }
  });

  // Clock
  function updateClock() {
    var now = new Date();
    var h = now.getHours().toString().padStart(2, '0');
    var m = now.getMinutes().toString().padStart(2, '0');
    var el = document.getElementById('vsbClock');
    if (el) el.textContent = h + ':' + m;
  }
  updateClock();
  setInterval(updateClock, 30000);

  // Uptime
  var _startTime = Date.now();
  function updateUptime() {
    var elapsed = Date.now() - _startTime;
    var h = Math.floor(elapsed / 3600000);
    var m = Math.floor((elapsed % 3600000) / 60000);
    var el = document.getElementById('vsbUptime');
    if (el) el.textContent = h + 'h' + m.toString().padStart(2, '0') + 'm';
  }
  updateUptime();
  setInterval(updateUptime, 60000);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  ESCAPE KEY â€” Close topmost panel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      if (chatOverlay.classList.contains('open')) closeVillageChat();
      else if (detailOverlay.classList.contains('open')) closeVillageDetail();
      else if (missionsOverlay.classList.contains('open')) closeMissionsPanel();
      else if (cronOverlay.classList.contains('open')) closeCronPanel();
      else if (memoryOverlay.classList.contains('open')) closeMemoryPanel();
      else if (settingsOverlay.classList.contains('open')) closeSettingsPanel();
    }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  LIVE ACTIVITY SIMULATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  var ACTIVITY_VERBS = {
    ceo: ['Orchestrating','Reviewing','Planning','Delegating'],
    atlas: ['Coordinating','Documenting','Syncing','Scheduling'],
    forge: ['Building','Deploying','Optimizing','Refactoring'],
    hunter: ['Prospecting','Analyzing','Pitching','Converting'],
    echo: ['Crafting','Writing','Designing','Publishing'],
    sentinel: ['Scanning','Auditing','Reviewing','Monitoring']
  };
  var ACTIVITY_OBJECTS = {
    ceo: ['fleet ops','quality pipeline','sprint goals','roadmap'],
    atlas: ['workflows','deployment pipeline','cron schedules','fleet status'],
    forge: ['security middleware','API endpoints','live bridge','infra'],
    hunter: ['lead pipeline','pricing tiers','market segments','funnel'],
    echo: ['content scripts','brand story','video pipeline','social'],
    sentinel: ['codebase','security posture','compliance','artifacts']
  };

  // â”€â”€ Announce readiness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (window.parent !== window) {
    window.parent.postMessage({ type: 'village:ready', theme: 'simcity', timestamp: Date.now() }, '*');
  }
  window.__VILLAGE_THEME = 'simcity';

  // â”€â”€ SpawnKit integration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (window.SpawnKit) {
    SpawnKit.on('data:refresh', function(data) {
      if (data.agents) {
        data.agents.forEach(function(d) {
          var a = (typeof agents !== 'undefined') ? agents.find(function(x) { return x.name === d.name; }) : null;
          if (a && d.status) a.status = d.status;
        });
        var countEl = document.getElementById('vsbAgentCount');
        if (countEl) countEl.textContent = data.agents.length + ' Agents';
      }
    });
    if (SpawnKit.mode === 'live') SpawnKit.refresh();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  INIT (called after village images load)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window.initVillagePanels = function() {
    prefetchData();
    setInterval(prefetchData, 30000);
    loadLiveAgentData();
  };

})();
</script>
</body>
</html>
